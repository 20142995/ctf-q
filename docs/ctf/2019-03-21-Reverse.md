[迷宫问题的三种求解方法](https://blog.csdn.net/m0_37870649/article/details/105096303)

[TOC]
# TODO
unicorn
https://www.hetianlab.com/cour.do?w=1&c=CCID660c-8b63-44e9-929e-5a1edef2e2bd
https://www.52pojie.cn/thread-1026209-1-1.html
https://mp.weixin.qq.com/s/mqXF9jpULSAFp3VyeJoVSA


# 工具环境配置
[Reverse Engineering with Ghidra_](https://bbs.pediy.com/thread-250805.htm)
[Reverse Engineering Tutorial](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)
[IDA如何patch掉花指令？](https://bbs.pediy.com/thread-263323.htm)
[The Ghidra book - The Definitive Guide [Complete]](https://bbs.pediy.com/thread-262585.htm)
[《Windows PE权威指南》](https://bbs.pediy.com/thread-263552.htm)
[Ghidra操作手册](https://www.kanxue.com/book-section_list-64.htm)

[综合 | CTF逆向指南](https://mp.weixin.qq.com/s/SBtFqLNjXzl55WvtBmPtPw)

# Q1 

x64dbg 载入后为什么不在入口 在7xxxx地址。

# 逆向

## 解题思路
1. winhex直接搜flag

2. 用 die/exeinfo pe 查壳。

        ELF文件，用winhex打开搜下是不是upx
        如果提示 yoda's Protector, 有可能是UPX壳， 扔到 winhex 搜到UPX，搜到为UPX壳。

    2.1 如果是upx用upx -d filename 脱壳

2. 没壳拖入IDA和OD

    Ctrl+S 看rdata段
    遇到 __debugbreak() 汇编窗口看是 int ,3 ， 可能需要nop掉。
    v3 == 125 这种, IDA中按R转成字符看看。
                        也可能是按A转换成字符串

4. OD 直接改jmp跳转到flag。见 xctf game
4. dbg直接改jmp跳转到flag。见 xctf game
3. IDA直接改EIP跳转到flag。见下面
4. 看start函数。如果start后面还有执行。直接看后面执行。
        异或加密直接改寄存器的值，改正确的种子进去，让ida自己解密。
4. 脱壳：
       用x64/x32dbg(不用od) ,走几步一个大跳。就开脱。插件 Scylla, IAT自动搜索。
             1. 不使用结果。
             2. 导入中删除无效指针
             3. 转储 4.PE重建 5.修复转储

4. 逆向分析, v9 = 'wodah'; 小端存储注意, join时需要反序
5. 暴破angr, ponce
6. apk: 1.jadx 2. jeb 看源码，也要看smali代码
7. jar: jeb, jd-gui
         jd-gui加编码  java -D'file.encoding='=utf-8 -jar .\jd-gui-1.6.6.jar exercise2.jar
8. pyc文件 uncompyle6 -o pcat.py pcat.pyc
9. smc自解码  羊城杯2021 BabySmc, BUUCTF-re-[GWCTF 2019]re3 smc,



高级
[求解迷宫问题的三种方法(python实现)](https://blog.csdn.net/qq_29681777/article/details/83719680)



### FAQ
1. upx脱壳时：提示：无法读取被调试进程 XXXXXXX 的内存。

```   
方法1.去除随机地址。
方法2.请使用 52pojie WinXP虚拟机2.0。或者去掉随机地址ASLR
```

### Go语言的逆向

多看asm窗口，字符变量比较明显

### VB/MFC

1. 查看  OnInit 函数
2. 搜索 MessageBoxW 函数
3. 搜索 window , callWindowProcW, CreateWindowExW

EnableWindow 没隐藏 , MoveWindow, ShowWindow分析

4. PostMessageW 

断点---
https://mp.weixin.qq.com/s/seTVPrbeN7pGRFk0F4Zdnw
Bp GetDlgItemTextA

### 代码阅读/IDAC

byte型保留0xff，可以用 `& 0xff` 或 `% 0x100`

++*((_QWORD *)result + 2); QWORD型(8bytes) +2相当于 +了2个QWORD长度, 即 result地址+16

### C/C++/CPP
operator[](v6,i);

```c
// int a[6];
v6[i]
```

异或32, F^0x20 == F^32 == f 是转换大小写
        {^32==[


### 数据处理
大整数注意可能是小端存储，要倒序过来。

wchar_t 16位或32位。

### 题目类型
#### 迷宫题 
```
as[10*dword_407034+dword_407030] == 'F'
```
10是列宽


### smc自解码
羊城杯2021 BabySmc, BUUCTF-re-[GWCTF 2019]re3 smc,
https://blog.csdn.net/qq_41923479/article/details/80377708
https://blog.csdn.net/Palmer9/article/details/105034093/


phantom https://www.bilibili.com/video/BV1ZT4y1o7H8

mprotect 修改权限可以改代码了。  ida按个c就能变code， 按p变函数, 然后就能f5了。
按y 可改类型 char*
### 反调试技术

https://ctf-wiki.org/reverse/windows/anti-debug/ntglobalflag/

## 查看文件信息

Linux下 file xxxx

## Tools
python/pyc 反编译 https://github.com/rocky/python-uncompyle6/releases

## IDA使用
[入门](https://www.52pojie.cn/forum.php?mod=viewthread&tid=886103)

[IDA作者Blog](https://hex-rays.com/blog/)

转换200 单位为String, 右击数据 Array 输入200, 再鼠标选中按A
数据修正 按D 修改字节为1,2,4,8字节,
　　     按A -- Ascii
         按*  Array
         按O Offset 将此处定义为地址偏移
函数修正 起始地址按P
指令修正 按D 修正不会跳转的地址

设置 - Disassembly - auto comments
### 环境配置
[IDA7.5 启动基础配置 ](https://bbs.pediy.com/thread-264346.htm)
```
@rem 7032.bat file for bootstrap ida.exe with py2
@set path=D:\ProgramData\graphviz_my\bin;%path%
@set path=D:\ProgramData\Anaconda2;D:\ProgramData\Anaconda2\Scripts;D:\ProgramData\Anaconda2\Library\bin;D:\ProgramData\Anaconda2\Lib;D:\ProgramData\Anaconda2\DLLs;D:\Program Files\IDA 7.0\python;%path%
@set PYTHONPATH=D:\Python;D:\Python\lib;D:\Python\scripts
@start ida.exe
```

### 分析Tips
连续内存看成同一变量, 都是v17
```
__int128 v17;  // [esp+Ch]
__int128 v18;  // [esp+1Ch]
int v19;       // [esp+2Ch]
int v20;       // [esp+30Ch]
__int16 v21;   // [esp+34Ch]
int v22;       // [esp+38h]
```

### 快捷键

A Data转为字符串
```
选中多个后按A
db 1
db 0
```

如果运行时会弹2个错误确认，使用F4来运行。

Ctrl + E => 跳到Entry => main

IDA-View 转字串时, 显示不全先D再S
    S 转字串

\ 隐藏转换 *QWORD
H 转16进制
N rename , 再按F5更新

16进制变量值 按 c就能变code， 按p变函数, 然后就能f5了。

### 设置

Options-General...-strings 把gb2312 改为UTF-8。点击ok

### 操作

打开hex窗口： View-Open Subviews-
IDA view 右击变量 jump to a new hex window
#### 函数操作
删除函数：在函数窗口中选中函数后，按Delete键。
定义函数：在反汇编窗口中选中对应行后，按P键。
修改函数参数：在函数窗口中选中并按Ctrl＋E组合键，或在反汇编窗口的函数内部按Alt＋P组合键。

### 插件 
keypatch

https://mp.weixin.qq.com/s/96nkW8oFk4w7HMZrKqw6jQ

[Ponce使用方法](https://www.cnblogs.com/wgf4242/p/13064986.html)

https://github.com/illera88/Ponce/actions/runs/115490440

https://github.com/illera88/Ponce/tree/master/latest_builds

https://www.bilibili.com/video/BV1QK411W7ZZ

https://blog.csdn.net/Hotspurs/article/details/106039643
### 常用方式
* 将文件丢入IDA，定位main函数，F5

* 只有一个信息框从弹窗下手

```
    1.搜索message  API：View-Imports ，底下的搜索栏搜 message, 看到MessageBoxW
    2.双击进去，Ctrl+X查看调用，发现没有被调用，于是放过
    3.弹窗有可能为窗口类，搜索window --- ShowWindow
```

连续的定义， 可试着在汇编窗口看。

Feature | Description|Menu|Windows
--|--|--|--
数字转字符 | 右击 - Char, 字串-大端存储的，需倒序。在hex dump里看是正常的 || <kbd>R</kbd>
导出数据 | 双击变量进入, 选中数据后 导出 => C unsign char array decimal |Edit - Export data | <kbd>Shift</kbd> <kbd>E</kbd>
切换变量大小| 双击变量进入的 反汇编数据窗口，点击变量 |右击-Data | <kbd>D</kbd> 可切换 Byte, Word, Dword
显示数组大小| 双击变量进入的 反汇编数据窗口，点击变量 |右击变量-Array| 按*键

如果它函数反编译出来的变量很奇怪，可以将这个函数undefine掉然后再define，这样看的变量就会正常很多

Alt+D, Setup Data types

#### 直接跳转EIP
![x](imgs/ida03.jpg)
### FAQ

#### F5提示：positive sp value has been found!!!!!“的解决方法/修复栈指针错误

[Link](https://blog.csdn.net/feibabeibei_beibei/article/details/85238676)

options->General->Disassembly->√Stack Pointer

在负值上一行Alt+K 输入对应值平栈
#### Patch花指令

方法1 单击要修改位置, Alt+4(HexView), F2 修改为90, F2保存
方法2 Edit Patch - change bytes 为90

常见花指令，进行nop, 其他代码按c转成代码 再按P ,再F5
```
xor eax,eax
jz xxxxx
```

### 常用伪代码分析

int 80h,  中断
0x90 == nop

#### 连续的Char可能=String

    CHAR String; // [esp+34h] [ebp-20004h]
    char v19; // [esp+35h] [ebp-20003h]    =String[0]
    char v20; // [esp+36h] [ebp-20002h]    =String[1]
    char v21; // [esp+37h] [ebp-20001h]    =String[2]
    char v22; // [esp+38h] [ebp-20000h]    =String[3]
    char v23; // [esp+39h] [ebp-1FFFFh]    =String[4]
    char v24; // [esp+3Ah] [ebp-1FFFEh]    =String[5]
    char v25; // [esp+3Bh] [ebp-1FFFDh]    =String[6]
    char v26; // [esp+10034h] [ebp-10004h] =String[7]
    char v27; // [esp+10035h] [ebp-10003h] =String[8]
    char v28; // [esp+10036h] [ebp-10002h] =String[9]

相当于

    CHAR String[9]; // 上面地址也都是差1h

#### strcmp

strcmp(a,b) 相等时返回0,  `!strcmp(a,b)` 表示a,b相等为True

### IDAPython
示例 朱雀杯 tree

#### 执行Python脚本
https://www.hex-rays.com/products/ida/support/idapython_docs/

Description|Menu|Windows
--|--|--
执行Python脚本| `File - Sript File` | <kbd>Alt</kbd><kbd>F7</kbd>
Python命令窗口| `File - Sript Command` <br>Script Language选Pyhon| <kbd>Shift</kbd><kbd>F2</kbd>

#### IDAPython|打印Dword地址值
[Link](https://www.52pojie.cn/thread-1117330-1-1.html)

```python
addr=0x08048A90 # 数组的地址
arr=[]
for i in range(6): # 数组的个数
    arr.append(Dword(addr+4*i))
print(arr)
```
#### IDAPython|打印32长度的bytes

```python
from idaapi import *
bytes_addr = 0xCFFFD6F8
bytes_size = 32
data = get_bytes(bytes_addr,bytes_size)
L = [hex(ch) for ch in data]
print (L)
```
#### 大端与小端 

假设一个十六进制数0x12345678

大端的存储方式是：12,34,56,78，然后读取的时候也是从前往后读

小端的存储方式是：78,56,34,12，然后读取的时候是从后往前读取

### FAQ
Q: 怎样从伪代码(F5)返回到 汇编代码
A: 按tab, 右击图 text view

Q: IDA，怎样在图(Proximity Browser)中展开显示子函数的汇编
A: space键 : 切换 graph view 和 text mode

### 快捷键

Esc 后退
Tab 切换伪代码和汇编

Enter 进入

G jump to address

Ctrl+P jump function

Shift+F12 查看文本

F5 反汇编成代码

Ctrl+X 查看调用

C 显示为代码

A 显示为String

Space 切换视图

显示为Array：　双击变量，进入反汇编窗口按*
### 变量显示

翻译
    
    A[(unsigned __int8)((unsigned __int8)B[i] / 3u - 2)] ) 等于
    A[B[i] / 3 - 2]

![123](./imgs/ida_1.png)

注意 0x6c和 0x68也要包含进来

    a = 'lk2j9Gh}AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX{CMt8SZo]'
    b = [0x48, 0x5D, 0x8D, ..., 0x1B, 0, 0]

#### 快速选中连续的bytes
定位好后，Ctrl+1, hex dump, 然后再选
#### 如何查看 函数地址
在函数窗口选中函数后 Ctrl+E
### 使用 Patch Program
1.伪代码窗口中 选中要使用Patch的位置，

    1.1 直接Ctrl+Alt+K 或
    1.2 按Tab, 进入反汇编窗口,  菜单 Edit-KeyPatch (Ctrl+Alt+K)
    1.2.1 或 反汇编窗口 Edit-"Patch Program"-Assemble

2. 修改，菜单 Edit-"Patch Program" - Apply Patches to input file.

### 使用远程调试, 调试windows程序和linux程序相同。

Windows 下的 IDA     

1. 在 IDA 的安装目录/dbgsrc/找到 linux_server 和 linux_serverx64 拷贝到 linux 虚拟机中
2. 在 linux 中运行 linux_server 并在 linux 中运行要调试的 demo
3. Debugger -- Attach -- Remote Linux debbuger

4. 配置客户端调试选项

路径默认是 linux_server 的位置, 放在同文件夹下可直接使用文件名。 否则使用全路径名。 / 开头

比如, /mnt/hgfs/vmware/dbg/runthis 或直接使用 runthis

配置好调试的服务端后，接下来开始配置客户端IDA，正常启动IDA打开【Debugger】-【Run】-【Remote Linux debugger】来设置调试选项

Debugger - Process Option

![Alt text](imgs/ida01.png)

__调试win下程序__

也使用远程的方式调试。

#### 调试常用

Description|Key binding
--|--
Step into|<kbd>F7</kbd>
Step over|<kbd>F8</kbd>

菜单 `Debugger - Debugger Windows - Watch View`


## android apk, java / 动态调试
[DASCTF八月挑战赛 Android 逆向 apkrev](https://mp.weixin.qq.com/s/Z26uEKDtmhnXapscWEEHSQ)

jadx打开。关键函数有native--表示反编译so文件。

[动态调试apk](https://the_itach1.gitee.io/2021/08/02/D0g3比赛平台 re wp/#极客巅峰-medical-app)
https://www.cnblogs.com/ddms/p/8820044.html
https://blog.csdn.net/freeking101/article/details/106701908
[2](https://blog.csdn.net/freeking101/article/details/106701908)
https://bbs.pediy.com/thread-269252.htm
https://bbs.pediy.com/thread-269320.htm

android 可以在strings.xml中找到字符串的值。

ida android 调试 [L1](https://www.jianshu.com/p/16e9966817c5)  [L2](https://www.jianshu.com/p/16e9966817c5)

### navtive 相关

关键函数有native。用ida在x86打开对应的文件。（如果不行再用x64的。）

### 简单加壳 梆梆安全加固

https://blog.csdn.net/lostnerv/article/details/106040085

## java 反编译

### jd-gui
Bug: 如果打不开class文件，多半是类名和文件名不一致。可以先新建一个hi.java，然后把class文件放到此文件夹，用jd-gui打开 hi.java， class文件就能正常显示了。

### Jeb
拉进入后，右击main, 解析(Decompiler)

### anrdoid killer
重新打包-- 菜单-android 批量编译

### Android reverse
[由2021ByteCTF引出的intent重定向浅析](https://mp.weixin.qq.com/s/A8g7cIyM480Y_gXFwiGjMg)

#### IDA基本用法
https://www.bilibili.com/video/BV1BR4y1J7Hf

jadx 打开，保存后。 源文件

```
System.loadLibrary("wtf");
public static native String getSign(String arg0, String arg1, String arg2)

```
会加载 libwtf.so 文件。 native关键字,表示从so中导出的getSign方法, 用ida载入so文件

1. Export窗口。有 `Java_com_sichuanol_cbgc_util_SignManager_getSign` ,前面是包名后面是类名+方法名

2. File - Load File - Parse C header file(Ctrl+F9), 载入 jni.h
3. 选择参数1即a1, Convert to struct *
4. 选择_JNIEnv

#### jni, native关键字和so文件

https://blog.csdn.net/re_psyche/article/details/83790851
https://blog.csdn.net/getsum/article/details/85217885

解压后用jeb打开mainactivity， 解析，调用了 hellolib

发现关键函数是 native 的，所以要查看hellolib.so文件。

jeb里找到后用16进制查看。向下翻页找DDCTF****@***.com 即flag.（或者winhex打开，然后搜索ctf找到flag）

```
MD5Digest(v18, v22, v30)  // 输入, 长度 输出, C语言中通常不用返回值
```
#### IDA动态调试APK

https://www.bilibili.com/video/BV1W3411y7tD

```
adb push android_server /data/local/tmp
adb shell
su
cd /data/local/tmp
chmod 777 android_server
./android_server

// 换窗口
adb forward tcp:23946 tcp:23946
```

IDA , Debugger - Attach - Remote Arm Linux/Android debugger, 勾选

```
Suspend on process entry poiont
Suspend on thread start/exit
Suspend on library load/unload
```

确定， hostname: 127.0.0.1

选择要调试的APK确定

查看 Modules窗口，找到对应的so文件双击。

双击方法名称。

动态时会隐藏函数名，所以还开2个IDA一个看地址及函数名称。

下断点，执行 断下后。。

在hex view, syncronize with r0

寄存器窗口  通常R0-R3 参数 R4-R8局部变量 LR返回地址 PC当前位置 SP栈顶

## Ollydbg
插件-搜索-中文-unicode  里面找有没有你赢了，flag等相关字，
[调试子进程](https://blog.csdn.net/darcy_123/article/details/101552444)

bp printf # printf 断点

### FAQ
Q:如何加入参数调试？

A:菜单:调试-参数

Q: 怎样删除硬件断点？ 

A: 调试-硬件断点
### 快捷键

快捷键|说明
--|--
F4|运行到光标位置
F2|断点
Ctrl+G|转到表达式 400001
Ctrl+S|查找命令序列
Ctrl+B|查找二进制
1-9| NOP 1-9个字节
Alt+Bksp|撤销修改

寄存器窗口 Z 位关系到跳转

左下角 M1-M5

      记录你当前内存操作最后一次的位置及 显示格式    
      选中M1  ： dd  00401000 
      选中M2：  db 00401020 
      选中M3：  让内存以字符串形式显示 
      接着你切换 M1 M2 M3就发现内存的显示

条件断点

    eax == 040000
    eax == 25 , 表示的是 0x25
    堆栈窗口右击-地址-相对于ESP，如要记录Conditional_bp.exe调用CreateFileA函数的情况，在CreateFileA函数的第一行，按Shift+F4键 [STRING[ESP+4]]=="c:\\1212.txt"
    CreateFIleW函数地址处，按下Shift+F2，输入条件：[UNICODE[esp+4]]=="C:\\Test\\123.txt"

### 条件断点

Shift+F2, eax == 0400000
### TODO
是否支持

    bp main
    bp kernel32!createprocess
    bp [apiname]

## x64dbg
插件xanalyzer
   plugin或右键, analyze selection / module

设置-系统断点，×，即可断在程序开始处

按g，显示流程图

保存修改: file-patch file

sync command: 流程图 右击 sync with origin

going back into the stpped in call: 流程图 按SS 

[trace recording]
    
    方便观察走了哪些路径，便于分析
    trace --> trace record --> word
    then, step over line by line(F8)

## angr 二进制框架

[L1](https://blog.csdn.net/xiangshangbashaonian/article/details/82825488) [L2](https://www.freebuf.com/sectool/143056.html)

__示例1: WhaleCTF题目 r100__

```python
import angr
proj = angr.Project("./r100",auto_load_libs=False)
state = proj.factory.entry_state()
simgr = proj.factory.simgr(state) 
simgr.explore(find=0x400844,avoid=0x400855) # 0x400844 =>输出正确答案的地址, 0x400855 错误跳转到erorr的地址
a = simgr.found[0].posix.dumps(0)
print(a) # 直接跑出答案
```

__示例2:  [ais3_crackme](https://github.com/angr/angr-doc/raw/master/examples/ais3_crackme/ais3_crackme)__

这个是需要跟参数的, 

通过claripy模块，来构造输入。claripy是一个符号求解引擎和z3类似，我们完全可以将其当成是z3进行使用。

claripy关于变量的定义在claripy.ast.bv.BV当中

通常使用claripy.BVS()创建位向量符号

```python
import angr   #导入angr
import claripy    #导入claripy
proj = angr.Project("./ais3_crackme")    #载入文件
argv1 = claripy.BVS('argv1',50*8)    #B是bit 1字节=8bit  猜测输入不多于50字节 就是50*8
state = proj.factory.entry_state(args=['./ais3_crackme',argv1])
simgr = proj.factory.simgr(state)
simgr.explore(find=0x400602,avoid=0x40060E)    #成功位置及失败位置
print(simgr.found[0].solver.eval(argv1))    #转成ascll码输出
print(simgr.found[0].solver.eval(argv1,cast_to=bytes))    #直接输出字符

```

## 脱壳、常见壳
### 去除随机地址ASLR

Stud_PE载入后， 左下角，最下面。dll特征 - 点击+号 - 动态基址 去√

### upx壳

kali中自带 `upx -d filename`

手动脱壳1

    直接CTRL+F，输入popad
    0040EA0E     61            popad                 //F2下断，F9运行，F2取消断点，单步F8
    0040EA0F   - E9 B826FFFF   jmp NOTEPAD.004010CC

手动脱壳1-esp定律

遇到向上跳转的jz等向上跳循环，直接移到下一行F4.

F8单步找到 pushad的下一句，看右侧寄存器窗口ESP变红，

1.右击ESP - HW Break [ESP]

    方式 1.1 或在数据窗口跟随，此时，在数据窗口中，右单击“数值”，选择“断点”->“设置硬件访问断点”->“Word”，按 Shift+F9
    方式 1.2 https://www.52pojie.cn/forum.php?mod=viewthread&tid=314918
    1.2.1 或 来到pushad语句后， 在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值）
    1.2.2 hr ESP(关键标志下一行代码所指示的ESP值(单步通过))

2.F9运行。继续单步，直到下一行是JMP之类的跳过去，看到像程序入口的地方,右击，用ollydump脱壳将程序DUMP出来即可，如

      0040EA0F   - E9 B826FFFF     jmp UPX.004010CC
      0040EA14     0000            add byte ptr ds:[eax],al
      0040EA16     0000            add byte ptr ds:[eax],al
      0040EA18     0000            add byte ptr ds:[eax],al
      0040EA1A     0000            add byte ptr ds:[eax],al
      0040EA1C     0000            add byte ptr ds:[eax],al

     此时，再按F8,便来到了OEP处，DUMP程序。


## 其他
### Python/pyd

https://www.bilibili.com/video/ magic
先import maigc, 然后dir(magic)看有哪些奇怪的调用一下。

### Python/pyc/pyinstaller
http://81.70.81.64/dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/#toc-head-3
https://www.cnblogs.com/pluie/p/13621823.html

pyc可以直接python x.pyc运行

1. `python pyinstxtractor.py 1py.exe` 看是什么版本, 
2. 有pyz/pyd文件加密时需要对应的python版本解密, 见下面
2. 可能要补或改magic code为显示的版本。
         可以看struct文件的第一行
3. uncompyle6 -o pcat.py pcat.pyc
python 3.3 + 使用 pip install uncompyle6,  uncompyle6 filename>xxx.py

查看 pyc 对应的python版本 Linux: `file filename.pyc`

python源码的 Python-3.x.x/Lib/importlib/_bootstrap_external.py
https://github.com/google/pytype/blob/master/pytype/pyc/magic.py

magic code:

```
Magic num | bit field | Timesatmp | FileSize

python版本

2.5      :B3 F2 0D 0A
2.7      :03 F3 0D 0A
3.3      :9E 0C 0D 0A
3.5      :16 0D 0D 0A
3.7.0    :42 0D 0D 0A 00 00 00 00  43 AB 75 60 2E 00 00 00
3.7.4    :42 0D 0D 0A 00 00 00 00  63 AF 36 3E 0C 00 00 00
3.8.1    :55 0D 0D 0A 00 00 00 00  43 AB 75 60 2E 00 00 00
```
查看当前Magic code:
```python
import importlib
importlib.util.MAGIC_NUMBER.hex()
'550d0d0a'
```
https://blog.csdn.net/weixin_46263782/article/details/120939260

[格式详解](https://kdr2.com/tech/main/1012-pyc-format.html)
[格式详解](https://www.cnblogs.com/blili/p/11799483.html)
[py2示例](http://www.xumenger.com/01-python-pyc-20180521/)

看Magic Code可知是py2还是py3
```
42 0D 0D 0A 00 00 00 00 00 47 79 61 33 00 00 00
Maigc Code |           |33617947时间戳| TYPE_CODE字段，见marshal.c
E3 00 00 00 00 00 00 00 00 00 00 00 00 03 00 00
00 40 00 00 00 73 1E 00 00 00 65 00 64 00 64 01
83 02 5A 01 65 01 A0 02 A1 00 5A 03 65 04 65 03
83 01 01 00 64 02 53 00 29 03 7A 05 78 78 2E 70
```

PyCodeObject对象----code block:
```
1个字节0x73为TYPE_CODE字段， 表示该字段为string格式；
4个字节0x1E00 0000表示code block段的数据部分占用0x1E个字节，即长度为30；
接下来30个字节65006400 ...... 5300 为该TYPE_CODE字段（数据类型string）部分，也就是pyc文件中包含的字节码指令
再往下的逐个TYPE_CODE字段都是重复结构的，用来表示PyCodeObject对象中的一些其他参数
```

见 `## pyc | DASCTF Oct X 吉林工师 欢迎来到魔法世界～ 魔法叠加`
#### pyz/pyd 文件
用相同版本反编译会出pyz
https://www.jianshu.com/p/b5404e65416d
https://miaotony.xyz/2021/10/25/CTF_2021bailu/#toc-heading-5

1.安装pyinstaller, 找到 pyimod02_archive.py复制到程序目录， 在文件最后面写入内容，执行解密文件变成pyc。
```python
inf = open(r'PYZ-00.pyz_extracted\baby_python\baby_core.pyc.encrypted', 'rb')
c = Cipher()

buf = c.decrypt(inf.read())
buf = zlib.decompress(buf)

out = open(r'PYZ-00.pyz_extracted\baby_python\baby_core.pyc', 'wb')
out.write(buf)
print('written down %d bytes' % len(buf))

inf.close()
out.close()
```
2.添加文件头
3.uncompyle6解密Pyc文件

### 编译一个pyc
python -m py_compile abc.py

```python
import py_compile
py_compile.compile('abc.py')
```
#### 查看 byte code
```python
# 1
python -m dis generate_bytecode.py

# 2
import dis
source = open("xx.py").read()
co = compile(source, 'xx.py', 'exec')
dis.dis(co)
```
## Wiki
### 内存相关知识 

扩展的存储单位有：

计算机存储容量大小以字节数来度量，1024进位制：

    1024B=1K(千)B  
    1024KB=1M(兆)B 
    1024MB=1G(吉)B 
    1024GB=1T(太)B 

　　 这是常用的五个，至于PB，EB，ZB，YB，BB，NB，DB几乎在日常使用中是不会遇到的。

　　

而Int8，Int16，Int32，nt64，后面的数字就代表这个数据类型占据的空间。

    Int8, 等于Byte, 占1个字节.
    Int16, 等于short, 占2个字节. -32768 32767
    Int32, 等于int, 占4个字节. -2147483648 2147483647
    Int64, 等于long, 占8个字节. -9223372036854775808 9223372036854775807

样, 看起来比short,int,long更加直观些!

　　另外, 还有一个Byte, 它等于byte, 0 - 255.

### 常见语言的入口点


VB：

    004012D4 >  68 54474000     push QQ个性网.00404754
    004012D9    E8 F0FFFFFF     call <jmp.&MSVBVM60.#100>
    004012DE    0000            add byte ptr ds:[eax],al
    004012E0    0000            add byte ptr ds:[eax],al
    004012E2    0000            add byte ptr ds:[eax],al
    004012E4    3000            xor byte ptr ds:[eax],al
    004012E6    0000            add byte ptr ds:[eax],al
    004012E8    48              dec eax


delphi:

    004A5C54 >  55              push ebp
    004A5C55    8BEC            mov ebp,esp
    004A5C57    83C4 F0         add esp,-10
    004A5C5A    B8 EC594A00     mov eax,openpro.004A59EC


BC++:

    00401678 > /EB 10           jmp short btengine.0040168A
    0040167A   |66:623A         bound di,dword ptr ds:[edx]
    0040167D   |43              inc ebx
    0040167E   |2B2B            sub ebp,dword ptr ds:[ebx]
    00401680   |48              dec eax
    00401681   |4F              dec edi
    00401682   |4F              dec edi
    00401683   |4B              dec ebx
    00401684   |90              nop
    00401685  -|E9 98005400     jmp 00941722
    0040168A   \A1 8B005400     mov eax,dword ptr ds:[54008B]
    0040168F    C1E0 02         shl eax,2
    00401692    A3 8F005400     mov dword ptr ds:[54008F],eax
    00401697    52              push edx
    00401698    6A 00           push 0
    0040169A    E8 99D01300     call <jmp.&KERNEL32.GetModuleHandleA>
    0040169F    8BD0            mov edx,eax


VC++:

    0040A41E >  55              push ebp
    0040A41F    8BEC            mov ebp,esp
    0040A421    6A FF           push -1
    0040A423    68 C8CB4000     push 跑跑排行.0040CBC8
    0040A428    68 A4A54000     push <jmp.&MSVCRT._except_handler3>
    0040A42D    64:A1 00000000  mov eax,dword ptr fs:[0]
    0040A433    50              push eax
    0040A434    64:8925 0000000>mov dword ptr fs:[0],esp
    0040A43B    83EC 68         sub esp,68
    0040A43E    53              push ebx
    0040A43F    56              push esi
    0040A440    57              push edi


MASM(汇编):

    004035C9 >  6A 00           push 0
    004035CB    E8 A20A0000     call <jmp.&kernel32.GetModuleHandleA>
    004035D0    A3 5B704000     mov dword ptr ds:[40705B],eax
    004035D5    68 80000000     push 80
    004035DA    68 2C754000     push 11.0040752C
    004035DF    FF35 5B704000   push dword ptr ds:[40705B]
    004035E5    E8 820A0000     call <jmp.&kernel32.GetModuleFileNameA>
    004035EA    E8 87070000     call 11.00403D76
    004035EF    6A 00           push 0
    004035F1    68 0B364000     push 11.0040360B
    004035F6    6A 00           push 0
    004035F8    6A 64           push 64
    004035FA    FF35 5B704000   push dword ptr ds:[40705B]

### C 语言符号优先级

| 表2 运算符优先级和结合律                                 |                                                              |          |
| -------------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 优先级                                                   | 运算符                                                       | 结合律   |
| 1                                                        | 后缀运算符：[]   ()   ·     ->   ++   --(类型名称){列表}     | 从左到右 |
| 2                                                        | 一元运算符：++     --   !   ~    +   -   *   &     sizeof_Alignof | 从右到左 |
| 3                                                        | 类型转换运算符：(类型名称)                                   | 从右到左 |
| 4                                                        | 乘除法运算符：*   /   %                                      | 从左到右 |
| 5                                                        | 加减法运算符：+   -                                          | 从左到右 |
| 6                                                        | 移位运算符：<<   >>                                          | 从左到右 |
| 7                                                        | 关系运算符：<<=   >>=                                        | 从左到右 |
| 8                                                        | 相等运算符：==   !=                                          | 从左到右 |
| 9                                                        | 位运算符 AND：&                                              | 从左到右 |
| 10                                                       | 位运算符 XOR：^                                              | 从左到右 |
| 11                                                       | 位运算符 OR：\|                                              | 从左到右 |
| 12                                                       | 逻辑运算符 AND：&&                                           | 从左到右 |
| 13                                                       | 逻辑运算符 OR：\|\|                                          | 从左到右 |
| 14                                                       | 条件运算符：?:                                               | 从右到左 |
| 15                                                       | 赋值运算符：                                                 | 从右到左 |
| | =       +=     -=    *=   /=    %=    &=     ^=    \|= |                                                              |       
| | <<=      >>=                                           |                                                              |       
| 16                                                       | 逗号运算符：，                                               | 从左到右 |

## 加密算法

### rc4
把 enc 用key再跑一遍即可

##cpp/c++

ostream 输出流,可重载操作符
https://blog.csdn.net/luoyayun361/article/details/87972929

### 练习

[writeup](writeup/xctf_game.md)

[xctf_NJUPT CTF 2017_maze.md](writeup/xctf_NJUPT CTF 2017_maze.md)

# CTF特训营

## 10.1 常规分析

### API断点

GetWindowText和GetDlgItemText

### 10.1.2 常见加密法识别

#### TEA

固定常数 0x9e3779b9 或 0x61c88647

#### rc4 流密码

加解密用一个函数 再跑一下密文即可

```c
// 初始化函数
void rc4_init(unsigned char *s,unsigned char *key, unsigned long Len) {
    int i = 0, j = 0;
    // char k[256]={0};
    unsigned char k[256] = {0};
    unsigned char tmp = 0;
    for (i = 0; i < 256; i++) {
        s[i] = i;
        k[i] = key[i % Len];
    }
    for (i = 0; i < 256; ++i) {
        j = (j + s[i] + k[i]) % 256;
        tmp = s[i];
        s[i] = s[j]; // 交换 s[i] 和 s[j]
        s[j] = tmp;
    }
}

/* 加解密 */
void rc4_crypt(unsigned char *s, unsigned char *Data, unsigned long Len){
    int i = 0, j = 0, t = 0;
    unsigned long k = 0;
    unsigned char tmp;
    for (k = 0; k < Len; ++k) {
        i = (i+1) % 256;
        j = (j + s[i]) % 256;
        tmp = s[i];
        s[i] = s[j]; // 交换 s[i] 和 s[j]
        s[j] = tmp;
        t = (s[i] + s[j]) % 256;
        Data[k] ^= s[t];
    }
}
```
#### MD5

关键字
0x67452301 0xefcdab89 0x98badcfe 0x10325476`
### 10.1.3 求解flag

#### 线性变换的求解

输入 1字节不同
123456
a23456
输出只有1字节不同时，确定为线性变换。。可以进行单字节爆破。
#### 约束求解

z3
# CTF从0到1

## 逆向

### 基础 
#### 调用约定
（1）x86 32位架构的调用约定
* __cdecl：参数从右向左依次压入栈中，调用完毕，由调用者负责将这些压入的参数清理掉，返回值置于EAX中。绝大多数×86平台的C语言程序都在使用这种约定。
* __stdcall：参数同样从右向左依次压入栈中，调用完毕，由被调用者负责清理压入的参数，返回值同样置于EAX中。Windows的很多API都是用这种方式提供的。
* __thiscall：为类方法专门优化的调用约定，将类方法的this指针放在ECX寄存器中，然后将其余参数压入栈中。
* __fastcall：为加速调用而生的调用约定，将第1个参数放在ECX中，将第2个参数放在EDX中，然后将后续的参数从右至左压入栈中。

（2）x86 64位架构的调用约定

* Microsoft x 64位（x 86-64）调用约定：在Windows上使用， 依次将前4个参数放入RDI、RSI、RDX、RCX这4个寄存器， 然后将剩下的参数从右至左压入栈中。
* SystemV x64调用约定：在Linux、MacOS上使用， 比Microsoft的版本多了两个寄存器使用RDI、RSI、RDX、RCX、R8、R9这6个寄存器传递前6个参数， 剩下的从右至左压栈。
