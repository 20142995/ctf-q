[TOC]

# Misc

## 隐写题-答题思路
1. 解题提示.md
1. 先看题目, 根据题目搜索关键字 2.  按提示转base64搜，末尾字符搜，多处合并 3. 附件的文件名
2. 文件名逆向
2. 1.搜文件名， 搜 <文件名> 下载
2. 文件属性-详细信息 ，各种奇怪的数据，加转码。
3. 010editor, 
        搜索Text型, flag,ctf, Unicode型 flag
        看文件头 
        修复文件头
        看文件末尾
        看文件中间
3. 打开看文件内容
4. 文件异常：高度，宽度是否正常。
0. 7z解压, 不要光用winrar
0. foremost file
0. binwalk -e filename
        * 发现多文件？看每个文件尾有没有隐藏
        * tiff data, 用 Stegano_Stegsolve的 frame browser
        * 有zlib 可能需要 LSB, RGB 加密等，用Stegano_Stegsolve各种尝试。
        * binwalk file
        *    发现 zlib文件 使用 binwalk -e file, 解压出29d 29d.zlib
        *    file 29d, 发现是 data 再次 binwalk 29d
        *    发现 zlib文件 再次 binwalk -e 解压出aad
        *    file aad, 发现是文本 打开查看

7. 010editor 分析, 配合 dd命令 分离，或者直接010 editor中分离
    
        010editor 搜索 `\{[a-z\d]{4,}`, 选项勾上 Regular expression
        strings xiaojiejie.jpeg | grep -E "\{[a-z]{4,}"
        grep 'KEY' -a filename

1. LSB隐写 -- LSBsteg.py decode -i 1.png -o flag.zip
1. 文字隐写 
           -- SNOW
           -- TTL隐写 2进制前2位变化 [SWPU2019]Network ,63/127/191/255
8. GIF文件：stegsolve 按帧看
9. pdf文件: chrome打开全选复制出来看看
8. PNG文件：
        1.windows照片查看器看，会忽略crc检验。
        2.用其他查看器。看会不会报错, 说明修改了高度
8. PNG文件：调整下高度，看看有没有flag。
8. PNG文件：改了宽度。暴破下过CRC32验证 , 10h-14h是宽度，大端写入比如1写为 00 00 00 1
8. PNG文件：`zsteg pcat.png`
             --- b1,r,lsb,xy   对应 lsb, red0, 不确定
             --- b1,bgr,lsb,xy 对应 bit plan order: bgr, 勾了r0g0b0
9. 图片藏文件: stegsolve, r0g0b0勾上, RGB, GBR等每个试一次, 下面就是藏了信息。
![](imgs/misc_steg.jpg)

1. JPEG隐写 提示JPSH, Jphswin, 打开后点seek保存文件
8. 图片隐写: Exif信息
8. 图片信息 经纬度
8. 图片隐写 stegsolve 左右看通道信息

        Alpha通道: 透明-看得到图，不透明看不到图, 其他-有隐藏信息
        R通道: 最低为位有问题。，把rgb 的0通道都提取出来。
        多通道有信息时，保存为Alpha0, r0,g0,b0图, Alpha0分别和+r0, 进行 Analyze - Image combine, 再用Alpha0和g0 ,b0同操作
        脚本像素分离看信息


8. 图片隐写 stegsolve 看下lsb隐写, 
        
8. 图片隐写 Steghide 看下有没有隐写。 steghide extract -sf filename
10. 密码相关, steghide尝试密码123456
10. 图片隐写 outguess -k 密码 -r 需要破解的文件名 -t 转出的文件名
            outguess -k gemlove -r sheng_huo_zhao_zhao.jpg -t flag.txt
10. 图片隐写 2进制的拼图,用010editor或winhex看形状。
10. 图片隐写 提示 刷新/F5, 使用F5-steganography
10. 图片隐写 Image Steganography
10. 图片隐写 彩图提取二维码。stegsolve选一适合的黑白帧。调整大小/去取某通道某 bit 信息/随机上色/etc. 都行。
        
    11. 或者[BJDCTF#bincat2](http://www.fzwjscj.xyz/index.php/archives/30/#bincat2)，对比两小图的区别，然后循环大图对比指定偏移量。
11. 音频隐写 1.Audition看 多是摩斯码, 2.看频谱spectrogram(视图-频谱) 3.听歌
             MP3Stegodecode.exe -P password -X target.mp3
            摩斯码音频 自动解码： 
                    1.Audition禁用 其他声道, 将目标声道提高 
                    2.右击声道，提取为单声道， 导出mp3
                    3. https://morsecode.world/international/decoder/audio-decoder-adaptive.html 上传解码 play
            
11. 文字隐写 snow可Google:space tab steg, baidu: 空格 制表符 隐写
11. 文字隐写 snow.exe -C flag.txt
12.         base64隐写
10. 脑洞信息 图片是倒着的, dragon倒过来就是 nogard
10. 脑洞信息 galf_si_erehw 提示: 可能是将hex数据倒转过来
11. 看hex值符合哪些特点，倒序 | 文件头 |
11. Detect it Easy 查看, 见下面的具体用法
10. pcapng 取证： 1. foremost分解看看。 2. 用bytes搜索pass, flag 3. 追踪流 4.见底下详解
11. zip 伪加密, ZipCenOp.jar r filename
11. rar 伪加密, F9 81 74 85 改成 F9 81 74 80
11. zip/rar 文件， 使用unzip或者winrar打开 逐个解压，因为包里可能有不需要密码的。
11. zip/rar 密码，先看题目提示，图片文件用010 editor搜索设置 Unicode型, 搜pass, 4位试下。不行再看总结。
11. zip/rar 明文攻击, 里面文件有可能是网上有的。搜一下下载个进行明文攻击。
                压缩工具要相同，如果产生CRC32不同。换工具试， 算法也要相同
                1.压缩方式要选 1存储 2zip
                pkcrack.exe -C 1.zip -c hhh.jpg -P 2.zip -p hhh.jpg -d re.zip -a
                Advanced Archive Password Recovery 比上面慢。
                     提示尝试找回口令的时候---停止。然后用3个密钥解密。
            小文件爆破 (原始)大小 <=6 可以考虑CRC32爆破攻击
                      python crc32.py reverse 0x1b2e6194
12. word 显示隐藏文字
                    
12. 流量分析 icmp, 长度转ascii码, 见下面 简单流量分析
        文件-导出-http所有
        看post请求, 看参数, 参数大小，计算是否有tcp头见misc_fly.pcap
        去掉异常头部(比如1-4个字符)
            binwalk file或通过请求参数看总大小a，合并文件b , b-a再除以(包数量)=tcp头。见misc_fly.pcap
        TCP数据包看16进制  data, hex值可能有按键操作7F是DEL键
        注意盲注等Sql关键字。可能有flag
        蚁剑混淆 f389等等会加在Base64前面，逐位去混淆。，自己搭建抓包试下。
        USB 流量分析 见羊城杯2021 misc520, unctf2020 mouse_click



11. doc文件 1. 显示隐藏文字 2. 解压看有没有隐藏图片
12. cap文件, 802.11协议的数据包  aircrack-ng shipin.cap 见底下
12. 01001010 等二进制转字符串试试。
13. xor文件 xortools破解。见下面
14. hex文件 IDA分析, 或 xxd -r -p MissionImprobable.TEENSY31.hex out
13. 路由相关使用 routerpassview 搜 username 或者是password
15. vmdk 一定要在Linux下7z解压: __7z x filename__
16. 查找webshell, 使用D盾审计。
17. 视频文件, Premiere看比较清楚。
18. 视频隐写 ->图片, ffmpeg -i 10.mp4 -an -f image2 'outut_%05d.jpg'
19. 编码问题 -- 1. 010 editor左上角 edit as 处修改
           -- 2. dd conv=ascii if=111.txt of=ASCII_file.txt
20. 
18. sage 解方程，二元一次，一元多次方程，见下面
19. nfs流  notepad 1.txt:flag.txt 或用 NtfsStreamsEditor
19. 太空站文件 了慢扫描图像工具：MMSSTV https://hamsoft.ca/pages/mmsstv.php
10. 脑洞信息 颜色*宽度 求和,
10. 脑洞信息 6-10位数字 可能是QQ号，进它空间，相册看下。

## png隐写

    00 00 00 0D 49 48 44 52 --0D头块长13, 49 48 44 52 IHDR标识
    00 00 01 f4 00 00 01 a4  宽:00 00 01 f4即500 高: 00 00 01 a4即 400
    08 06 00 00 00 cb d6 df 8a --- CRC校验 29:32 这4个字节是CRC

有时会改宽度，需要CRC校验的。

0x12,13 宽度, 大端模式, 999为03e7

0x16,17 高度

左上角为基点分别是向右拉和向下。宽度一般不会改，会进行CRC校验的。

pngcheck -v filename

Image photography线上和离线加密方式不同。

### png格式介绍1
参考链接

https://dev.gameres.com/Program/Visual/Other/PNGFormat.htm

https://blog.csdn.net/hherima/article/details/45847043

https://www.bilibili.com/video/BV1V4411Z7VA

00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F
--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--
89|50|4E|47|0D|0A|1A|0A|00|00|00|0D|49|48|44|52
00|00|00|0F|00|00|00|20|08|06|00|00|00|CD|2C|22
宽度1/4|2/4|3/4|4/4|高度1/4|2/4|3/4|4/4|Bit depth|ColorType|Compression Method|Filter method|Interlace Method|crc 1/4|2/4|3/4
A9 |
4/4|

### png格式介绍2

    89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52
    00 00 07 80 00 00 04 B0 

前四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，数据块包含了png图片的宽高等信息，该段格式是固定的

之后的四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示，该段格式也是固定的

之后进入13位数据块，前8个字节00 00 05 56 00 00 03 00中：

前四个字节00 00 05 56（即为十进制的1366），代表该图片的宽，该段数据是由图片的实际宽决定的

后四个字节00 00 03 00（即为十进制的768），代表该图片的高，该段数据是由图片的实际高度决定的

这8个字节都属于13位数据块的内容，因此数据块应再向后数5个字节，即为00 00 05 56 00 00 03 00 08 02 00 00 00

剩余的4位40 5C AB 95为该png的CRC检验码，也就是本篇文章要重点讨论的地方，该段数据是由IDCH以及十三位数据块（即上文中的49 48 44 52 00 00 05 56 00 00 03 00 08 02 00 00 00）计算得到的
### 17 steghide隐写01\
将Misc.png拖入winhex发现尾部不对。
1. 用foremost 解压 Misc.png
2. 用steghide 解密 000112.jpg，出现密码
3. 打开pdf，输入密码。（或者暴破）

### 19 outguess隐写
outguess -r angrybird.jpg 11.txt

# 工具使用

## wifi.cap wifi密码破解 aircrack, airdecap-ng

    aircrack-ng -w 常用密码.txt wifi.cap
    aircrack-ng -w /usr/share/wordlists/rockyou.txt wifi.cap

解密流量包

    airdecap-ng shipin.cap -e 0719 -p 88888888
    airdecap-ng shipin.cap -e 0719(前面的essid) -p 88888888
### 解密 http 包, misc_fly.pcap

过滤语句 http.request.method==POST 找到压缩包分卷每个进行保存。

binwalk分析一下 发现有一个rar压缩包 364应该是数据包的一些头等等全部去掉。

    dd if=a1 bs=1 skip=364 of=b1
    dd if=a2 bs=1 skip=364 of=b2
    dd if=a3 bs=1 skip=364 of=b3
    dd if=a4 bs=1 skip=364 of=b4
    dd if=a5 bs=1 skip=364 of=b5
    cat b1 b2 b3 b4 b5 > fly.rar

参考 https://www.cnblogs.com/cat47/p/11567399.html

https://blog.csdn.net/sinat_36188088/article/details/53333565
## notepad++
二进制转字符-转10进制

## binwalk -- kali 分析文件工具 分析头和尾
binwalk -e new.jpg

-e = extract 直接解压文件

\u1111\u2222 --- 要在Chrome里直接 F12 console加引号输出 , "\u1111\u2222" 回车。

## foremost -- kali 分析文件工具,并拆分隐藏的文件
[windows上使用foremost](https://www.cnblogs.com/cnnnnnn/p/8994362.html)

foremost new.jpg 

## Stegsolve --- LSB隐写
java -jar Stegsolve.jar

Analasys - Data Extract

最低位先用0 (alpha没变形没选)

√LSB First

测试每个 Bit Plane Order

      找到明显标志后保存 - Save Test 

SaveBin

## zsteg
zsteg -h

    # 查看LSB信息
    zsteg pcat.png

    检测zlib
    # -b的位数是从1开始的
    zsteg zlib.bmp -b 1 -o xy -v

## file 命令分析文件 或者winhex

## volatility 内存取证
https://blog.csdn.net/qq_42880719/article/details/117304586

`volatility -f <文件名> --profile=<配置文件> <插件> [插件参数]`

imageinfo

```
volatility -f raw.raw imageinfo
```

pslist 知道镜像信息后，一般就会pslist 查看镜像中正在运行的进程

```
volatility -f raw.raw --profile=Win7SP1x64 pslist
```

pstree 以树的形式来列出正在进行的进程，当然pstree也不会显示出隐藏或未链接的进程

`volatility -f raw.raw --profile=Win7SP1x64 pslist`

cmdscan 搜索XP / 2003 / Vista / 2008和conhost.exe上搜索csrss.exe的内存，对于win7是搜索cmd.exe。是搜索命令行的输入历史记录

```
volatility -f raw.raw --profile=Win7SP1x64 cmdscan
```

consoles 相似与cmdscan，但是他扫描的不是COMMAND_HISTORY，而是CONSOLE_INFORMATION，而且还有个显著的优点是cmdscan只能查看到输入的指令，而consoles能查看到输入的指令以及缓冲区的输出(即键入和键出)

```
volatility -f raw.raw --profile=Win7SP1x64 consoles
```

cmdline 此指令将会列出所有命令行下运行的程序

```
volatility -f raw.raw --profile=Win7SP1x64 cmdline
```

除此之外，简单讲一些不常见的指令

```
privs:显示进程权限
envars：显示进程环境变量
verinfo：显示PE文件中嵌入的版本信息
enumfunc：列出进程，dll和内核驱动程序导入和导出
```

filescan 扫描文件指令,一般呢会根据正在进行的进程来定向扫描，也常常会扫描桌面文件。

```
volatility -f raw.raw --profile=Win7SP1x64 filescan
volatility -f raw.raw --profile=Win7SP1x64 filescan | grep “flag”
volatility -f raw.raw --profile=Win7SP1x64 filescan | grep “Desktop”（有的可能是中文把Desktop改成桌面即可）
volatility -f raw.raw --profile=Win7SP1x64 filescan | grep -E “png”（查找png后缀文件）
```

dumpfiles dump出指定PID的文件，一般只要是做内存题都会用到的指令。

```
volatility -f raw.raw --profile=Win7SP1x64 dumpfiles -Q [PID] -D ./
```
将PID的文件保存在当前目录

memdump 可以将内存中的某个进程保存出来

volatility -f win7.vmem --profile=Win7SP1x64 memdump -p [PID] -D ./

editbox/notepad
显示出有关编辑控件的信息
在XP中，正在运行的notepad程序，使用notepad指令就可以看到notepad.exe的内容，而在win7中，将不支持notepad，只能使用editbox，这里举例editbox

volatility -f raw.raw --profile=Win7SP1x64 editbox

netscan
查看网络连接的连接情况

volatility -f raw.raw --profile=Win7SP1x64 netscan

svcscan
扫描windows服务列表

volatility -f raw.raw --profile=Win7SP1x64 svcscan

screenshot
显示GDI样式的截屏

volatility -f raw.raw --profile=Win7SP1x64 screenshot -D ./

userassist
查看运行的进程和次数

volatility -f raw.raw --profile=Win7SP1x64 userassist

clipboard
剪贴板数据，加参数-v可以导出

volatility -f raw.raw --profile=Win7SP1x64 clipboard
volatility -f raw.raw --profile=Win7SP1x64 clipboard -v >clip.txt


hivelist
列出注册表

volatility -f raw.raw --profile=Win7SP1x64 hivelist
加参数-o virtual地址可以导出，如volatility -f raw.raw --profile=Win7SP1x64 hivelist -o 0xfffff8a003696010

iehistory
获取浏览器的浏览历史，这个指令也经常用到。

volatility -f raw.raw --profile=Win7SP1x64 iehistory


dlldump
将指定PID的进程的所有DLL导出

volatility -f raw.raw --profile=Win7SP1x64 dlldump -p [PID] -D ./


printkey
常常是用来列举用户及密码、查看获取最后登陆系统的用户。

获取用户：volatility -f raw.raw --profile=Win7SP1x64 printkey -K “SAM\Domains\Account\Users\Names”

获取最后登陆系统的用户：volatility -f raw.raw --profile=Win7SP1x64 printkey -K “SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon”


获取密码哈希：
1.获取system 的 virtual 地址，SAM 的 virtual 地址：
volatility -f raw.raw --profile=Win7SP1x64 hivelist


2.hashdump:
volatility -f raw.raw --profile=Win7SP1x64 hashdump -y 0xfffff8a000024010 -s 0xfffff8a001390010


>3.碰运气解hash(一般题都是能用cmd5、somd5解出来的)

配合Gimp
dump出正在运行的内存，然后配合Gimp

1.dump出正在运行的程序，随便dump都行
volatility -f raw.raw --profile=Win7SP1x64 memdump -p [PID] -D ./
2.将dump出来的文件(如1234.dmp)重命名为.data拓展名(即1234.data)
3.使用Gimp打开(ubuntu)

>4.这里请放大，进行如下操作
(1).将图像类型RGB修改为RGB Alpha
(2).调整高度(建议调稍微高一点)、确定一个看着合适的宽度、调整位移，可以使用鼠标滑轮和键盘来快速调整，也可以拖动调整


查找txt文件
```
volatility -f 1.raw --profile=WinXPSP2x86 filescan|grep "txt"
```

获取–profile的参数 

    volatility -f mem.vmem –profile=WinXPSP2x86 volshell

shell的命令： 

    dt("内核关键数据结构名称")
    如
    dt("_PEB")

剪贴板
    
    volatility -f memeories.vmem --profile=Win10x86_14393 clipboard

列举进程：

    volatility -f mem.vmem –profile=WinXPSP2x86 pslist

列举缓存在内存的注册表 ：

    volatility -f mem.vmem –profile=WinXPSP2x86 hivelist

hivedump 打印出注册表中的数据 ：

    volatility -f mem.vmem –profile=WinXPSP2x86 hivedump -o 注册表的 virtual 地址

获取SAM表中的用户 ：

    volatility -f mem.vmem –profile=WinXPSP2x86 printkey -K "SAM\Domains\Account\Users\Names" 

可以看到有4个用户

获取最后登录系统的账户 ：

    volatility -f mem.vmem –profile=WinXPSP2x86 printkey -K "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" 

提取出内存中记录的 当时正在运行的程序有哪些，运行过多少次，最后一次运行的时间等信息 

    volatility -f mem.vmem –profile=WinXPSP2x86 userassist

将内存中的某个进程数据以 dmp 的格式保存出来 。

    volatility -f mem.vmem –profile=WinXPSP2x86 -p [PID] -D [dump 出的文件保存的目录]

二进制编辑器 hexeditor 将以上保存的 dmp 文件打开，并进行调查取证的工作 。

    hexeditor 1736.dmp

二进制.png

你还可以使用 strings 这个工具将它的字符串打印出来。 

    例：

    strings 1736.dmp > 1736.txt 

    strings 1608.dmp > 1736.txt | grep shellcode 

提取内存中保留的 cmd 命令使用情况 。

    volatility -f mem.vmem –profile=WinXPSP2x86 cmdscan

获取到当时的网络连接情况 。

    volatility -f mem.vmem –profile=WinXPSP2x86 netscan

获取 IE 浏览器的使用情况。 

    volatility -f mem.vmem –profile=WinXPSP2x86 iehistory 

获取内存中的系统密码，我们可以使用 hashdump 将它提取出来 。

    volatility -f mem.vmem –profile=WinXPSP2x86 hashdump -y （注册表 system 的 virtual 地址 ）-s （SAM 的 virtual 地址）

    volatility -f mem.vmem –profile=WinXPSP2x86 hashdump -y 0xe1035b60 -s 0xe16aab60 

最大程度上将内存中的信息提取出来，那么你可以使用 timeliner 这个插件。它会从多个位置来收集系统的活动信息 

    volatility -f mem.vmem –profile=WinXPSP2x86 timeliner


打开kali，使用volatility 查看进程，可以发现一个TrueCrypy.exe的进程。 

    volatility -f mem.vmem –profile=WinXPSP2x86 pslist

TrueCrypy.exe是一款加密程序，而我们可以推出，suspicion为加密的结果。 

我们需要从内存dump出key来。 

    volatility -f mem.vmem –profile=WinXPSP2x86 memdump -p 1464 -D ctf/ 

dump出来的文件为1464.dmp 。

Elcomsoft Forensic Disk Decryptor 的使用。

我们需要借助Elcomsoft Forensic Disk Decryptor（Elcomsoft硬盘取证解密器，简称为EFDD）软件来获取key和破解文件  。
### bitlocker解密, vmem, vhdx
参见  网鼎杯2020白虎组 密码柜

windows挂载后, 有密钥情况下。

manage-bde -unlock G: -RecoveryPassword 294173-189123-573023-455081-459382-434610-344091-286275

### xor解密

xortool -c 20 filename 得到密钥。 脚本跑

```python
#coding:utf-8

f = open('xor','rb')
w = open('xor1.png','ab')
line = f.read()
key = 'WDCTF'
# print hex(ord(line[1]))
for i in range(len(line)):
    w.write(chr(ord(line[i])^ord(key[i % 5])))
```
### sage 计算，解方程等

```
# 三元一次方程
var('x y z')
solve([3*x-y+z==185,
2*x+3*y-z==321,
x+y+z==173], [x, y, z])

# 一元二次方程
var('x')
f(x)=x*x+x-7943722218936282
f.roots()
```


## Detect it Easy
DIE看时发现资源区段显示加壳，很可疑。

![注意，前面](./imgs/Software_die02.jpg)

查看资源，发现Flag关键字。

![注意，前面](./imgs/Software_die01.jpg)

在图1处右击查看16进制，发现PNG头。转储出来。恢复PNG头。显示出flag

也可以用ResHackerFX或 [ResourcesExtract1.18](https://www.xiazaiba.com/html/2983.html) 提取
## 文件头
字符串 PK是 zip的开头,  5d480506xxxxx 为尾部

## 题库list

1. 简单流量分析

[工业信息安全技能大赛(ICSC)2019](https://www.secshi.com/19184.html)

不久前，运维人员在日常安全检查的时候发现现场某设备会不时向某不知名ip发出非正常的ICMP PING包。这引起了运维人员的注意，他在过滤出ICMP包分析并马上开始做应急处理很可能已被攻击的设备。运维人员到底发现了什么?flag形式为 flag{}

