[TOC]
RSA https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/

flag{uuid4}.bit_length() == 343左右
1. 先yafu分解n试下
2. 看题目, 观察有可能是5进制的。(0-9看看都有没有)
4. 同n, 共模攻击
4. nc接近, 看有没公约数
3. 没给e, 试2,3,10,65537
3. 低加密指数广播攻击的特性猜e=3、10、17等
4. 小范围爆破 0,200 , 注意try catch
5. [rho](https://blog.csdn.net/maxichu/article/details/45459533) 
6. sage [Coppersmith 攻击](https://www.ruanx.net/coppersmith/)
7. Franklin-Reiter attack, 同n同e, m和m+r
         m1 = bytes_to_long(flag)
         m2 = a*m1 + b
         https://www.bilibili.com/read/cv13480202/


unusual rsa https://wp.ctf.show/d/180-unusual-rsa-writeup
https://blog.csdn.net/m0_49109277/article/details/118603921#t1
## 普通 pqr, yafu/ sage  factor分解
```python
import gmpy2
from Crypto.Util.number import long_to_bytes

e = 0x10001

n = 897607935780955837078784515115186203180822213482989041398073067996023639  # yafu/ sage 分解
c = 490571531583321382715358426750276448536961994273309958885670149895389968

p, q, r = 932470255754103340237147, 1098382268985762240184333, 876391552113414716726089

phin = (p-1) * (q-1) * (r-1)
d = gmpy2.invert(e, phin)
m = pow(c,d,n)
print(long_to_bytes(m))
```
## 绿城杯2021 RSA1, nc不互素 / CTF小学生rsa19 /

```python
from Crypto.Util.number import *
import gmpy2
from flag import flag
assert flag[:5]==b'flag{'

m = bytes_to_long(flag)
p = getPrime(1024)
q = getPrime(1024)
n = p * q
print('n =',n)
e = 0x10001
M = 2021 * m * 1001 * p 
c = pow(M,e,n)
print('c =',c)

#n = 17365231154926348364478276872558492775911760603002394353723603461898405740234715001820111548600914907617003806652492391686710256274156677887101997175692277729648456087534987616743724646598234466094779540729413583826355145277980479040157075453694250572316638348121571218759769533738721506811175866990851972838466307594226293836934116659685215775643285465895317755892754473332034234495795936183610569571016400535362762699517686781602302045048532131426035260878979892169441059467623523060569285570577199236309888155833013721997933960457784653262076135561769838704166810384309655788983073376941843467117256002645962737847
#c = 6944967108815437735428941286784119403138319713455732155925055928646536962597672941805831312130689338014913452081296400272862710447207265099750401657828165836013122848656839100854719965188680097375491193249127725599660383746827031803066026497989298856420216250206035068180963797454792151191071433645946245914916732637007117085199442894495667455544517483404006536607121480678688000420422281380539368519807162175099763891988648117937777951069899975260190018995834904541447562718307433906592021226666885638877020304005614450763081337082838608414756162253825697420493509914578546951634127502393647068722995363753321912676
```

$$
\begin{multline}
\shoveleft
\begin{aligned}
    & M = 2021 * m * 1001 * p \\
    & c = pow(M,e,n) \\
    & c = M^e\%n \\
    & c = M^e+kn \\
    & c = M^e+k*p*q \\
    \\ 
    & c = (2021*m*1001*p)^e+k*p*q \\
    & 两边同时模上p \\
    & c\%p = (2021*m*1001*p)^e\%p+k*p*q\%p \\
    & c\%p = 0 \\
    & c = kp \\
    & p = gcd(c,n) \\
\end{aligned}
\end{multline}
$$

例2 M=m*p+n， CTF小学生rsa19

```python
n=p*q
e=65537
c=pow(m*p+n,e,n)
print("n=",n)
print("c=",c)
print("e=",e)
n= 24981188020167643746074879674147956549430370314044132464039253351652835734440674909204189557556602865962429895374385855345228410925147709118740392159925942795088299679655602727568511595072696409696271371250102853677902616206682058248674337676916036346628088795691598346311821772518310067782592432491390315016938601034921878080792576848740835839533436309467949739957366439791446358471180018562594829965668319970676634275599934272794456322929434264075482862354958544593517741073415713467939034524174022554745424038830745700456334054077809280744596235294447559597633491714726093368901810800094506409706555205366712813489
c= 18621596046506896357501494490427254488179638636182636310535680038609096612801678121484736598560358324455851721295385341142207429201113106822997090878471278518783809844775558184834964034587247425952074737623038780244691628409045326000650516141599732305641793044557982746856322994617259408879266356396616639748741726355064689072113192676869563527139209384310754130692810070548558914951576972545449143198975499766952417464247791425484288188124235662918342094367901287461654602032582020287215884903753469091244847129233355340585693462406329376871222071849218639774125831290704426337294409031337314523781596602940531607723
e= 65537
```


$$
\begin{multline}
\shoveleft
\begin{aligned}
& c = (mp+n)^e + k* p*q \\
& c = (mp^e+ mp^t*n^{t_2} + n^e) + k*p*q & t < e\\
& c = mp^e+ mp^t*(p*q)^{t_2}+ (p*q)^e + k*p*q & 同时 \% p \\
& c \% p = 0 \\
& c = kp
\end{aligned}
\end{multline}
$$

推导2
$$
\begin{multline}
\shoveleft
\begin{aligned}
& c = (mp+n)^e \% n \\
& c = (mp^e+ k_1(mp)^xn^y + n^e) \% n\\
& c = (mp)^e \% n \\
& c = (mp+n)^e \% n = (mp)^e \% n \\
& \\
& 推导3 \\
& c = (mp+n)^e \% n \\
& c = mp^e+ k_1(mp)^xn^y + n^e + kn\\
& c = (mp)^e+ k_3n\\
& 两边同时模n \\
& c = (mp)^e\%n \\
& c = (mp+n)^e \% n = (mp)^e \% n \\
& \\
& 推导4 \\
& c = (mp)^e + kn \\
& c = m^e*p^e + p*k*q \\
& c = p(m^e*p^(e-1) + k*q) \\
& c = k_4p \\
& p = gcd(n,c) \\ 

\end{aligned}
\end{multline}
$$


## dp 泄露

https://blog.csdn.net/m0_49109277/article/details/113622053?spm=1001.2014.3001.5501

## DASCTF2020 7月月赛 - ezrsa , pqr
```python
from secret import flag
from Crypto.Util.number import getPrime,inverse,bytes_to_long,long_to_bytes
from sympy import isprime

m = bytes_to_long(flag)

i=0
p=getPrime(1024)
r=getPrime(1024)
while True:
    i+=1
    q = 5*p+i
    if isprime(q) :
        break

n=p*q*r
e = 65537
c = pow(m,e,n)
p3 = pow(p,3,n)
q3 = pow(q,3,n)
print c
print e
print n
print p3
print q3

#c=121836624300974075697021410307617877799398704636412997043885070081959280989429720121505939271618801519845564677294487289085261071864489530938936756975266796724602572135614554790383740417604947122325421381322155502222532570899845171858215244411945889235509975121332503672838693190271397334662495169940649349725607212867270114445618201171582223868214171942753939282404133460110489725340075179818856587044172460703519751189284498768640898837525773823127259807337383870535232880471869465188882667401540052151795173003568424369575866780354852158304748299284900468768898966143729562589110027789165774068500360970335261801131264801996703446527156709491597639262305131309592217711956181866054589085773085822482247966030763162382493197473555330201343835684065991963179440335668817727280429581864224497755004825170263803174390985868997862117983334405815543271969716910040927833496696049703621334172902517666284662473059140662717708823
#e=65537
#n=20361372240024088786698455948788052559208001789410016096382703853157107986024860262721685000417719260611935731634077852127432140361792767202581631816544546972750034494061276779878409544779707914261679633764772575040304712361634318086289783951555842021028438799649252652041211341825451500751760872572402250747982495384263677669526575825183733353800694161425360299521143726681387485097281832219009682768523304737252763907939642212542959846630464628135025203489075698699980715986689341069964387779523254203021424865355054215122316160201073604105317768112281914334065349420946717116563634883368316247495042216330408372176714499012778410160478384503335610321108263706243329745785632599707740534386988945259578897614317582546751658480917188464178997026284336861027299289073045677754342746386408505695243800685323283852020325044649604548575089927541935884800327121875191739922436199496098842684301207745090701158839031935190703347091
#p3=3639847731266473012111996909765465259684540134584180368372338570948892196816095838781423020996407457408188225238520927483809091079993151555076781372882518810174687150067903870448436299501557380508793238254471833275507634732947964907461619182112787911133054275872120243558556697900528427679352181961312958660881800731678134481664074711076672290178389996403357076809805422591851145306425951725627843352207233693810474618882394140691334742086008967260117740486955640068190440609984095657695423536016475468229419187489359563800737261212975921663803729112420222039005478830477455592167092520074509241894829304209406713781082959299623674294927249556083486223036858674077173104518013601628447504500606447821540687465361616447631579976579754996021653630804073535352129315413118764836270751250405649683786487251823247828947202336680538849571498780353357272103697510910576879383751704763858882439578045020243015928994208017750848637513
#q3=7030777127779173206633582847346001157991477456002191926122836599155148909465054067800807615361108442560942058865403188672629297039703065927801771646334817871335134889139894648729527452541098449842202838983982508551750669662540615534327150829869964429006130891731472099912937717406120443380283548571270317421722042835639732966975812764084015221255115940508456442279902250677665136380988902682370875602145833135937210740790528756301051981994351553247852018355526641012434670664732924491790949235519600899289515495046353559475806935200029321563549553167235419039924276406059858659476329718809657072997385947262654743181242885709558209249589482036673428723035300722280229192727192487772217518673838209646300548275957450994828221329299666216457961746189885356929698674294944243729739850927111231235060005119781652245234537583181232715964191675241206562888107252569566488402724441835466680342239244581162530424964324562530832713397
```

exp

```python
from libnum import n2s

c = 121836624300974075697021410307617877799398704636412997043885070081959280989429720121505939271618801519845564677294487289085261071864489530938936756975266796724602572135614554790383740417604947122325421381322155502222532570899845171858215244411945889235509975121332503672838693190271397334662495169940649349725607212867270114445618201171582223868214171942753939282404133460110489725340075179818856587044172460703519751189284498768640898837525773823127259807337383870535232880471869465188882667401540052151795173003568424369575866780354852158304748299284900468768898966143729562589110027789165774068500360970335261801131264801996703446527156709491597639262305131309592217711956181866054589085773085822482247966030763162382493197473555330201343835684065991963179440335668817727280429581864224497755004825170263803174390985868997862117983334405815543271969716910040927833496696049703621334172902517666284662473059140662717708823
e = 65537
n = 20361372240024088786698455948788052559208001789410016096382703853157107986024860262721685000417719260611935731634077852127432140361792767202581631816544546972750034494061276779878409544779707914261679633764772575040304712361634318086289783951555842021028438799649252652041211341825451500751760872572402250747982495384263677669526575825183733353800694161425360299521143726681387485097281832219009682768523304737252763907939642212542959846630464628135025203489075698699980715986689341069964387779523254203021424865355054215122316160201073604105317768112281914334065349420946717116563634883368316247495042216330408372176714499012778410160478384503335610321108263706243329745785632599707740534386988945259578897614317582546751658480917188464178997026284336861027299289073045677754342746386408505695243800685323283852020325044649604548575089927541935884800327121875191739922436199496098842684301207745090701158839031935190703347091
p3 = 3639847731266473012111996909765465259684540134584180368372338570948892196816095838781423020996407457408188225238520927483809091079993151555076781372882518810174687150067903870448436299501557380508793238254471833275507634732947964907461619182112787911133054275872120243558556697900528427679352181961312958660881800731678134481664074711076672290178389996403357076809805422591851145306425951725627843352207233693810474618882394140691334742086008967260117740486955640068190440609984095657695423536016475468229419187489359563800737261212975921663803729112420222039005478830477455592167092520074509241894829304209406713781082959299623674294927249556083486223036858674077173104518013601628447504500606447821540687465361616447631579976579754996021653630804073535352129315413118764836270751250405649683786487251823247828947202336680538849571498780353357272103697510910576879383751704763858882439578045020243015928994208017750848637513
q3 = 7030777127779173206633582847346001157991477456002191926122836599155148909465054067800807615361108442560942058865403188672629297039703065927801771646334817871335134889139894648729527452541098449842202838983982508551750669662540615534327150829869964429006130891731472099912937717406120443380283548571270317421722042835639732966975812764084015221255115940508456442279902250677665136380988902682370875602145833135937210740790528756301051981994351553247852018355526641012434670664732924491790949235519600899289515495046353559475806935200029321563549553167235419039924276406059858659476329718809657072997385947262654743181242885709558209249589482036673428723035300722280229192727192487772217518673838209646300548275957450994828221329299666216457961746189885356929698674294944243729739850927111231235060005119781652245234537583181232715964191675241206562888107252569566488402724441835466680342239244581162530424964324562530832713397

import gmpy2


def decrypt(c, e, n):  # 小公钥指数攻击
    for i in range(10 ** 10):
        mm = c + i * n
        result, b = gmpy2.iroot(mm, e)
        if b:
            return result


# p3 = pow(p,3,n)
# q3 = pow(q,3,n)
p = decrypt(p3, 3, n)
q = decrypt(q3, 3, n)
# n = p * q * r
r = n // p // q

phin = int((p - 1) * (q - 1) * (r - 1))
d = gmpy2.invert(e, phin)
flag = pow(c, d, n)
print('flag is ', flag)
print(n2s(int(flag)))
```


### 多组n和c, gcd(n1,n2)得到p和q, 羊城杯2021 Bigrsa
```python
from Crypto.Util.number import long_to_bytes
import gmpy2

n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061
n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073
e = 65537
c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264
p = gmpy2.gcd(n1, n2)
q1 = n1 // p
q2 = n2 // p
phi1 = (p - 1) * (q1 - 1)
d1 = gmpy2.invert(e, phi1)
phi2 = (p - 1) * (q2 - 1)
d2 = gmpy2.invert(e, phi2)

m2 = pow(c, d2, n2)
m = pow(m2, d1, n1)
print(long_to_bytes(m))

```
### [BJDCTF2020]RSA, 多组n,c 多n求gcd, 再爆e

```python
import gmpy2
from Crypto.Util.number import long_to_bytes

c1 = 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120
n1 = 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037
# pow(294,e,n)
m1 = 381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018

c2 = 979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721
n2 = 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047

print(gmpy2.gcd(n1, n2))
p = 99855353761764939308265951492116976798674681282941462516956577712943717850048051273358745095906207085170915794187749954588685850452162165059831749303473106541930948723000882713453679904525655327168665295207423257922666721077747911860159181041422993030618385436504858943615630219459262419715816361781062898911
q = n1 // p
phin = (p - 1) * (q - 1)
for e in range(1, 100000):
    if pow(294, e, n1) == m1:
        print(e)  # 52361
        break

d = gmpy2.invert(e, phin)
m = pow(c1, d, n1)
print(long_to_bytes(m))
```

## 假设pq相近，暴破phin, [NCTF2019]childRSA
题目
```python
from random import choice
from Crypto.Util.number import isPrime, sieve_base as primes
from flag import flag


def getPrime(bits):
    while True:
        n = 2
        while n.bit_length() < bits:
            n *= choice(primes)
        if isPrime(n + 1):
            return n + 1

e = 0x10001
m = int.from_bytes(flag.encode(), 'big')
p, q = [getPrime(2048) for _ in range(2)]
n = p * q
c = pow(m, e, n)

# n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513
# c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108
```
exp 
```python
import gmpy2
import Crypto.Util.number
import sympy

d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804
e = 0x10001
# 有 c d e 我们知道 e*d = 1%(p-1)(q-1) 则 e*d-1 = k*(p-1)*(q-1)
# 可以爆破k要得到(p-1)(q-1)
# 取k的范围 ed - 1是2063到2064位 、 （p-1）（q-1）是1024+1024位 则k取2**15~2**16
# e*d-1 -- 2064, 2063 <= k*2048 <=2064 , 15 <= k <= 16
for i in range(1000, 3000):
    if 2 ** i < e * d - 1 < 2 ** (i + 1):
        print(i)
        break
        # 2063
        # print((e*d - 1).bit_length()) # 这么算更快
# (e*d-1)对k的模为0
# 我们还知道q是p的下一个素数 俩者大小相差不大  
for k in range(2 ** 15, 2 ** 16):
    if (e * d - 1) % k == 0:
        p = sympy.prevprime(gmpy2.iroot((e * d - 1) // k, 2)[0]) # pq相近  Φn ≈ p**2 = kΦ(n)+1 = e * d 
        # 通过sympy.prevprime(n)得到小于n的最大素数
        # gmpy2.iroot开方函数输出的是一个元组
        q = gmpy2.next_prime(p)
        if (e * d - 1) // k == (q - 1) * (p - 1):
            # 验证pq是否正确
            break
n = q * p
m = pow(c, d, n)
print(Crypto.Util.number.long_to_bytes(m))
# b'NCTF{70u2_nn47h_14_v3ry_gOO0000000d}'
```

## 给了e的随机取值范围，爆破, [HDCTF2019]bbbbbbrsa

题目
```python
from base64 import b64encode as b32encode
from gmpy2 import invert,gcd,iroot
from Crypto.Util.number import *
from binascii import a2b_hex,b2a_hex
import random

flag = "******************************"

nbit = 128

p = getPrime(nbit)
q = getPrime(nbit)
n = p*q

print p
print n

phi = (p-1)*(q-1)

e = random.randint(50000,70000)

while True:
    if gcd(e,phi) == 1:
        break;
    else:
        e -= 1;

c = pow(int(b2a_hex(flag),16),e,n)

print b32encode(str(c))[::-1]

# 2373740699529364991763589324200093466206785561836101840381622237225512234632
```
```python
import gmpy2
from Crypto.Util.number import long_to_bytes

c = 2373740699529364991763589324200093466206785561836101840381622237225512234632
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061
p = 177077389675257695042507998165006460849
q = n // p
phin = (p - 1) * (q - 1)

for e in range(50000, 70000):
    if gmpy2.gcd(e, phin) == 1:
        d = gmpy2.invert(e, phin)
        m = pow(c, d, n)
        flag = long_to_bytes(m)
        if b'flag' in flag or b'CTF' in flag or (b"{" in flag and b'}' in flag):
            print(flag)
```


## 威尔逊定理 RoarCTF2019 babyRSA pq接近

题目
```python
import sympy
import random

def myGetPrime():
    A= getPrime(513)
    print(A)
    B=A-random.randint(1e3,1e5)
    print(B)
    return sympy.nextPrime((B!)%A)
p=myGetPrime()
#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596

q=myGetPrime()
#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026

r=myGetPrime()

n=p*q*r
#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
c=pow(flag,e,n)
#e=0x1001
#c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428
#so,what is the flag?
```


$$
\begin{multline}
\begin{aligned}
& (A-1)! \ \% A \equiv -1 \ \% A \\
& (A-1)(A-2)...(B+1)B(B-1)...1 \ \equiv -1 (mod \ A) =>\\
& (A-1)(A-2)...(B+1)B! \ \equiv -1 (mod \ A) =>\\
& (A-1)(A-2)...(B+1)B! \ \equiv (A-1) (mod \ A)  --加除数结果不变 =>\\
& (A-2)...(B+1)B! \equiv 1 (mod \ A) =>\\
& \mathsf{逐个取余相乘, 再求逆元即可}
\end{aligned}
\end{multline}

 % \equiv -1
$$

exp

```python
import gmpy2
import sympy
from Crypto.Util.number import long_to_bytes

n = 85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
e = 0x1001
c = 75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428

A2 = 16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
B2 = 16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
A1 = 21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
B1 = 21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596


def willson(A, B):
    tmp = 1
    for i in range(B + 1, A - 1):
        tmp *= i
        tmp %= A
    factorial = gmpy2.invert(tmp, A)
    return factorial


p = sympy.nextprime(willson(A1, B1))
q = sympy.nextprime(willson(A2, B2))
r = n // p // q
phi_n = (p - 1) * (q - 1) * (r - 1)
d = gmpy2.invert(e, phi_n)

m = pow(c, d, n)
print(long_to_bytes(m))
```
## 小范围爆破,xy 求解
RoarCTF2019 RSA

```python
import gmpy2
import sympy
from Crypto.Util.number import long_to_bytes

# A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x
# p=next_prime(z*x*y)
# q=next_prime(z)

A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724
n = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128

# for x in range(2, 200):
#     for y in range(2, 200):
#         try:
#             if (((y % x) ** 5) % (x % y)) ** 2019 + y ** 316 + (y + 1) // x == A:
#                 print(x, y)
#         except:
#             pass

x, y = 2, 83
xy = 166
n1 = n // 166
np = (gmpy2.iroot(n1, 2))[0]
p = sympy.nextprime(np)
q = n // p
phin = (p - 1) * (q - 1)
for e in [2, 3, 10, 65537]:
    try:
        d = gmpy2.invert(e, phin)
        m = pow(c, d, n)
        print(long_to_bytes(m))

    except Exception as e:
        pass
```

## 自定义 n P1*P2....*P17 [MRCTF2020]babyRSA

```python
import sympy
import random
from gmpy2 import gcd, invert
from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes
from z3 import *
flag = b"MRCTF{xxxx}"
base = 65537


def GCD(A):
    B = 1
    for i in range(1, len(A)):
        B = gcd(A[i-1], A[i])
    return B


def gen_p():
    P = [0 for i in range(17)]
    P[0] = getPrime(128)
    for i in range(1, 17):
        P[i] = sympy.nextprime(P[i-1])
    print("P_p :", P[9])
    n = 1
    for i in range(17):
        n *= P[i]
    p = getPrime(1024)
    factor = pow(p, base, n)
    print("P_factor :", factor)
    return sympy.nextprime(p)


def gen_q():
    sub_Q = getPrime(1024)
    Q_1 = getPrime(1024)
    Q_2 = getPrime(1024)
    Q = sub_Q ** Q_2 % Q_1
    print("Q_1: ", Q_1)
    print("Q_2: ", Q_2)
    print("sub_Q: ", sub_Q)
    return sympy.nextprime(Q)


if __name__ == "__main__":
    _E = base
    _P = gen_p()
    _Q = gen_q()
    assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1)
    _M = bytes_to_long(flag)
    _C = pow(_M, _E, _P * _Q)
    print("Ciphertext = ", _C)
'''
P_p : 206027926847308612719677572554991143421
P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839
Q_1:  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2:  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q:  168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
Ciphertext =  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832
'''
```

exp
```python
import operator
from functools import reduce

import gmpy2
import sympy
from Crypto.Util.number import long_to_bytes

base = 65537
P_p = 206027926847308612719677572554991143421
P_factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839
Q_1 = 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2 = 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q = 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832
e = base

P = [0]*17
P[9] = P_p
for i in range(10, 17):
    P[i] = sympy.nextprime(P[i - 1])
for i in range(8, -1, -1):
    P[i] = sympy.prevprime(P[i + 1])

phinp = reduce(operator.mul, [x - 1 for x in P])
P_n = reduce(operator.mul, P)
P_d = gmpy2.invert(base, phinp)
p = pow(P_factor, P_d, P_n)
_P = sympy.nextprime(p)

Q = pow(sub_Q, Q_2, Q_1)
_Q = sympy.nextprime(Q)

_N = _P * _Q
phin = (_P - 1) * (_Q - 1)
_D = gmpy2.invert(e, phin)
_M = pow(Ciphertext, _D, _N)
print(long_to_bytes(_M))
```


## [NPUCTF2020]EzRSA wp,  e和Φ(n)不互素

$$
\begin{multline}
\shoveleft
\begin{aligned}
& gcd(e,\phi(n))=b \\
& ed \equiv 1mod \phi(n)  \\
& e = a*b \\ 
& abd \equiv 1mod \phi(n) \\
& c \equiv  m^e \ mod \ n => \ \ m^{ab} \equiv c\ mod \ n \\
& c^{bd} \equiv m^{abbd} \equiv m^b mod \ n \\
& bd = gmpy2.invert(a,\phi (n)) \\
& m^b = gmpy2.invert(c^{bd},\phi (n))
\end{aligned}
\end{multline}
$$

```python
import gmpy2
import sympy
from Crypto.Util.number import long_to_bytes

# p = getPrime(1024)
# q = getPrime(1024)
# n = p * q
# gift = lcm(p - 1, q - 1)
# flag = b'NPUCTF{******************}'
# m = int.from_bytes(flag, 'big')
# c = powmod(m, e, n)

e = 54722
n = 17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121
gift = 2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104
c = 3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319

print(n.bit_length())  # 2048
print(gift.bit_length())  # 2045, 差3位。。即不超过8。循环试一下。

for i in range(1, 200):
    if gift * i > n:
        print(i)  # i为9 ，不超过9 ，很可能是取8
        break

x = sympy.Symbol('x')
y = sympy.Symbol('y')
p, q = sympy.solve([x * y - n, (x - 1) * (y - 1) - gift * 8], [x, y])[0]
p, q = int(p), int(q)
phin = (p - 1) * (q - 1)
G = gmpy2.gcd(e, phin)
d2 = gmpy2.invert(e // G, phin)  # 推导见上面
m2 = pow(c, d2, n)
m = gmpy2.iroot(m2, 2)[0]
print(long_to_bytes(m))
```


## [MRCTF2020]Easy_RSA  给了ed,和n , 至少从 ed//n + 1开始取k
题目
```python
import sympy
from gmpy2 import gcd, invert
from random import randint
from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes
import base64

from zlib import *
flag = b"MRCTF{XXXX}"
base = 65537

def gen_prime(N):
    A = 0
    while 1:
        A = getPrime(N)
        if A % 8 == 5:
            break
    return A

def gen_p():
    p = getPrime(1024)
    q = getPrime(1024)
    assert (p < q)
    n = p * q
    print("P_n = ", n)
    F_n = (p - 1) * (q - 1)
    print("P_F_n = ", F_n)
    factor2 = 2021 * p + 2020 * q
    if factor2 < 0:
        factor2 = (-1) * factor2
    return sympy.nextprime(factor2)


def gen_q():
    p = getPrime(1024)
    q = getPrime(1024)
    assert (p < q)
    n = p * q
    print("Q_n = ", n)
    e = getRandomNBitInteger(53)
    F_n = (p - 1) * (q - 1)
    while gcd(e, F_n) != 1:
        e = getRandomNBitInteger(53)
    d = invert(e, F_n)
    print("Q_E_D = ", e * d)
    factor2 = 2021 * p - 2020 * q
    if factor2 < 0:
        factor2 = (-1) * factor2
    return sympy.nextprime(factor2)


if __name__ == "__main__":
    _E = base
    _P = gen_p()
    _Q = gen_q()
    assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1)
    _M = bytes_to_long(flag)
    _C = pow(_M, _E, _P * _Q)
    print("Ciphertext = ", _C)
'''
P_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740
Q_n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D =  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext =  40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021
'''
```

exp
```python
import operator
import sys
from functools import reduce

import gmpy2
import sympy
from Crypto.Util.number import long_to_bytes

# prime = 5 + 8 * k
from json5.lib import long

e = base = 65537

P_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740
Q_n = 20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D = 100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext = 40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021

print(e)
print(base)


def get_p():
    x, y = sympy.symbols("x y")
    a = sympy.solve([x * y - P_n, (x - 1) * (y - 1) - P_F_n], [x, y])[0]
    P_p, P_q = a
    factor2 = 2021 * P_p + 2020 * P_q
    return sympy.nextprime(factor2)


def get_q():
    # Q_n = p * q > phin, 假设k=(Q_E_D - 1) // Q_n, 至少从 k + 1开始取值
    K = ((Q_E_D - 1) // Q_n) + 1  
    for k in range(K, K + 2):
        p, q = sympy.symbols("p q")
        a = sympy.solve([p * q - Q_n, k * (p - 1) * (q - 1) + 1 - Q_E_D], [p, q])
        if a:
            Q_p, Q_q = a[0]
            factor2 = 2021 * Q_p - 2020 * Q_q
            return sympy.nextprime(factor2)


p = get_p()
q = get_q()
phi_n = (p - 1) * (q - 1)
n = p * q
d = gmpy2.invert(e, phi_n)
m = pow(Ciphertext, d, n)

print(long_to_bytes(m))

```



## 综合题目  RSA之 两组e与φ(n)不互素解法 [De1CTF2019]babyrsa

https://blog.csdn.net/weixin_44110537/article/details/107433092


$$
c_1 = m^{e_1} \% (p*q_1) => c_1 = m^{14 \frac{e_1}{14}} \% (p*q_1) \\
c_2 = m^{e_2} \% (p*q_2) => c_2 = m^{14 \frac{e_2}{14}} \% (p*q_2) \\
$$
此时 $gcd( \frac{e_1}{14}, (p-1)*(q_1-1))=1$ 所以 $m^{14}=c_1^{d_1} \% (p*q_1)$ , 其中 $d_1 = invert(\frac{e_1}{14}, (p-1)*(q-1))$
同理有 $m^{14} = c_2^{d_2} \% (p*q_2)$
$$
\left\{
\begin{array}{c}

m^{14} = c_1^{d_1} \ \% \ p \\ 
m^{14} = c_1^{d_1} \ \% \ q_1 \\ 
m^{14} = c_2^{d_2} \ \% \ p \\ 
m^{14} = c_2^{d_2} \ \% \ q_2 \\ 

\end{array}
\right. \\
$$

因为有$gcd(7, (q_1-1)*(q_2-1))=1$将$q_1q_2$合并， --条件是 $e \phi(n) \equiv 1$  这里e=14=2*7 , q1-1 * q2-1肯定为偶数, 所以有公因数2, e/2=14/2=7, 将$m^2$作为整体
利用CRT求特解 - 设此特解为 $last=CRT((c_1^{d_1}, c_2^{d_2}), (q_1, q_2))$
$$
\begin{aligned}
& (m^2)^7 = k*q_1*q_2 + last \\
& last=(m^2)^7 \% (q_1 * q_2) & d=invert(7, (q_1-1) * (q_2-1)) \\
\end{aligned}
$$
最后 $m^2$开平方得m.

![](https://gitee.com/wgf4242/imgs/raw/master/imgs/20201113211542536-(2).jpg)

```python
from functools import reduce
import gmpy2
from Crypto.Util.number import long_to_bytes


def CRT(r, d):
    M = reduce(lambda x, y: x * y, d)
    x = 0
    for re, de in zip(r, d):
        md = M // de
        x = (x + gmpy2.invert(md, de) * md * re) % M
    return int(M + x % M) % M


def get_p():
    n = [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791]
    c = [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797]
    p4 = CRT(n, c)
    return gmpy2.iroot(p4, 4)[0]


def get_e(ee, n, c):
    # kn + ce1 = e1 ^ ee1
    for k in range(0, 100000):
        a, b = gmpy2.iroot(k * n + c, ee)
        if b:
            return a


ee1 = 42
ee2 = 3
ce1 = 45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384
ce2 = 13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158
tmp = 864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387
n = 15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039

# part3, yafu 分解n
# q1p < q1q
q1q = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088835693
q1p = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
q1 = q1p
q2 = 114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513
c1 = 262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124
c2 = 7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596

if __name__ == '__main__':
    # part 1
    p = get_p()

    # part 2
    e1 = get_e(ee1, n, ce1)
    e2 = get_e(ee2, n, ce2) - tmp

    # part 4
    n1 = p * q1
    n2 = p * q2
    phi_n1 = (p - 1) * (q1 - 1)
    phi_n2 = (p - 1) * (q2 - 1)
    # print(f'p is {p}')
    # print(f'e1 is {e1}')
    # print(f'e2 is {e2}')

    GCD = gmpy2.gcd(e1, phi_n1)
    GCD2 = gmpy2.gcd(e2, phi_n2)
    # print(GCD)  # 14

    m14 = gmpy2.invert(e1 // GCD, phi_n1)  # 这里可由前两式推得，一个值，不是正解, 用中国剩余定理继续推
    d1 = gmpy2.invert(e1 // GCD, phi_n1)
    d2 = gmpy2.invert(e2 // GCD2, phi_n2)

    mi1 = gmpy2.powmod(c1, d1, p * q1) % q1
    mi2 = gmpy2.powmod(c2, d2, p * q2) % q2
    aa = [mi1, mi2]
    nn = [q1, q2]
    last = CRT(aa, nn)
    # last = m2**7 mod (q1*q2)
    new_d = gmpy2.invert(7, (q1 - 1) * (q2 - 1))
    m_2 = gmpy2.powmod(last, new_d, q1 * q2)
    m = gmpy2.iroot(m_2, 2)[0]
    print(long_to_bytes(m))
```
## [INSHack2017]rsa16m ， nc很大, 相对的e很小。有可能$m^e$比n小, 直接尝试对c开e次方。
前一直说小加密指数攻击，举例都是说e=3等，其实所谓的‘小’不过是相对而言的，关键是要看$m^e$ 与n的大小。
```python
import gmpy2
import Crypto.Util.number

txt = open('rsa_16m', 'r').read()
exec(txt)
m = gmpy2.iroot(c, e)[0]

print(Crypto.Util.number.long_to_bytes(m))
```


## [QCTF2018]Xman-RSA
题目
```python
from gmpy2 import is_prime
from os import urandom
import base64


def bytes_to_num(b):
    return int(b.encode('hex'), 16)


def num_to_bytes(n):    # 去掉最后字符
    b = hex(n)[2:-1]
    b = '0' + b if len(b) % 2 == 1 else b
    return b.decode('hex')


def get_a_prime(l):
    random_seed = urandom(l)

    num = bytes_to_num(random_seed)

    while True:
        if is_prime(num):
            break
        num += 1
    return num


def encrypt(s, e, n):
    p = bytes_to_num(s)
    p = pow(p, e, n)
    return num_to_bytes(p).encode('hex')


def separate(n):
    p = n % 4
    t = (p * p) % 4  # 偶数0 奇数1
    return t == 1 # 偶数 false 奇数 true


f = open('flag.txt', 'r')
flag = f.read()

msg1 = "" # flag 0 2 4 6偶数集合
msg2 = "" # flag 1 3 5 7 集合
for i in range(len(flag)):
    if separate(i): # 奇数
        msg2 += flag[i]
    else: # 偶数
        msg1 += flag[i]

p1 = get_a_prime(128)
p2 = get_a_prime(128)
p3 = get_a_prime(128)
n1 = p1 * p2
n2 = p1 * p3
e = 0x1001
c1 = encrypt(msg1, e, n1)
c2 = encrypt(msg2, e, n2)
print(c1)  # n1 encrypted
print(c2)

e1 = 0x1001
e2 = 0x101
p4 = get_a_prime(128)
p5 = get_a_prime(128)
n3 = p4 * p5
c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex') # 共模攻击 得到n1, 再解p1
c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex') 
print(c1)  # cipher
print(c2)

print(base64.b64encode(num_to_bytes(n2)))  # n2 n3
print(base64.b64encode(num_to_bytes(n3)))
```

exp
```python
import base64
from Crypto.Util.number import bytes_to_long, long_to_bytes
import gmpy2

n2 = b'PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw=='
n3 = b'TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ=='
f1 = 0x1240198b148089290e375b999569f0d53c32d356b2e95f5acee070f016b3bef243d0b5e46d9ad7aa7dfe2f21bda920d0ac7ce7b1e48f22b2de410c6f391ce7c4347c65ffc9704ecb3068005e9f35cbbb7b27e0f7a18f4f42ae572d77aaa3ee189418d6a07bab7d93beaa365c98349d8599eb68d21313795f380f05f5b3dfdc6272635ede1f83d308c0fdb2baf444b9ee138132d0d532c3c7e60efb25b9bf9cb62dba9833aa3706344229bd6045f0877661a073b6deef2763452d0ad7ab3404ba494b93fd6dfdf4c28e4fe83a72884a99ddf15ca030ace978f2da87b79b4f504f1d15b5b96c654f6cd5179b72ed5f84d3a16a8f0d5bf6774e7fd98d27bf3c9839
f2 = 0x129d5d4ab3f9e8017d4e6761702467bbeb1b884b6c4f8ff397d078a8c41186a3d52977fa2307d5b6a0ad01fedfc3ba7b70f776ba3790a43444fb954e5afd64b1a3abeb6507cf70a5eb44678a886adf81cb4848a35afb4db7cd7818f566c7e6e2911f5ababdbdd2d4ff9825827e58d48d5466e021a64599b3e867840c07e29582961f81643df07f678a61a9f9027ebd34094e272dfbdc4619fa0ac60f0189af785df77e7ec784e086cf692a7bf7113a7fb8446a65efa8b431c6f72c14bcfa49c9b491fb1d87f2570059e0f13166a85bb555b40549f45f04bc5dbd09d8b858a5382be6497d88197ffb86381085756365bd757ec3cdfa8a77ba1728ec2de596c5ab
e1 = 0x1001
e2 = 0x101
e = 0x1001
c1 = 0x2639c28e3609a4a8c953cca9c326e8e062756305ae8aee6efcd346458aade3ee8c2106ab9dfe5f470804f366af738aa493fd2dc26cb249a922e121287f3eddec0ed8dea89747dc57aed7cd2089d75c23a69bf601f490a64f73f6a583081ae3a7ed52238c13a95d3322065adba9053ee5b12f1de1873dbad9fbf4a50a2f58088df0fddfe2ed8ca1118c81268c8c0fd5572494276f4e48b5eb424f116e6f5e9d66da1b6b3a8f102539b690c1636e82906a46f3c5434d5b04ed7938861f8d453908970eccef07bf13f723d6fdd26a61be8b9462d0ddfbedc91886df194ea022e56c1780aa6c76b9f1c7d5ea743dc75cec3c805324e90ea577fa396a1effdafa3090
c2 = 0x42ff1157363d9cd10da64eb4382b6457ebb740dbef40ade9b24a174d0145adaa0115d86aa2fc2a41257f2b62486eaebb655925dac78dd8d13ab405aef5b8b8f9830094c712193500db49fb801e1368c73f88f6d8533c99c8e7259f8b9d1c926c47215ed327114f235ba8c873af7a0052aa2d32c52880db55c5615e5a1793b690c37efdd5e503f717bb8de716303e4d6c4116f62d81be852c5d36ef282a958d8c82cf3b458dcc8191dcc7b490f227d1562b1d57fbcf7bf4b78a5d90cd385fd79c8ca4688e7d62b3204aeaf9692ba4d4e44875eaa63642775846434f9ce51d138ca702d907849823b1e86896e4ea6223f93fae68b026cfe5fa5a665569a9e3948a
n2 = bytes_to_long(base64.b64decode(n2))
n3 = bytes_to_long(base64.b64decode(n3))


def common_modulus(n, c1, e1, c2, e2):
    s = gmpy2.gcdext(e1, e2)
    m1 = gmpy2.powmod(c1, s[1], n)
    m2 = gmpy2.powmod(c2, s[2], n)
    m = (m1 * m2) % n
    return m


n1 = common_modulus(n3, c1, e1, c2, e2)
p1 = gmpy2.gcd(n1, n2)

p2 = n1 // p1
phi_1 = (p1 - 1) * (p2 - 1)
d1 = gmpy2.invert(e, phi_1)
m1 = pow(f1, d1, n1)

p3 = n2 // p1
phi_2 = (p1 - 1) * (p3 - 1)
d2 = gmpy2.invert(e, phi_2)
m2 = pow(f2, d2, n2)

m1 = long_to_bytes(m1).decode()
m2 = long_to_bytes(m2).decode()

for x,y in zip(m1,m2):
    print(f'{x}{y}', end='')
```

## 结合多项式环,  [watevrCTF 2019]Swedish RSA
https://yoloyolo.top/2021/01/21/RSA-0/

```python
flag = bytearray(raw_input())
flag = list(flag)
length = len(flag)
bits = 16

## Prime for Finite Field.
p = random_prime(2^bits-1, False, 2^(bits-1))

file_out = open("downloads/polynomial_rsa.txt", "w")
file_out.write("Prime: " + str(p) + "\n")

## Univariate Polynomial Ring in y over Finite Field of size p
R.<y> = PolynomialRing(GF(p))

## Analogous to the primes in Z
def gen_irreducable_poly(deg):
    while True:
        out = R.random_element(degree=deg)
        if out.is_irreducible():
            return out


## Polynomial "primes"
P = gen_irreducable_poly(ZZ.random_element(length, 2*length))
Q = gen_irreducable_poly(ZZ.random_element(length, 2*length))

## Public exponent key
e = 65537

## Modulus
N = P*Q
file_out.write("Modulus: " + str(N) + "\n")

## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)
S.<x> = R.quotient(N)

## Encrypt
m = S(flag)
c = m^e

file_out.write("Ciphertext: " + str(c))
file_out.close()
############
Prime: 43753
Modulus: 34036*y^177 + 23068*y^176 + 13147*y^175 + 36344*y^174 + 10045*y^173 + 41049*y^172 + 17786*y^171 + 16601*y^170 + 7929*y^169 + 37570*y^168 + 990*y^167 + 9622*y^166 + 39273*y^165 + 35284*y^164 + 15632*y^163 + 18850*y^162 + 8800*y^161 + 33148*y^160 + 12147*y^159 + 40487*y^158 + 6407*y^157 + 34111*y^156 + 8446*y^155 + 21908*y^154 + 16812*y^153 + 40624*y^152 + 43506*y^151 + 39116*y^150 + 33011*y^149 + 23914*y^148 + 2210*y^147 + 23196*y^146 + 43359*y^145 + 34455*y^144 + 17684*y^143 + 25262*y^142 + 982*y^141 + 24015*y^140 + 27968*y^139 + 37463*y^138 + 10667*y^137 + 39519*y^136 + 31176*y^135 + 27520*y^134 + 32118*y^133 + 8333*y^132 + 38945*y^131 + 34713*y^130 + 1107*y^129 + 43604*y^128 + 4433*y^127 + 18110*y^126 + 17658*y^125 + 32354*y^124 + 3219*y^123 + 40238*y^122 + 10439*y^121 + 3669*y^120 + 8713*y^119 + 21027*y^118 + 29480*y^117 + 5477*y^116 + 24332*y^115 + 43480*y^114 + 33406*y^113 + 43121*y^112 + 1114*y^111 + 17198*y^110 + 22829*y^109 + 24424*y^108 + 16523*y^107 + 20424*y^106 + 36206*y^105 + 41849*y^104 + 3584*y^103 + 26500*y^102 + 31897*y^101 + 34640*y^100 + 27449*y^99 + 30962*y^98 + 41434*y^97 + 22125*y^96 + 24314*y^95 + 3944*y^94 + 18400*y^93 + 38476*y^92 + 28904*y^91 + 27936*y^90 + 41867*y^89 + 25573*y^88 + 25659*y^87 + 33443*y^86 + 18435*y^85 + 5934*y^84 + 38030*y^83 + 17563*y^82 + 24086*y^81 + 36782*y^80 + 20922*y^79 + 38933*y^78 + 23448*y^77 + 10599*y^76 + 7156*y^75 + 29044*y^74 + 23605*y^73 + 7657*y^72 + 28200*y^71 + 2431*y^70 + 3860*y^69 + 23259*y^68 + 14590*y^67 + 33631*y^66 + 15673*y^65 + 36049*y^64 + 29728*y^63 + 22413*y^62 + 18602*y^61 + 18557*y^60 + 23505*y^59 + 17642*y^58 + 12595*y^57 + 17255*y^56 + 15316*y^55 + 8948*y^54 + 38*y^53 + 40329*y^52 + 9823*y^51 + 5798*y^50 + 6379*y^49 + 8662*y^48 + 34640*y^47 + 38321*y^46 + 18760*y^45 + 13135*y^44 + 15926*y^43 + 34952*y^42 + 28940*y^41 + 13558*y^40 + 42579*y^39 + 38015*y^38 + 33788*y^37 + 12381*y^36 + 195*y^35 + 13709*y^34 + 31500*y^33 + 32994*y^32 + 30486*y^31 + 40414*y^30 + 2578*y^29 + 30525*y^28 + 43067*y^27 + 6195*y^26 + 36288*y^25 + 23236*y^24 + 21493*y^23 + 15808*y^22 + 34500*y^21 + 6390*y^20 + 42994*y^19 + 42151*y^18 + 19248*y^17 + 19291*y^16 + 8124*y^15 + 40161*y^14 + 24726*y^13 + 31874*y^12 + 30272*y^11 + 30761*y^10 + 2296*y^9 + 11017*y^8 + 16559*y^7 + 28949*y^6 + 40499*y^5 + 22377*y^4 + 33628*y^3 + 30598*y^2 + 4386*y + 23814
Ciphertext: 5209*x^176 + 10881*x^175 + 31096*x^174 + 23354*x^173 + 28337*x^172 + 15982*x^171 + 13515*x^170 + 21641*x^169 + 10254*x^168 + 34588*x^167 + 27434*x^166 + 29552*x^165 + 7105*x^164 + 22604*x^163 + 41253*x^162 + 42675*x^161 + 21153*x^160 + 32838*x^159 + 34391*x^158 + 832*x^157 + 720*x^156 + 22883*x^155 + 19236*x^154 + 33772*x^153 + 5020*x^152 + 17943*x^151 + 26967*x^150 + 30847*x^149 + 10306*x^148 + 33966*x^147 + 43255*x^146 + 20342*x^145 + 4474*x^144 + 3490*x^143 + 38033*x^142 + 11224*x^141 + 30565*x^140 + 31967*x^139 + 32382*x^138 + 9759*x^137 + 1030*x^136 + 32122*x^135 + 42614*x^134 + 14280*x^133 + 16533*x^132 + 32676*x^131 + 43070*x^130 + 36009*x^129 + 28497*x^128 + 2940*x^127 + 9747*x^126 + 22758*x^125 + 16615*x^124 + 14086*x^123 + 13038*x^122 + 39603*x^121 + 36260*x^120 + 32502*x^119 + 17619*x^118 + 17700*x^117 + 15083*x^116 + 11311*x^115 + 36496*x^114 + 1300*x^113 + 13601*x^112 + 43425*x^111 + 10376*x^110 + 11551*x^109 + 13684*x^108 + 14955*x^107 + 6661*x^106 + 12674*x^105 + 21534*x^104 + 32132*x^103 + 34135*x^102 + 43684*x^101 + 837*x^100 + 29311*x^99 + 4849*x^98 + 26632*x^97 + 26662*x^96 + 10159*x^95 + 32657*x^94 + 12149*x^93 + 17858*x^92 + 35805*x^91 + 19391*x^90 + 30884*x^89 + 42039*x^88 + 17292*x^87 + 4694*x^86 + 1497*x^85 + 1744*x^84 + 31071*x^83 + 26246*x^82 + 24402*x^81 + 22068*x^80 + 39263*x^79 + 23703*x^78 + 21484*x^77 + 12241*x^76 + 28821*x^75 + 32886*x^74 + 43075*x^73 + 35741*x^72 + 19936*x^71 + 37219*x^70 + 33411*x^69 + 8301*x^68 + 12949*x^67 + 28611*x^66 + 42654*x^65 + 6910*x^64 + 18523*x^63 + 31144*x^62 + 21398*x^61 + 36298*x^60 + 27158*x^59 + 918*x^58 + 38601*x^57 + 4269*x^56 + 5699*x^55 + 36444*x^54 + 34791*x^53 + 37978*x^52 + 32481*x^51 + 8039*x^50 + 11012*x^49 + 11454*x^48 + 30450*x^47 + 1381*x^46 + 32403*x^45 + 8202*x^44 + 8404*x^43 + 37648*x^42 + 43696*x^41 + 34237*x^40 + 36490*x^39 + 41423*x^38 + 35792*x^37 + 36950*x^36 + 31086*x^35 + 38970*x^34 + 12439*x^33 + 7963*x^32 + 16150*x^31 + 11382*x^30 + 3038*x^29 + 20157*x^28 + 23531*x^27 + 32866*x^26 + 5428*x^25 + 21132*x^24 + 13443*x^23 + 28909*x^22 + 42716*x^21 + 6567*x^20 + 24744*x^19 + 8727*x^18 + 14895*x^17 + 28172*x^16 + 30903*x^15 + 26608*x^14 + 27314*x^13 + 42224*x^12 + 42551*x^11 + 37726*x^10 + 11203*x^9 + 36816*x^8 + 5537*x^7 + 20301*x^6 + 17591*x^5 + 41279*x^4 + 7999*x^3 + 33753*x^2 + 34551*x + 9659

```

exp
```python
R.<y> = PolynomialRing(GF(43753))
n = R("34036*y^177 + 23068*y^176 + 13147*y^175 + 36344*y^174 + 10045*y^173 + 41049*y^172 + 17786*y^171 + 16601*y^170 + 7929*y^169 + 37570*y^168 + 990*y^167 + 9622*y^166 + 39273*y^165 + 35284*y^164 + 15632*y^163 + 18850*y^162 + 8800*y^161 + 33148*y^160 + 12147*y^159 + 40487*y^158 + 6407*y^157 + 34111*y^156 + 8446*y^155 + 21908*y^154 + 16812*y^153 + 40624*y^152 + 43506*y^151 + 39116*y^150 + 33011*y^149 + 23914*y^148 + 2210*y^147 + 23196*y^146 + 43359*y^145 + 34455*y^144 + 17684*y^143 + 25262*y^142 + 982*y^141 + 24015*y^140 + 27968*y^139 + 37463*y^138 + 10667*y^137 + 39519*y^136 + 31176*y^135 + 27520*y^134 + 32118*y^133 + 8333*y^132 + 38945*y^131 + 34713*y^130 + 1107*y^129 + 43604*y^128 + 4433*y^127 + 18110*y^126 + 17658*y^125 + 32354*y^124 + 3219*y^123 + 40238*y^122 + 10439*y^121 + 3669*y^120 + 8713*y^119 + 21027*y^118 + 29480*y^117 + 5477*y^116 + 24332*y^115 + 43480*y^114 + 33406*y^113 + 43121*y^112 + 1114*y^111 + 17198*y^110 + 22829*y^109 + 24424*y^108 + 16523*y^107 + 20424*y^106 + 36206*y^105 + 41849*y^104 + 3584*y^103 + 26500*y^102 + 31897*y^101 + 34640*y^100 + 27449*y^99 + 30962*y^98 + 41434*y^97 + 22125*y^96 + 24314*y^95 + 3944*y^94 + 18400*y^93 + 38476*y^92 + 28904*y^91 + 27936*y^90 + 41867*y^89 + 25573*y^88 + 25659*y^87 + 33443*y^86 + 18435*y^85 + 5934*y^84 + 38030*y^83 + 17563*y^82 + 24086*y^81 + 36782*y^80 + 20922*y^79 + 38933*y^78 + 23448*y^77 + 10599*y^76 + 7156*y^75 + 29044*y^74 + 23605*y^73 + 7657*y^72 + 28200*y^71 + 2431*y^70 + 3860*y^69 + 23259*y^68 + 14590*y^67 + 33631*y^66 + 15673*y^65 + 36049*y^64 + 29728*y^63 + 22413*y^62 + 18602*y^61 + 18557*y^60 + 23505*y^59 + 17642*y^58 + 12595*y^57 + 17255*y^56 + 15316*y^55 + 8948*y^54 + 38*y^53 + 40329*y^52 + 9823*y^51 + 5798*y^50 + 6379*y^49 + 8662*y^48 + 34640*y^47 + 38321*y^46 + 18760*y^45 + 13135*y^44 + 15926*y^43 + 34952*y^42 + 28940*y^41 + 13558*y^40 + 42579*y^39 + 38015*y^38 + 33788*y^37 + 12381*y^36 + 195*y^35 + 13709*y^34 + 31500*y^33 + 32994*y^32 + 30486*y^31 + 40414*y^30 + 2578*y^29 + 30525*y^28 + 43067*y^27 + 6195*y^26 + 36288*y^25 + 23236*y^24 + 21493*y^23 + 15808*y^22 + 34500*y^21 + 6390*y^20 + 42994*y^19 + 42151*y^18 + 19248*y^17 + 19291*y^16 + 8124*y^15 + 40161*y^14 + 24726*y^13 + 31874*y^12 + 30272*y^11 + 30761*y^10 + 2296*y^9 + 11017*y^8 + 16559*y^7 + 28949*y^6 + 40499*y^5 + 22377*y^4 + 33628*y^3 + 30598*y^2 + 4386*y + 23814")
c = R("5209*y^176 + 10881*y^175 + 31096*y^174 + 23354*y^173 + 28337*y^172 + 15982*y^171 + 13515*y^170 + 21641*y^169 + 10254*y^168 + 34588*y^167 + 27434*y^166 + 29552*y^165 + 7105*y^164 + 22604*y^163 + 41253*y^162 + 42675*y^161 + 21153*y^160 + 32838*y^159 + 34391*y^158 + 832*y^157 + 720*y^156 + 22883*y^155 + 19236*y^154 + 33772*y^153 + 5020*y^152 + 17943*y^151 + 26967*y^150 + 30847*y^149 + 10306*y^148 + 33966*y^147 + 43255*y^146 + 20342*y^145 + 4474*y^144 + 3490*y^143 + 38033*y^142 + 11224*y^141 + 30565*y^140 + 31967*y^139 + 32382*y^138 + 9759*y^137 + 1030*y^136 + 32122*y^135 + 42614*y^134 + 14280*y^133 + 16533*y^132 + 32676*y^131 + 43070*y^130 + 36009*y^129 + 28497*y^128 + 2940*y^127 + 9747*y^126 + 22758*y^125 + 16615*y^124 + 14086*y^123 + 13038*y^122 + 39603*y^121 + 36260*y^120 + 32502*y^119 + 17619*y^118 + 17700*y^117 + 15083*y^116 + 11311*y^115 + 36496*y^114 + 1300*y^113 + 13601*y^112 + 43425*y^111 + 10376*y^110 + 11551*y^109 + 13684*y^108 + 14955*y^107 + 6661*y^106 + 12674*y^105 + 21534*y^104 + 32132*y^103 + 34135*y^102 + 43684*y^101 + 837*y^100 + 29311*y^99 + 4849*y^98 + 26632*y^97 + 26662*y^96 + 10159*y^95 + 32657*y^94 + 12149*y^93 + 17858*y^92 + 35805*y^91 + 19391*y^90 + 30884*y^89 + 42039*y^88 + 17292*y^87 + 4694*y^86 + 1497*y^85 + 1744*y^84 + 31071*y^83 + 26246*y^82 + 24402*y^81 + 22068*y^80 + 39263*y^79 + 23703*y^78 + 21484*y^77 + 12241*y^76 + 28821*y^75 + 32886*y^74 + 43075*y^73 + 35741*y^72 + 19936*y^71 + 37219*y^70 + 33411*y^69 + 8301*y^68 + 12949*y^67 + 28611*y^66 + 42654*y^65 + 6910*y^64 + 18523*y^63 + 31144*y^62 + 21398*y^61 + 36298*y^60 + 27158*y^59 + 918*y^58 + 38601*y^57 + 4269*y^56 + 5699*y^55 + 36444*y^54 + 34791*y^53 + 37978*y^52 + 32481*y^51 + 8039*y^50 + 11012*y^49 + 11454*y^48 + 30450*y^47 + 1381*y^46 + 32403*y^45 + 8202*y^44 + 8404*y^43 + 37648*y^42 + 43696*y^41 + 34237*y^40 + 36490*y^39 + 41423*y^38 + 35792*y^37 + 36950*y^36 + 31086*y^35 + 38970*y^34 + 12439*y^33 + 7963*y^32 + 16150*y^31 + 11382*y^30 + 3038*y^29 + 20157*y^28 + 23531*y^27 + 32866*y^26 + 5428*y^25 + 21132*y^24 + 13443*y^23 + 28909*y^22 + 42716*y^21 + 6567*y^20 + 24744*y^19 + 8727*y^18 + 14895*y^17 + 28172*y^16 + 30903*y^15 + 26608*y^14 + 27314*y^13 + 42224*y^12 + 42551*y^11 + 37726*y^10 + 11203*y^9 + 36816*y^8 + 5537*y^7 + 20301*y^6 + 17591*y^5 + 41279*y^4 + 7999*y^3 + 33753*y^2 + 34551*y + 9659")
#print(factor(n))
import gmpy2
f = 43753
e = 65537
phi = (f**65 - 1)*(f**112 - 1) # 分解n后 能看到一个x * p *q , p q最高次幂分别为65 112
d = gmpy2.invert(e, phi)
m = pow(c, Integer(d), n)
for i in range(63):
    print(chr(m[i]), end='')
```

## 环和 ecc-rsa , [watevrCTF 2019]ECC-RSA
```python
from fastecdsa.curve import P521 as Curve
from fastecdsa.point import Point
from Crypto.Util.number import bytes_to_long, isPrime
from os import urandom
from random import getrandbits
 
def gen_rsa_primes(G):
    urand = bytes_to_long(urandom(521//8))
    while True:
        s = getrandbits(521) ^ urand
 
        Q = s*G
        if isPrime(Q.x) and isPrime(Q.y):
            print("ECC Private key:", hex(s))
            print("RSA primes:", hex(Q.x), hex(Q.y))
            print("Modulo:", hex(Q.x * Q.y))
            return (Q.x, Q.y)
 
 
flag = int.from_bytes(input(), byteorder="big")
 
ecc_p = Curve.p
a = Curve.a
b = Curve.b
 
Gx = Curve.gx
Gy = Curve.gy
G = Point(Gx, Gy, curve=Curve)
 
 
e = 0x10001
p, q = gen_rsa_primes(G)
n = p*q
 
 
file_out = open("downloads/ecc-rsa.txt", "w")
 
file_out.write("ECC Curve Prime: " + hex(ecc_p) + "\n")
file_out.write("Curve a: " + hex(a) + "\n")
file_out.write("Curve b: " + hex(b) + "\n")
file_out.write("Gx: " + hex(Gx) + "\n")
file_out.write("Gy: " + hex(Gy) + "\n")
 
file_out.write("e: " + hex(e) + "\n")
file_out.write("p * q: " + hex(n) + "\n")
 
c = pow(flag, e, n)
file_out.write("ciphertext: " + hex(c) + "\n")
```

$$
\begin{multline}
\shoveleft
\begin{aligned}
& y^2 \equiv x^3 + a*x + b mod \  ecc\_prime \\
& 这里p对应x, q对应y \\
& q^2 \equiv p^3 + a*p + b \ mod \ ecc\_prime \\ 
& p^2 * q^2 \equiv (p^3+a*p+b) * p^2 \  mod \ ecc\_prime \\
& n^2 \equiv (p^3 + a*p + b) *p^2 \  mod \ ecc\_prime \\
& 0  \equiv (p^3 + a*p + b) *p^2 - n^2 \  mod \ ecc\_prime \\
\end{aligned}
\end{multline}
$$


```python
ep = 0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
a = -0x3
b = 0x51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00
Gx = 0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66
Gy = 0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650
e = 0x10001
n = 0x118aaa1add80bdd0a1788b375e6b04426c50bb3f9cae0b173b382e3723fc858ce7932fb499cd92f5f675d4a2b05d2c575fc685f6cf08a490d6c6a8a6741e8be4572adfcba233da791ccc0aee033677b72788d57004a776909f6d699a0164af514728431b5aed704b289719f09d591f5c1f9d2ed36a58448a9d57567bd232702e9b28f
c = 0x3862c872480bdd067c0c68cfee4527a063166620c97cca4c99baff6eb0cf5d42421b8f8d8300df5f8c7663adb5d21b47c8cb4ca5aab892006d7d44a1c5b5f5242d88c6e325064adf9b969c7dfc52a034495fe67b5424e1678ca4332d59225855b7a9cb42db2b1db95a90ab6834395397e305078c5baff78c4b7252d7966365afed9e

import gmpy2
from Crypto.Util.number import *
F.<x> = Zmod(ep)[]  # 定义一个商环, ep是模。
f = (x**3 + a * x + b)*(x**2) - n**2
pset = f.roots() # 开方
for _ in pset:
    p = Integer(_[0])
    q = n // p
    phi = (p - 1)*(q - 1)
    d = gmpy2.invert(gmpy2.mpz(e), gmpy2.mpz(phi))
    m = pow(c, d, n)
    print(long_to_bytes(m))
```

## 连分数/渐近分数求值, [羊城杯 2020]RRRRRRRSA

```python
import hashlib
import sympy
from Crypto.Util.number import *

flag = 'GWHT{************}'

flag1 = flag[:19].encode()
flag2 = flag[19:].encode()
assert(len(flag) == 38)

P1 = getPrime(1038)
P2 = sympy.nextprime(P1)
assert(P2 - P1 < 1000)

Q1 = getPrime(512)
Q2 = sympy.nextprime(Q1)

N1 = P1 * P1 * Q1
N2 = P2 * P2 * Q2

E1 = getPrime(1024)
E2 = sympy.nextprime(E1)

m1 = bytes_to_long(flag1)
m2 = bytes_to_long(flag2)

c1 = pow(m1, E1, N1)
c2 = pow(m2, E2, N2)

output = open('secret', 'w')
output.write('N1=' + str(N1) + '\n')
output.write('c1=' + str(c1) + '\n')
output.write('E1=' + str(E1) + '\n')
output.write('N2=' + str(N2) + '\n')
output.write('c2=' + str(c2) + '\n')
output.write('E2=' + str(E2) + '\n')
output.close()

N1=60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347
c1=55094296873556883585060020895253176070835143350249581136609315815308788255684072804968957510292559743192424646169207794748893753882418256401223641287546922358162629295622258913168323493447075410872354874300793298956869374606043622559405978242734950156459436487837698668489891733875650048466360950142617732135781244969524095348835624828008115829566644654403962285001724209210887446203934276651265377137788183939798543755386888532680013170540716736656670269251318800501517579803401154996881233025210176293554542024052540093890387437964747460765498713092018160196637928204190194154199389276666685436565665236397481709703644555328705818892269499380797044554054118656321389474821224725533693520856047736578402581854165941599254178019515615183102894716647680969742744705218868455450832
E1=125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820423103
N2=60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121
c2=39328446140156257571484184713861319722905864197556720730852773059147902283123252767651430278357950872626778348596897711320942449693270603776870301102881405303651558719085454281142395652056217241751656631812580544180434349840236919765433122389116860827593711593732385562328255759509355298662361508611531972386995239908513273236239858854586845849686865360780290350287139092143587037396801704351692736985955152935601987758859759421886670907735120137698039900161327397951758852875291442188850946273771733011504922325622240838288097946309825051094566685479503461938502373520983684296658971700922069426788236476575236189040102848418547634290214175167767431475003216056701094275899211419979340802711684989710130215926526387138538819531199810841475218142606691152928236362534181622201347
E2=125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820425393
```


显然我们可以知道的是N1/N2 <Q1/Q2
所以在Q1/Q2在区间(N1/N2,1)之间 (这是关键）
尝试对N1/N2进行连分数展开并求其各项渐进分数，其中某个连分数的分母可能就是Q1（这个可以依靠N%Q来验证）

$\frac {N_1}{N_2} = \frac {P_1^2}{P_2^2}* \frac {Q_1}{Q_2}$，对式子进行连分数攻击


```python
import gmpy2
from Crypto.Util.number import long_to_bytes


def transform(x, y):  # 使用辗转相除将分数x/y转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res


def continued_fraction(sub_res):
    numerator, denominator = 1, 0
    for i in sub_res[::-1]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回


# 求解每个渐进分数
def sub_fraction(x, y):
    res = transform(x, y)
    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def wienerAttack(n1, n2):
    for (q2, q1) in sub_fraction(n1, n2):  # 用一个for循环来注意试探n1/n2的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if q1 == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if n1 % q1 == 0 and q1 != 1:  # 成立条件
            return (q1, q2)
    print("该方法不适用")


N1 = 60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347
c1 = 55094296873556883585060020895253176070835143350249581136609315815308788255684072804968957510292559743192424646169207794748893753882418256401223641287546922358162629295622258913168323493447075410872354874300793298956869374606043622559405978242734950156459436487837698668489891733875650048466360950142617732135781244969524095348835624828008115829566644654403962285001724209210887446203934276651265377137788183939798543755386888532680013170540716736656670269251318800501517579803401154996881233025210176293554542024052540093890387437964747460765498713092018160196637928204190194154199389276666685436565665236397481709703644555328705818892269499380797044554054118656321389474821224725533693520856047736578402581854165941599254178019515615183102894716647680969742744705218868455450832
E1 = 125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820423103
N2 = 60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121
c2 = 39328446140156257571484184713861319722905864197556720730852773059147902283123252767651430278357950872626778348596897711320942449693270603776870301102881405303651558719085454281142395652056217241751656631812580544180434349840236919765433122389116860827593711593732385562328255759509355298662361508611531972386995239908513273236239858854586845849686865360780290350287139092143587037396801704351692736985955152935601987758859759421886670907735120137698039900161327397951758852875291442188850946273771733011504922325622240838288097946309825051094566685479503461938502373520983684296658971700922069426788236476575236189040102848418547634290214175167767431475003216056701094275899211419979340802711684989710130215926526387138538819531199810841475218142606691152928236362534181622201347
E2 = 125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820425393

q1, q2 = wienerAttack(N1, N2)
p1 = gmpy2.iroot(N1 // q1, 2)[0]
p2 = gmpy2.next_prime(p1)
phi1 = p1 * (p1 - 1) * (q1 - 1)
phi2 = p2 * (p2 - 1) * (q2 - 1)
d1 = gmpy2.invert(E1, phi1)
d2 = gmpy2.invert(E2, phi2)
m1 = long_to_bytes(gmpy2.powmod(c1, d1, N1))
m2 = long_to_bytes(gmpy2.powmod(c2, d2, N2))
print((m1 + m2))

```


## coppersmith-1, sagemath 低位128位 丢失, ctfshow easyrsa7

```python
p = 0xd1c520d9798f811e87f4ff406941958bab8fc24b19a32c3ad89b0b73258ed3541e9ca696fd98ce15255264c39ae8c6e8db5ee89993fa44459410d30a0a8af700ae3aee8a9a1d6094f8c757d3b79a8d1147e85be34fb260a970a52826c0a92b46cefb5dfaf2b5a31edf867f8d34d2222900000000000000000000000000000000
n = 0x79e0bf9b916e59286163a1006f8cefd4c1b080387a6ddb98a3f3984569a4ebb48b22ac36dff7c98e4ebb90ffdd9c07f53a20946f57634fb01f4489fcfc8e402865e152820f3e2989d4f0b5ef1fb366f212e238881ea1da017f754d7840fc38236edba144674464b661d36cdaf52d1e5e7c3c21770c5461a7c1bc2db712a61d992ebc407738fc095cd8b6b64e7e532187b11bf78a8d3ddf52da6f6a67c7e88bef5563cac1e5ce115f3282d5ff9db02278859f63049d1b934d918f46353fea1651d96b2ddd874ec8f1e4b9d487d8849896d1c21fb64029f0d6f47e560555b009b96bfd558228929a6cdf3fb6d47a956829fb1e638fcc1bdfad4ec2c3590dea1ed3

pbits = 1024
kbits = 128 # pbits - p.nbits()

PR.<x> = PolynomialRing(Zmod(n))
f = x+p
x0 = f.small_roots(X=2^kbits, beta=0.4)[0]
print(p+int(x0))
```

## coppersmith-2, sagemath 低位315位 丢失, ctfshow 

```python
# sage
from Crypto.Util.number import *

n = 14113948189208713011909396304970377626324044633561155020366406284451614054260708934598840781397326960921718892801653205159753091559901114082556464576477585198060530094478860626532455065960136263963965819002575418616768412539016154873800614138683106056209070597212668250136909436974469812231498651367459717175769611385545792201291192023843434476550550829737236225181770896867698281325858412643953550465132756142888893550007041167700300621499970661661288422834479368072744930285128061160879720771910458653611076539210357701565156322144818787619821653007453741709031635862923191561438148729294430924288173571196757351837
mbar = 1520800285708753284739523608878585974609134243280728660335545667177630830064371336150456537012842986526527904043383436211487979254140749228004148347597566264500276581990635110200009305900689510908049771218073767918907869112593870878204145615928290375086195098919355531430003571366638390993296583488184959318678321571278510231561645872308920917404996519309473979203661442792048291421574603018835698487725981963573816645574675640357569465990665689618997534740389987351864738104038598104713275375385003471306823348792559733332094774873827383320058176803218213042061965933143968710199376164960850951030741280074168795136
c = 6635663565033382363211849843446648120305449056573116171933923595209656581213410699649926913276685818674688954045817246263487415328838542489103709103428412175252447323358040041217431171817865818374522191881448865227314554997131690963910348820833080760482835650538394814181656599175839964284713498394589419605748581347163389157651739759144560719049281761889094518791244702056048080280278984031050608249265997808217512349309696532160108250480622956599732443714546043439089844571655280770141647694859907985919056009576606333143546094941635324929407538860140272562570973340199814409134962729885962133342668270226853146819
e = 3
kbits = 315

PR.<x>=PolynomialRing(Zmod(n))
f = (mbar + x) ^ e - c   # 条件等式
x0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n

print(long_to_bytes(mbar + x0))

```

## unusualrsa2 , 多个  ax+b mod n = c 这种

https://blog.csdn.net/m0_49109277/article/details/118603921#t5


题目
```python
# ********************
# @Author: Lazzaro
# ********************

from Crypto.Util.number import getPrime,bytes_to_long,long_to_bytes
from functools import reduce
from secret import flag, x, y

m = bytes_to_long(flag)
p = getPrime(1024)
q = getPrime(1024)
n = p*q
print(n)

assert(reduce(lambda x,y:x&y,[(i-5)*i+6==0 for i in x]))
assert(reduce(lambda x,y:x&y,[(j-15)*j+44==0 for j in y]))

print(pow(reduce(lambda x,y:x*m+y,x),17,n))
print(pow(reduce(lambda x,y:x*m+y,y),17,n))

#23772599983135215481563178266884362291876571759991288577057472733374903836591330410574958472090396886895304944176208711481780781286891334062794555288959410390926474473859289842654809538435377431088422352076225067494924657598298955407771484146155998883073439266427190212827600119365643065276814044272790573450938596830336430371987561905132579730619341196199420897034988685012777895002554746080384319298123154671447844799088258541911028041717897434816921424155687677867019535399434825468160227242441375503664915265223696139025407768146464383537556265875013085702422829200814612395116961538432886116917063119749068212699
#10900151504654409767059699202929100225155892269473271859207513720755903691031362539478242920144073599515746938827937863835169270383721094542639011665235593065932998091574636525973099426040452626893461449084383663453549354608769727777329036059746386523843912382289597182615339786437186169811342356085836838520978047561127661777189045888648773949147220411427306098338616422692914110656004863767719312410906124366000507952960331116878197129010412361636679449281808407214524741732730279777729251515759320442591663641984363061618865267606007355576230009922421807527598213455112981354590909603317525854070358390622096569841
#17298679220717326374674940612143058330715465693318467692839033642321129433471254547497087746971317567301086124779289015934582615377165560688447452762043163082394944604062014490446763247008217251611443338103074143809936437694543761369945095202092750900940979469994907399829695696313513303922266742415376818434932335640062684245008822643258497589196668426788916969378417960200705779461808292296450298558001909603602502604228973101048082095642290047196235959438278631661658312398313171590515776453711432353011579809351076532129444735206408591345372296372378396539831385036814349328459266432393612919118094115543053115450
```
x是[2,3]集合， y是[4,11]集合 假设为 x = [2,3] ,  y = [4,11]

$$
c = (2m+3)^{17} mod \ n \\ 
c = (4m+11)^{17} mod \ n \\ 
$$

我们可以很明显地看到了其中蕴含的线性关系

`Coppersmith’s Short-pad Attack & Related Message Attack（Franklin-Reiter攻击）`


从la佬的博客中据悉，所谓的padding过短，就是对应多项式的根会过小；提供了两个脚本, 本题目改脚本 1就可以了


```python
#脚本1
#Sage
import binascii
def attack(c1, c2, n, e):
    PR.<x>=PolynomialRing(Zmod(n))
    # replace a,b,c,d
    g1 = (a*x+b)^e - c1
    g2 = (c*x+d)^e - c2

    def gcd(g1, g2):
        while g2:
            g1, g2 = g2, g1 % g2
        return g1.monic()
    return -gcd(g1, g2)[0]
c1 =
c2 =
n =
e =
m1 = attack(c1, c2, n, e)
print(binascii.unhexlify("%x" % int(m1)))
```


```python
#脚本2
#Sage
def short_pad_attack(c1, c2, e, n):
    PRxy.<x,y> = PolynomialRing(Zmod(n))
    PRx.<xn> = PolynomialRing(Zmod(n))
    PRZZ.<xz,yz> = PolynomialRing(Zmod(n))
    g1 = x^e - c1
    g2 = (x+y)^e - c2
    q1 = g1.change_ring(PRZZ)
    q2 = g2.change_ring(PRZZ)
    h = q2.resultant(q1)
    h = h.univariate_polynomial()
    h = h.change_ring(PRx).subs(y=xn)
    h = h.monic()
    kbits = n.nbits()//(2*e*e)
    diff = h.small_roots(X=2^kbits, beta=0.4)[0]  # find root < 2^kbits with factor >= n^0.4
    return diff
def related_message_attack(c1, c2, diff, e, n):
    PRx.<x> = PolynomialRing(Zmod(n))
    g1 = x^e - c1
    g2 = (x+diff)^e - c2
    def gcd(g1, g2):
        while g2:
            g1, g2 = g2, g1 % g2
        return g1.monic()
    return -gcd(g1, g2)[0]
if __name__ == '__main__':
    n =
    e =
    c1 =
    c2 =
    diff = short_pad_attack(c1, c2, e, n)
    print("difference of two messages is %d" % diff)
    m1 = related_message_attack(c1, c2, diff, e, n)
    print("m1:", m1)
    print("m2:", m1 + diff)

```


## unusualrsa3 多项式rsa

```
# ********************
# @Author: Lazzaro
# ********************

p: 
2470567871

N: 
1932231392*x^255 + 1432733708*x^254 + 1270867914*x^253 + 1573324635*x^252 + 2378103997*x^251 + 820889786*x^250 + 762279735*x^249 + 1378353578*x^248 + 1226179520*x^247 + 657116276*x^246 + 1264717357*x^245 + 1015587392*x^244 + 849699356*x^243 + 1509168990*x^242 + 2407367106*x^241 + 873379233*x^240 + 2391647981*x^239 + 517715639*x^238 + 828941376*x^237 + 843708018*x^236 + 1526075137*x^235 + 1499291590*x^234 + 235611028*x^233 + 19615265*x^232 + 53338886*x^231 + 434434839*x^230 + 902171938*x^229 + 516444143*x^228 + 1984443642*x^227 + 966493372*x^226 + 1166227650*x^225 + 1824442929*x^224 + 930231465*x^223 + 1664522302*x^222 + 1067203343*x^221 + 28569139*x^220 + 2327926559*x^219 + 899788156*x^218 + 296985783*x^217 + 1144578716*x^216 + 340677494*x^215 + 254306901*x^214 + 766641243*x^213 + 1882320336*x^212 + 2139903463*x^211 + 1904225023*x^210 + 475412928*x^209 + 127723603*x^208 + 2015416361*x^207 + 1500078813*x^206 + 1845826007*x^205 + 797486240*x^204 + 85924125*x^203 + 1921772796*x^202 + 1322682658*x^201 + 2372929383*x^200 + 1323964787*x^199 + 1302258424*x^198 + 271875267*x^197 + 1297768962*x^196 + 2147341770*x^195 + 1665066191*x^194 + 2342921569*x^193 + 1450622685*x^192 + 1453466049*x^191 + 1105227173*x^190 + 2357717379*x^189 + 1044263540*x^188 + 697816284*x^187 + 647124526*x^186 + 1414769298*x^185 + 657373752*x^184 + 91863906*x^183 + 1095083181*x^182 + 658171402*x^181 + 75339882*x^180 + 2216678027*x^179 + 2208320155*x^178 + 1351845267*x^177 + 1740451894*x^176 + 1302531891*x^175 + 320751753*x^174 + 1303477598*x^173 + 783321123*x^172 + 1400145206*x^171 + 1379768234*x^170 + 1191445903*x^169 + 946530449*x^168 + 2008674144*x^167 + 2247371104*x^166 + 1267042416*x^165 + 1795774455*x^164 + 1976911493*x^163 + 167037165*x^162 + 1848717750*x^161 + 573072954*x^160 + 1126046031*x^159 + 376257986*x^158 + 1001726783*x^157 + 2250967824*x^156 + 2339380314*x^155 + 571922874*x^154 + 961000788*x^153 + 306686020*x^152 + 80717392*x^151 + 2454799241*x^150 + 1005427673*x^149 + 1032257735*x^148 + 593980163*x^147 + 1656568780*x^146 + 1865541316*x^145 + 2003844061*x^144 + 1265566902*x^143 + 573548790*x^142 + 494063408*x^141 + 1722266624*x^140 + 938551278*x^139 + 2284832499*x^138 + 597191613*x^137 + 476121126*x^136 + 1237943942*x^135 + 275861976*x^134 + 1603993606*x^133 + 1895285286*x^132 + 589034062*x^131 + 713986937*x^130 + 1206118526*x^129 + 311679750*x^128 + 1989860861*x^127 + 1551409650*x^126 + 2188452501*x^125 + 1175930901*x^124 + 1991529213*x^123 + 2019090583*x^122 + 215965300*x^121 + 532432639*x^120 + 1148806816*x^119 + 493362403*x^118 + 2166920790*x^117 + 185609624*x^116 + 184370704*x^115 + 2141702861*x^114 + 223551915*x^113 + 298497455*x^112 + 722376028*x^111 + 678813029*x^110 + 915121681*x^109 + 1107871854*x^108 + 1369194845*x^107 + 328165402*x^106 + 1792110161*x^105 + 798151427*x^104 + 954952187*x^103 + 471555401*x^102 + 68969853*x^101 + 453598910*x^100 + 2458706380*x^99 + 889221741*x^98 + 320515821*x^97 + 1549538476*x^96 + 909607400*x^95 + 499973742*x^94 + 552728308*x^93 + 1538610725*x^92 + 186272117*x^91 + 862153635*x^90 + 981463824*x^89 + 2400233482*x^88 + 1742475067*x^87 + 437801940*x^86 + 1504315277*x^85 + 1756497351*x^84 + 197089583*x^83 + 2082285292*x^82 + 109369793*x^81 + 2197572728*x^80 + 107235697*x^79 + 567322310*x^78 + 1755205142*x^77 + 1089091449*x^76 + 1993836978*x^75 + 2393709429*x^74 + 170647828*x^73 + 1205814501*x^72 + 2444570340*x^71 + 328372190*x^70 + 1929704306*x^69 + 717796715*x^68 + 1057597610*x^67 + 482243092*x^66 + 277530014*x^65 + 2393168828*x^64 + 12380707*x^63 + 1108646500*x^62 + 637721571*x^61 + 604983755*x^60 + 1142068056*x^59 + 1911643955*x^58 + 1713852330*x^57 + 1757273231*x^56 + 1778819295*x^55 + 957146826*x^54 + 900005615*x^53 + 521467961*x^52 + 1255707235*x^51 + 861871574*x^50 + 397953653*x^49 + 1259753202*x^48 + 471431762*x^47 + 1245956917*x^46 + 1688297180*x^45 + 1536178591*x^44 + 1833258462*x^43 + 1369087493*x^42 + 459426544*x^41 + 418389643*x^40 + 1800239647*x^39 + 2467433889*x^38 + 477713059*x^37 + 1898813986*x^36 + 2202042708*x^35 + 894088738*x^34 + 1204601190*x^33 + 1592921228*x^32 + 2234027582*x^31 + 1308900201*x^30 + 461430959*x^29 + 718926726*x^28 + 2081988029*x^27 + 1337342428*x^26 + 2039153142*x^25 + 1364177470*x^24 + 613659517*x^23 + 853968854*x^22 + 1013582418*x^21 + 1167857934*x^20 + 2014147362*x^19 + 1083466865*x^18 + 1091690302*x^17 + 302196939*x^16 + 1946675573*x^15 + 2450124113*x^14 + 1199066291*x^13 + 401889502*x^12 + 712045611*x^11 + 1850096904*x^10 + 1808400208*x^9 + 1567687877*x^8 + 2013445952*x^7 + 2435360770*x^6 + 2414019676*x^5 + 2277377050*x^4 + 2148341337*x^3 + 1073721716*x^2 + 1045363399*x + 1809685811

m^0x10001%N:  
922927962*x^254 + 1141958714*x^253 + 295409606*x^252 + 1197491798*x^251 + 2463440866*x^250 + 1671460946*x^249 + 967543123*x^248 + 119796323*x^247 + 1172760592*x^246 + 770640267*x^245 + 1093816376*x^244 + 196379610*x^243 + 2205270506*x^242 + 459693142*x^241 + 829093322*x^240 + 816440689*x^239 + 648546871*x^238 + 1533372161*x^237 + 1349964227*x^236 + 2132166634*x^235 + 403690250*x^234 + 835793319*x^233 + 2056945807*x^232 + 480459588*x^231 + 1401028924*x^230 + 2231055325*x^229 + 1716893325*x^228 + 16299164*x^227 + 1125072063*x^226 + 1903340994*x^225 + 1372971897*x^224 + 242927971*x^223 + 711296789*x^222 + 535407256*x^221 + 976773179*x^220 + 533569974*x^219 + 501041034*x^218 + 326232105*x^217 + 2248775507*x^216 + 1010397596*x^215 + 1641864795*x^214 + 1365178317*x^213 + 1038477612*x^212 + 2201213637*x^211 + 760847531*x^210 + 2072085932*x^209 + 168159257*x^208 + 70202009*x^207 + 1193933930*x^206 + 1559162272*x^205 + 1380642174*x^204 + 1296625644*x^203 + 1338288152*x^202 + 843839510*x^201 + 460174838*x^200 + 660412151*x^199 + 716865491*x^198 + 772161222*x^197 + 924177515*x^196 + 1372790342*x^195 + 320044037*x^194 + 117027412*x^193 + 814803809*x^192 + 1175035545*x^191 + 244769161*x^190 + 2116927976*x^189 + 617780431*x^188 + 342577832*x^187 + 356586691*x^186 + 695795444*x^185 + 281750528*x^184 + 133432552*x^183 + 741747447*x^182 + 2138036298*x^181 + 524386605*x^180 + 1231287380*x^179 + 1246706891*x^178 + 69277523*x^177 + 2124927225*x^176 + 2334697345*x^175 + 1769733543*x^174 + 2248037872*x^173 + 1899902290*x^172 + 409421149*x^171 + 1223261878*x^170 + 666594221*x^169 + 1795456341*x^168 + 406003299*x^167 + 992699270*x^166 + 2201384104*x^165 + 907692883*x^164 + 1667882231*x^163 + 1414341647*x^162 + 1592159752*x^161 + 28054099*x^160 + 2184618098*x^159 + 2047102725*x^158 + 103202495*x^157 + 1803852525*x^156 + 446464179*x^155 + 909116906*x^154 + 1541693644*x^153 + 166545130*x^152 + 2283548843*x^151 + 2348768005*x^150 + 71682607*x^149 + 484339546*x^148 + 669511666*x^147 + 2110974006*x^146 + 1634563992*x^145 + 1810433926*x^144 + 2388805064*x^143 + 1200258695*x^142 + 1555191384*x^141 + 363842947*x^140 + 1105757887*x^139 + 402111289*x^138 + 361094351*x^137 + 1788238752*x^136 + 2017677334*x^135 + 1506224550*x^134 + 648916609*x^133 + 2008973424*x^132 + 2452922307*x^131 + 1446527028*x^130 + 29659632*x^129 + 627390142*x^128 + 1695661760*x^127 + 734686497*x^126 + 227059690*x^125 + 1219692361*x^124 + 635166359*x^123 + 428703291*x^122 + 2334823064*x^121 + 204888978*x^120 + 1694957361*x^119 + 94211180*x^118 + 2207723563*x^117 + 872340606*x^116 + 46197669*x^115 + 710312088*x^114 + 305132032*x^113 + 1621042631*x^112 + 2023404084*x^111 + 2169254305*x^110 + 463525650*x^109 + 2349964255*x^108 + 626689949*x^107 + 2072533779*x^106 + 177264308*x^105 + 153948342*x^104 + 1992646054*x^103 + 2379817214*x^102 + 1396334187*x^101 + 2254165812*x^100 + 1300455472*x^99 + 2396842759*x^98 + 2398953180*x^97 + 88249450*x^96 + 1726340322*x^95 + 2004986735*x^94 + 2446249940*x^93 + 520126803*x^92 + 821544954*x^91 + 1177737015*x^90 + 676286546*x^89 + 1519043368*x^88 + 224894464*x^87 + 1742023262*x^86 + 142627164*x^85 + 1427710141*x^84 + 1504189919*x^83 + 688315682*x^82 + 1397842239*x^81 + 435187331*x^80 + 433176780*x^79 + 454834357*x^78 + 1046713282*x^77 + 1208458516*x^76 + 811240741*x^75 + 151611952*x^74 + 164192249*x^73 + 353336244*x^72 + 1779538914*x^71 + 1489144873*x^70 + 213140082*x^69 + 1874778522*x^68 + 908618863*x^67 + 1058334731*x^66 + 1706255211*x^65 + 708134837*x^64 + 1382118347*x^63 + 2111915733*x^62 + 1273497300*x^61 + 368639880*x^60 + 1652005004*x^59 + 1977610754*x^58 + 1412680185*x^57 + 2312775720*x^56 + 59793381*x^55 + 1345145822*x^54 + 627534850*x^53 + 2159477761*x^52 + 10450988*x^51 + 1479007796*x^50 + 2082579205*x^49 + 1158447154*x^48 + 126359830*x^47 + 393411272*x^46 + 2343384236*x^45 + 2191577465*x^44 + 1281188680*x^43 + 230049708*x^42 + 539600199*x^41 + 1711135601*x^40 + 1659775448*x^39 + 1716176055*x^38 + 904363231*x^37 + 2385749710*x^36 + 567278351*x^35 + 404199078*x^34 + 372670353*x^33 + 1286079784*x^32 + 1744355671*x^31 + 2316856064*x^30 + 2106475476*x^29 + 614988454*x^28 + 2149964943*x^27 + 1065233185*x^26 + 188130174*x^25 + 540415659*x^24 + 1031409799*x^23 + 1067085678*x^22 + 1005161755*x^21 + 249654085*x^20 + 1816791634*x^19 + 1437500292*x^18 + 448596413*x^17 + 2397497659*x^16 + 2353732701*x^15 + 2068949189*x^14 + 1826419168*x^13 + 1265366199*x^12 + 547031306*x^11 + 1016962374*x^10 + 160089486*x^9 + 2264803979*x^8 + 1081806194*x^7 + 824215340*x^6 + 497731793*x^5 + 45017166*x^4 + 317548920*x^3 + 1391127733*x^2 + 1752881284*x + 1290424106
```

```python
# 多项式rsa

def main():
    p = 2470567871
    R.<x> = PolynomialRing(GF(p))

    N = 1932231392 * x ^ 255 + 1432733708 * x ^ 254 + 1270867914 * x ^ 253 + 1573324635 * x ^ 252 + 2378103997 * x ^ 251 + 820889786 * x ^ 250 + 762279735 * x ^ 249 + 1378353578 * x ^ 248 + 1226179520 * x ^ 247 + 657116276 * x ^ 246 + 1264717357 * x ^ 245 + 1015587392 * x ^ 244 + 849699356 * x ^ 243 + 1509168990 * x ^ 242 + 2407367106 * x ^ 241 + 873379233 * x ^ 240 + 2391647981 * x ^ 239 + 517715639 * x ^ 238 + 828941376 * x ^ 237 + 843708018 * x ^ 236 + 1526075137 * x ^ 235 + 1499291590 * x ^ 234 + 235611028 * x ^ 233 + 19615265 * x ^ 232 + 53338886 * x ^ 231 + 434434839 * x ^ 230 + 902171938 * x ^ 229 + 516444143 * x ^ 228 + 1984443642 * x ^ 227 + 966493372 * x ^ 226 + 1166227650 * x ^ 225 + 1824442929 * x ^ 224 + 930231465 * x ^ 223 + 1664522302 * x ^ 222 + 1067203343 * x ^ 221 + 28569139 * x ^ 220 + 2327926559 * x ^ 219 + 899788156 * x ^ 218 + 296985783 * x ^ 217 + 1144578716 * x ^ 216 + 340677494 * x ^ 215 + 254306901 * x ^ 214 + 766641243 * x ^ 213 + 1882320336 * x ^ 212 + 2139903463 * x ^ 211 + 1904225023 * x ^ 210 + 475412928 * x ^ 209 + 127723603 * x ^ 208 + 2015416361 * x ^ 207 + 1500078813 * x ^ 206 + 1845826007 * x ^ 205 + 797486240 * x ^ 204 + 85924125 * x ^ 203 + 1921772796 * x ^ 202 + 1322682658 * x ^ 201 + 2372929383 * x ^ 200 + 1323964787 * x ^ 199 + 1302258424 * x ^ 198 + 271875267 * x ^ 197 + 1297768962 * x ^ 196 + 2147341770 * x ^ 195 + 1665066191 * x ^ 194 + 2342921569 * x ^ 193 + 1450622685 * x ^ 192 + 1453466049 * x ^ 191 + 1105227173 * x ^ 190 + 2357717379 * x ^ 189 + 1044263540 * x ^ 188 + 697816284 * x ^ 187 + 647124526 * x ^ 186 + 1414769298 * x ^ 185 + 657373752 * x ^ 184 + 91863906 * x ^ 183 + 1095083181 * x ^ 182 + 658171402 * x ^ 181 + 75339882 * x ^ 180 + 2216678027 * x ^ 179 + 2208320155 * x ^ 178 + 1351845267 * x ^ 177 + 1740451894 * x ^ 176 + 1302531891 * x ^ 175 + 320751753 * x ^ 174 + 1303477598 * x ^ 173 + 783321123 * x ^ 172 + 1400145206 * x ^ 171 + 1379768234 * x ^ 170 + 1191445903 * x ^ 169 + 946530449 * x ^ 168 + 2008674144 * x ^ 167 + 2247371104 * x ^ 166 + 1267042416 * x ^ 165 + 1795774455 * x ^ 164 + 1976911493 * x ^ 163 + 167037165 * x ^ 162 + 1848717750 * x ^ 161 + 573072954 * x ^ 160 + 1126046031 * x ^ 159 + 376257986 * x ^ 158 + 1001726783 * x ^ 157 + 2250967824 * x ^ 156 + 2339380314 * x ^ 155 + 571922874 * x ^ 154 + 961000788 * x ^ 153 + 306686020 * x ^ 152 + 80717392 * x ^ 151 + 2454799241 * x ^ 150 + 1005427673 * x ^ 149 + 1032257735 * x ^ 148 + 593980163 * x ^ 147 + 1656568780 * x ^ 146 + 1865541316 * x ^ 145 + 2003844061 * x ^ 144 + 1265566902 * x ^ 143 + 573548790 * x ^ 142 + 494063408 * x ^ 141 + 1722266624 * x ^ 140 + 938551278 * x ^ 139 + 2284832499 * x ^ 138 + 597191613 * x ^ 137 + 476121126 * x ^ 136 + 1237943942 * x ^ 135 + 275861976 * x ^ 134 + 1603993606 * x ^ 133 + 1895285286 * x ^ 132 + 589034062 * x ^ 131 + 713986937 * x ^ 130 + 1206118526 * x ^ 129 + 311679750 * x ^ 128 + 1989860861 * x ^ 127 + 1551409650 * x ^ 126 + 2188452501 * x ^ 125 + 1175930901 * x ^ 124 + 1991529213 * x ^ 123 + 2019090583 * x ^ 122 + 215965300 * x ^ 121 + 532432639 * x ^ 120 + 1148806816 * x ^ 119 + 493362403 * x ^ 118 + 2166920790 * x ^ 117 + 185609624 * x ^ 116 + 184370704 * x ^ 115 + 2141702861 * x ^ 114 + 223551915 * x ^ 113 + 298497455 * x ^ 112 + 722376028 * x ^ 111 + 678813029 * x ^ 110 + 915121681 * x ^ 109 + 1107871854 * x ^ 108 + 1369194845 * x ^ 107 + 328165402 * x ^ 106 + 1792110161 * x ^ 105 + 798151427 * x ^ 104 + 954952187 * x ^ 103 + 471555401 * x ^ 102 + 68969853 * x ^ 101 + 453598910 * x ^ 100 + 2458706380 * x ^ 99 + 889221741 * x ^ 98 + 320515821 * x ^ 97 + 1549538476 * x ^ 96 + 909607400 * x ^ 95 + 499973742 * x ^ 94 + 552728308 * x ^ 93 + 1538610725 * x ^ 92 + 186272117 * x ^ 91 + 862153635 * x ^ 90 + 981463824 * x ^ 89 + 2400233482 * x ^ 88 + 1742475067 * x ^ 87 + 437801940 * x ^ 86 + 1504315277 * x ^ 85 + 1756497351 * x ^ 84 + 197089583 * x ^ 83 + 2082285292 * x ^ 82 + 109369793 * x ^ 81 + 2197572728 * x ^ 80 + 107235697 * x ^ 79 + 567322310 * x ^ 78 + 1755205142 * x ^ 77 + 1089091449 * x ^ 76 + 1993836978 * x ^ 75 + 2393709429 * x ^ 74 + 170647828 * x ^ 73 + 1205814501 * x ^ 72 + 2444570340 * x ^ 71 + 328372190 * x ^ 70 + 1929704306 * x ^ 69 + 717796715 * x ^ 68 + 1057597610 * x ^ 67 + 482243092 * x ^ 66 + 277530014 * x ^ 65 + 2393168828 * x ^ 64 + 12380707 * x ^ 63 + 1108646500 * x ^ 62 + 637721571 * x ^ 61 + 604983755 * x ^ 60 + 1142068056 * x ^ 59 + 1911643955 * x ^ 58 + 1713852330 * x ^ 57 + 1757273231 * x ^ 56 + 1778819295 * x ^ 55 + 957146826 * x ^ 54 + 900005615 * x ^ 53 + 521467961 * x ^ 52 + 1255707235 * x ^ 51 + 861871574 * x ^ 50 + 397953653 * x ^ 49 + 1259753202 * x ^ 48 + 471431762 * x ^ 47 + 1245956917 * x ^ 46 + 1688297180 * x ^ 45 + 1536178591 * x ^ 44 + 1833258462 * x ^ 43 + 1369087493 * x ^ 42 + 459426544 * x ^ 41 + 418389643 * x ^ 40 + 1800239647 * x ^ 39 + 2467433889 * x ^ 38 + 477713059 * x ^ 37 + 1898813986 * x ^ 36 + 2202042708 * x ^ 35 + 894088738 * x ^ 34 + 1204601190 * x ^ 33 + 1592921228 * x ^ 32 + 2234027582 * x ^ 31 + 1308900201 * x ^ 30 + 461430959 * x ^ 29 + 718926726 * x ^ 28 + 2081988029 * x ^ 27 + 1337342428 * x ^ 26 + 2039153142 * x ^ 25 + 1364177470 * x ^ 24 + 613659517 * x ^ 23 + 853968854 * x ^ 22 + 1013582418 * x ^ 21 + 1167857934 * x ^ 20 + 2014147362 * x ^ 19 + 1083466865 * x ^ 18 + 1091690302 * x ^ 17 + 302196939 * x ^ 16 + 1946675573 * x ^ 15 + 2450124113 * x ^ 14 + 1199066291 * x ^ 13 + 401889502 * x ^ 12 + 712045611 * x ^ 11 + 1850096904 * x ^ 10 + 1808400208 * x ^ 9 + 1567687877 * x ^ 8 + 2013445952 * x ^ 7 + 2435360770 * x ^ 6 + 2414019676 * x ^ 5 + 2277377050 * x ^ 4 + 2148341337 * x ^ 3 + 1073721716 * x ^ 2 + 1045363399 * x + 1809685811

    S.<x> = R.quotient(N)  # 创建商环
    c = 922927962 * x ^ 254 + 1141958714 * x ^ 253 + 295409606 * x ^ 252 + 1197491798 * x ^ 251 + 2463440866 * x ^ 250 + 1671460946 * x ^ 249 + 967543123 * x ^ 248 + 119796323 * x ^ 247 + 1172760592 * x ^ 246 + 770640267 * x ^ 245 + 1093816376 * x ^ 244 + 196379610 * x ^ 243 + 2205270506 * x ^ 242 + 459693142 * x ^ 241 + 829093322 * x ^ 240 + 816440689 * x ^ 239 + 648546871 * x ^ 238 + 1533372161 * x ^ 237 + 1349964227 * x ^ 236 + 2132166634 * x ^ 235 + 403690250 * x ^ 234 + 835793319 * x ^ 233 + 2056945807 * x ^ 232 + 480459588 * x ^ 231 + 1401028924 * x ^ 230 + 2231055325 * x ^ 229 + 1716893325 * x ^ 228 + 16299164 * x ^ 227 + 1125072063 * x ^ 226 + 1903340994 * x ^ 225 + 1372971897 * x ^ 224 + 242927971 * x ^ 223 + 711296789 * x ^ 222 + 535407256 * x ^ 221 + 976773179 * x ^ 220 + 533569974 * x ^ 219 + 501041034 * x ^ 218 + 326232105 * x ^ 217 + 2248775507 * x ^ 216 + 1010397596 * x ^ 215 + 1641864795 * x ^ 214 + 1365178317 * x ^ 213 + 1038477612 * x ^ 212 + 2201213637 * x ^ 211 + 760847531 * x ^ 210 + 2072085932 * x ^ 209 + 168159257 * x ^ 208 + 70202009 * x ^ 207 + 1193933930 * x ^ 206 + 1559162272 * x ^ 205 + 1380642174 * x ^ 204 + 1296625644 * x ^ 203 + 1338288152 * x ^ 202 + 843839510 * x ^ 201 + 460174838 * x ^ 200 + 660412151 * x ^ 199 + 716865491 * x ^ 198 + 772161222 * x ^ 197 + 924177515 * x ^ 196 + 1372790342 * x ^ 195 + 320044037 * x ^ 194 + 117027412 * x ^ 193 + 814803809 * x ^ 192 + 1175035545 * x ^ 191 + 244769161 * x ^ 190 + 2116927976 * x ^ 189 + 617780431 * x ^ 188 + 342577832 * x ^ 187 + 356586691 * x ^ 186 + 695795444 * x ^ 185 + 281750528 * x ^ 184 + 133432552 * x ^ 183 + 741747447 * x ^ 182 + 2138036298 * x ^ 181 + 524386605 * x ^ 180 + 1231287380 * x ^ 179 + 1246706891 * x ^ 178 + 69277523 * x ^ 177 + 2124927225 * x ^ 176 + 2334697345 * x ^ 175 + 1769733543 * x ^ 174 + 2248037872 * x ^ 173 + 1899902290 * x ^ 172 + 409421149 * x ^ 171 + 1223261878 * x ^ 170 + 666594221 * x ^ 169 + 1795456341 * x ^ 168 + 406003299 * x ^ 167 + 992699270 * x ^ 166 + 2201384104 * x ^ 165 + 907692883 * x ^ 164 + 1667882231 * x ^ 163 + 1414341647 * x ^ 162 + 1592159752 * x ^ 161 + 28054099 * x ^ 160 + 2184618098 * x ^ 159 + 2047102725 * x ^ 158 + 103202495 * x ^ 157 + 1803852525 * x ^ 156 + 446464179 * x ^ 155 + 909116906 * x ^ 154 + 1541693644 * x ^ 153 + 166545130 * x ^ 152 + 2283548843 * x ^ 151 + 2348768005 * x ^ 150 + 71682607 * x ^ 149 + 484339546 * x ^ 148 + 669511666 * x ^ 147 + 2110974006 * x ^ 146 + 1634563992 * x ^ 145 + 1810433926 * x ^ 144 + 2388805064 * x ^ 143 + 1200258695 * x ^ 142 + 1555191384 * x ^ 141 + 363842947 * x ^ 140 + 1105757887 * x ^ 139 + 402111289 * x ^ 138 + 361094351 * x ^ 137 + 1788238752 * x ^ 136 + 2017677334 * x ^ 135 + 1506224550 * x ^ 134 + 648916609 * x ^ 133 + 2008973424 * x ^ 132 + 2452922307 * x ^ 131 + 1446527028 * x ^ 130 + 29659632 * x ^ 129 + 627390142 * x ^ 128 + 1695661760 * x ^ 127 + 734686497 * x ^ 126 + 227059690 * x ^ 125 + 1219692361 * x ^ 124 + 635166359 * x ^ 123 + 428703291 * x ^ 122 + 2334823064 * x ^ 121 + 204888978 * x ^ 120 + 1694957361 * x ^ 119 + 94211180 * x ^ 118 + 2207723563 * x ^ 117 + 872340606 * x ^ 116 + 46197669 * x ^ 115 + 710312088 * x ^ 114 + 305132032 * x ^ 113 + 1621042631 * x ^ 112 + 2023404084 * x ^ 111 + 2169254305 * x ^ 110 + 463525650 * x ^ 109 + 2349964255 * x ^ 108 + 626689949 * x ^ 107 + 2072533779 * x ^ 106 + 177264308 * x ^ 105 + 153948342 * x ^ 104 + 1992646054 * x ^ 103 + 2379817214 * x ^ 102 + 1396334187 * x ^ 101 + 2254165812 * x ^ 100 + 1300455472 * x ^ 99 + 2396842759 * x ^ 98 + 2398953180 * x ^ 97 + 88249450 * x ^ 96 + 1726340322 * x ^ 95 + 2004986735 * x ^ 94 + 2446249940 * x ^ 93 + 520126803 * x ^ 92 + 821544954 * x ^ 91 + 1177737015 * x ^ 90 + 676286546 * x ^ 89 + 1519043368 * x ^ 88 + 224894464 * x ^ 87 + 1742023262 * x ^ 86 + 142627164 * x ^ 85 + 1427710141 * x ^ 84 + 1504189919 * x ^ 83 + 688315682 * x ^ 82 + 1397842239 * x ^ 81 + 435187331 * x ^ 80 + 433176780 * x ^ 79 + 454834357 * x ^ 78 + 1046713282 * x ^ 77 + 1208458516 * x ^ 76 + 811240741 * x ^ 75 + 151611952 * x ^ 74 + 164192249 * x ^ 73 + 353336244 * x ^ 72 + 1779538914 * x ^ 71 + 1489144873 * x ^ 70 + 213140082 * x ^ 69 + 1874778522 * x ^ 68 + 908618863 * x ^ 67 + 1058334731 * x ^ 66 + 1706255211 * x ^ 65 + 708134837 * x ^ 64 + 1382118347 * x ^ 63 + 2111915733 * x ^ 62 + 1273497300 * x ^ 61 + 368639880 * x ^ 60 + 1652005004 * x ^ 59 + 1977610754 * x ^ 58 + 1412680185 * x ^ 57 + 2312775720 * x ^ 56 + 59793381 * x ^ 55 + 1345145822 * x ^ 54 + 627534850 * x ^ 53 + 2159477761 * x ^ 52 + 10450988 * x ^ 51 + 1479007796 * x ^ 50 + 2082579205 * x ^ 49 + 1158447154 * x ^ 48 + 126359830 * x ^ 47 + 393411272 * x ^ 46 + 2343384236 * x ^ 45 + 2191577465 * x ^ 44 + 1281188680 * x ^ 43 + 230049708 * x ^ 42 + 539600199 * x ^ 41 + 1711135601 * x ^ 40 + 1659775448 * x ^ 39 + 1716176055 * x ^ 38 + 904363231 * x ^ 37 + 2385749710 * x ^ 36 + 567278351 * x ^ 35 + 404199078 * x ^ 34 + 372670353 * x ^ 33 + 1286079784 * x ^ 32 + 1744355671 * x ^ 31 + 2316856064 * x ^ 30 + 2106475476 * x ^ 29 + 614988454 * x ^ 28 + 2149964943 * x ^ 27 + 1065233185 * x ^ 26 + 188130174 * x ^ 25 + 540415659 * x ^ 24 + 1031409799 * x ^ 23 + 1067085678 * x ^ 22 + 1005161755 * x ^ 21 + 249654085 * x ^ 20 + 1816791634 * x ^ 19 + 1437500292 * x ^ 18 + 448596413 * x ^ 17 + 2397497659 * x ^ 16 + 2353732701 * x ^ 15 + 2068949189 * x ^ 14 + 1826419168 * x ^ 13 + 1265366199 * x ^ 12 + 547031306 * x ^ 11 + 1016962374 * x ^ 10 + 160089486 * x ^ 9 + 2264803979 * x ^ 8 + 1081806194 * x ^ 7 + 824215340 * x ^ 6 + 497731793 * x ^ 5 + 45017166 * x ^ 4 + 317548920 * x ^ 3 + 1391127733 * x ^ 2 + 1752881284 * x + 1290424106

    P, Q = N.factor()
    P, Q = P[0], Q[0]
    phi = (p ** P.degree() - 1) * (p ** Q.degree() - 1)
    e = 0x10001
    d = inverse_mod(e, phi)

    m = c ^ d
    m = "".join([chr(c) for c in m.list()])
    print(m)


if __name__ == '__main__':
    main()
```

通用脚本 
```python
#脚本1
#Sage
#已知p,n,m^e
p=
P = PolynomialRing(Zmod(p), name = 'x')
x = P.gen()
e =
n =
c =

#分解N
q1, q2 = n.factor()
q1, q2 = q1[0], q2[0]

#求φ，注意求法，
phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)
assert gcd(e, phi) == 1
d = inverse_mod(e, phi)
m = pow(c,d,n)

#取多项式系数
flag = bytes(m.coefficients())
print("Flag: ", flag.decode())

```

## 强网杯2019 Copperstudy
https://www.codercto.com/a/82462.html
https://www.codenong.com/cs109409929/

### challenge3: coppersmith-3 Partial Key Exposure Attack(部分私钥暴露攻击), 低位512位 丢失, 若e较小，已知d的低位
题目
```
# Generating challenge 3
# n=150321028009130354952936883857309681894020847531159158502081071950139005893940720192222818223452509366952043731427473227177298005733169730122951841607588203293656438506606875166581980245663904626174003873285039031850291768606190148930641858353416095367648614194945504473877174372009804724981157816517146365503
# e=3
# m=random.getrandbits(512)
# c=pow(m,e,n)=279116358436840580147135264977269766918703572686163424333902485009842298728906610039634071468953660540129011632204235110720391834202748072777997984798198718031840510910536129574068550796083534754156176522863159732508426650006577887519609959487704645860163220182377162399205490957919178853
# d&((1<<512)-1)=614458137343821046117789393597908978602987399007340945087371499068308794994045115902422050299164025988168436422387962281884609333002957006597112797673211
# long_to_bytes(m).encode('hex')=
```

```python
def partial_p(p0, kbits, n):
    PR.<x> = PolynomialRing(Zmod(n))
    nbits = n.nbits()

    f = 2^kbits*x + p0
    f = f.monic()
    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3
    if roots:
        x0 = roots[0]
        p = gcd(2^kbits*x0 + p0, n)
        return ZZ(p)

def find_p(d0, kbits, e, n):
    X = var('X')

    for k in range(1, e+1):
        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)
        for x in results:
            p0 = ZZ(x[0])
            p = partial_p(p0, kbits, n)
            if p:
                return p


if __name__ == '__main__':
    n = 92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183
    e = 3
    d = 787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955

    nbits = n.nbits()
    kbits = d.nbits()

    print ("lower %d bits (of %d bits) is given" % (kbits, nbits))

    p = find_p(d, kbits, e, n)
    q = n//p
    print ("d0 = %d" % d)
    print ("d = %d" % inverse_mod(e, (p-1)*(q-1)))
    # d = 61931015986410954522379841763963945834108214123439860201390512063842165571430799255094107119082046571341221952786658415661511901536119262974324197242727901361853519060099176095718398341546521709753140715090423775413590463159715914497625346364363050316931779727154988269576808476796380941227956316802411370267
```

```python
import gmpy2
c=56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530
n = 92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183
d = 61931015986410954522379841763963945834108214123439860201390512063842165571430799255094107119082046571341221952786658415661511901536119262974324197242727901361853519060099176095718398341546521709753140715090423775413590463159715914497625346364363050316931779727154988269576808476796380941227956316802411370267
m = pow(c,d,n)
print(long_to_bytes(m))
# b'FLAG{2^8rsa5ab086745f6ec745619a8b65fe4ec560}'
# 0x464c41477b325e3872736135616230383637343566366563373435363139613862363566653465633536307d
```

challenge4 crt, 中国剩余定理

### challenge 5  Franklin-Reiter attack, 同n同e, m和m+r
```
[+]Generating challenge 5
[+]n=0x3298d508dc5255e5f53c2890326aceacf9439b9f2f06e2abf3e19ece5a503315852cbaf9ab9f730f9bde1082331f0697491dade2c57463d610b540697506ce3441ced4262ca150b1c28535f266e954967895f6d4b3fc86281cdfaa21fa8aa1b440de1bb0b0b4332969f24bff01d574f94235de3bc3da43401915adf253589b63L
[+]e=3
[+]m=random.getrandbits(512)
[+]c=pow(m,e,n)=0x1b124c087004fd532a26f2cb6cc5c9ee2176c2070d87c159bd0e74b8811ab3af84c96e05dd7bf6bb6b5a251c8558c357036aff678525c8734570e142e38e77419993892a29d9a9f54bd3d4c048895482466d749eb0cf5b12b427c1753f6ebe3eba2ad9dcdc87b7c2040bfab6a5c124eb21b821fa58e167d8cb57e9c551ab9dbfL
[+]x=pow(m+1,e,n)=0x2d6fcf825d2fcb98f37f951fc000520f4aab11222f92a1af01e0988943fdde016664b706f4197bd085e79f57daedbecf4ee59cc9f010998c22f1c2df6223df57e86b9efd8bcca779f16e6da8a54778459b4d956a255d8ecc3d3a9e9a72a7c70cb2bec8bbaa2bb5c2f2d3f95769cee6fdd7fd04bbd6d84070e50739b5b059c6e6L
[-]long_to_bytes(m).encode('hex')=
```


```python
# https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/FranklinReiter.sage
# Franklin-Reiter attack against RSA.
# If two messages differ only by a known fixed difference between the two messages
# and are RSA encrypted under the same RSA modulus N
# then it is possible to recover both of them.

# Inputs are modulus, known difference, ciphertext 1, ciphertext2.
# Ciphertext 1 corresponds to smaller of the two plaintexts. (The one without the fixed difference added to it)
from Crypto.Util.number import long_to_bytes


def franklinReiter(n, e, r, c1, c2):
    R.<X> = Zmod(n)[]
    f1 = X ^ e - c1
    f2 = (X + r) ^ e - c2
    # coefficient 0 = -m, which is what we wanted!
    return Integer(n - (compositeModulusGCD(f1, f2)).coefficients()[0])

def compositeModulusGCD(a, b):
    if (b == 0):
        return a.monic()
    else:
        return compositeModulusGCD(b, a % b)

def testFranklinReiter():
    r = 1
    n = 113604829563460357756722229849309932731534576966155520277171862442445354404910882358287832757024693652075211204635679309777620586814014894544893424988818766425089667672311645586528776360047956843961901352792631908859388801090108188344342619580661377758180391734771694803991493164412644148805229529911069578061
    e = 3
    c1 = 112992730284209629010217336632593897028023711212853788739137950706145189880318698604512926758021533447981943498594790549326550460216939216988828130624120379925895123186121819609415184887470233938291227816332249857236198616538782622327476603338806349004620909717360739157545735826670038169284252348037995399308
    c2 = 112992730284209629010217336632593897028023711212853788739137950706145189880318698604512926758021552486915464025361447529153776277710423467951041523831865232164370127602772602643378592695459331174613894578701940837730590029577336924367384969935652616989527416027725713616493815764725131271563545176286794438175

    recoveredM = franklinReiter(n, e, r, c1, c2)
    print(long_to_bytes(recoveredM).hex())
    print(long_to_bytes(recoveredM))
```

### challenge 6 boneh_durfee d<N^0.270
题目一上来就点明d<N^0.270,基本就可以考虑boneh_durfee的方法

```
Generating challenge 6
n=0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27L
d=random.getrandbits(1024*0.270)
e=invmod(d,phin)
hex(e)=0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bbL
m=random.getrandbits(512)
c=pow(m,e,n)=0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866cL
long_to_bytes(m).encode('hex')=
```

填入n,e,c替换脚本。
```python
from __future__ import print_function
import time

############################################
# Config
##########################################
from Crypto.Util.number import long_to_bytes

"""
Setting debug to true will display more informations
about the lattice, the bounds, the vectors...
"""
debug = True

"""
Setting strict to true will stop the algorithm (and
return (-1, -1)) if we don't have a correct
upperbound on the determinant. Note that this
doesn't necesseraly mean that no solutions
will be found since the theoretical upperbound is
usualy far away from actual results. That is why
you should probably use `strict = False`
"""
strict = False

"""
This is experimental, but has provided remarkable results
so far. It tries to reduce the lattice as much as it can
while keeping its efficiency. I see no reason not to use
this option, but if things don't work, you should try
disabling it
"""
helpful_only = True
dimension_min = 7 # stop removing if lattice reaches that dimension

############################################
# Functions
##########################################

# display stats on helpful vectors
def helpful_vectors(BB, modulus):
    nothelpful = 0
    for ii in range(BB.dimensions()[0]):
        if BB[ii,ii] >= modulus:
            nothelpful += 1

    print(nothelpful, "/", BB.dimensions()[0], " vectors are not helpful")

# display matrix picture with 0 and X
def matrix_overview(BB, bound):
    for ii in range(BB.dimensions()[0]):
        a = ('%02d ' % ii)
        for jj in range(BB.dimensions()[1]):
            a += '0' if BB[ii,jj] == 0 else 'X'
            if BB.dimensions()[0] < 60:
                a += ' '
        if BB[ii, ii] >= bound:
            a += '~'
        print(a)

# tries to remove unhelpful vectors
# we start at current = n-1 (last vector)
def remove_unhelpful(BB, monomials, bound, current):
    # end of our recursive function
    if current == -1 or BB.dimensions()[0] <= dimension_min:
        return BB

    # we start by checking from the end
    for ii in range(current, -1, -1):
        # if it is unhelpful:
        if BB[ii, ii] >= bound:
            affected_vectors = 0
            affected_vector_index = 0
            # let's check if it affects other vectors
            for jj in range(ii + 1, BB.dimensions()[0]):
                # if another vector is affected:
                # we increase the count
                if BB[jj, ii] != 0:
                    affected_vectors += 1
                    affected_vector_index = jj

            # level:0
            # if no other vectors end up affected
            # we remove it
            if affected_vectors == 0:
                print("* removing unhelpful vector", ii)
                BB = BB.delete_columns([ii])
                BB = BB.delete_rows([ii])
                monomials.pop(ii)
                BB = remove_unhelpful(BB, monomials, bound, ii-1)
                return BB

            # level:1
            # if just one was affected we check
            # if it is affecting someone else
            elif affected_vectors == 1:
                affected_deeper = True
                for kk in range(affected_vector_index + 1, BB.dimensions()[0]):
                    # if it is affecting even one vector
                    # we give up on this one
                    if BB[kk, affected_vector_index] != 0:
                        affected_deeper = False
                # remove both it if no other vector was affected and
                # this helpful vector is not helpful enough
                # compared to our unhelpful one
                if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) < abs(bound - BB[ii, ii]):
                    print("* removing unhelpful vectors", ii, "and", affected_vector_index)
                    BB = BB.delete_columns([affected_vector_index, ii])
                    BB = BB.delete_rows([affected_vector_index, ii])
                    monomials.pop(affected_vector_index)
                    monomials.pop(ii)
                    BB = remove_unhelpful(BB, monomials, bound, ii-1)
                    return BB
    # nothing happened
    return BB

""" 
Returns:
* 0,0   if it fails
* -1,-1 if `strict=true`, and determinant doesn't bound
* x0,y0 the solutions of `pol`
"""
def boneh_durfee(pol, modulus, mm, tt, XX, YY):
    """
    Boneh and Durfee revisited by Herrmann and May
    
    finds a solution if:
    * d < N^delta
    * |x| < e^delta
    * |y| < e^0.5
    whenever delta < 1 - sqrt(2)/2 ~ 0.292
    """

    # substitution (Herrman and May)
    PR.<u, x, y> = PolynomialRing(ZZ)
    Q = PR.quotient(x*y + 1 - u) # u = xy + 1
    polZ = Q(pol).lift()

    UU = XX*YY + 1

    # x-shifts
    gg = []
    for kk in range(mm + 1):
        for ii in range(mm - kk + 1):
            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk
            gg.append(xshift)
    gg.sort()

    # x-shifts list of monomials
    monomials = []
    for polynomial in gg:
        for monomial in polynomial.monomials():
            if monomial not in monomials:
                monomials.append(monomial)
    monomials.sort()
    
    # y-shifts (selected by Herrman and May)
    for jj in range(1, tt + 1):
        for kk in range(floor(mm/tt) * jj, mm + 1):
            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)
            yshift = Q(yshift).lift()
            gg.append(yshift) # substitution
    
    # y-shifts list of monomials
    for jj in range(1, tt + 1):
        for kk in range(floor(mm/tt) * jj, mm + 1):
            monomials.append(u^kk * y^jj)

    # construct lattice B
    nn = len(monomials)
    BB = Matrix(ZZ, nn)
    for ii in range(nn):
        BB[ii, 0] = gg[ii](0, 0, 0)
        for jj in range(1, ii + 1):
            if monomials[jj] in gg[ii].monomials():
                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)

    # Prototype to reduce the lattice
    if helpful_only:
        # automatically remove
        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1)
        # reset dimension
        nn = BB.dimensions()[0]
        if nn == 0:
            print("failure")
            return 0,0

    # check if vectors are helpful
    if debug:
        helpful_vectors(BB, modulus^mm)
    
    # check if determinant is correctly bounded
    det = BB.det()
    bound = modulus^(mm*nn)
    if det >= bound:
        print("We do not have det < bound. Solutions might not be found.")
        print("Try with highers m and t.")
        if debug:
            diff = (log(det) - log(bound)) / log(2)
            print("size det(L) - size e^(m*n) = ", floor(diff))
        if strict:
            return -1, -1
    else:
        print("det(L) < e^(m*n) (good! If a solution exists < N^delta, it will be found)")

    # display the lattice basis
    if debug:
        matrix_overview(BB, modulus^mm)

    # LLL
    if debug:
        print("optimizing basis of the lattice via LLL, this can take a long time")

    BB = BB.LLL()

    if debug:
        print("LLL is done!")

    # transform vector i & j -> polynomials 1 & 2
    if debug:
        print("looking for independent vectors in the lattice")
    found_polynomials = False
    
    for pol1_idx in range(nn - 1):
        for pol2_idx in range(pol1_idx + 1, nn):
            # for i and j, create the two polynomials
            PR.<w,z> = PolynomialRing(ZZ)
            pol1 = pol2 = 0
            for jj in range(nn):
                pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)
                pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)

            # resultant
            PR.<q> = PolynomialRing(ZZ)
            rr = pol1.resultant(pol2)

            # are these good polynomials?
            if rr.is_zero() or rr.monomials() == [1]:
                continue
            else:
                print("found them, using vectors", pol1_idx, "and", pol2_idx)
                found_polynomials = True
                break
        if found_polynomials:
            break

    if not found_polynomials:
        print("no independant vectors could be found. This should very rarely happen...")
        return 0, 0
    
    rr = rr(q, q)

    # solutions
    soly = rr.roots()

    if len(soly) == 0:
        print("Your prediction (delta) is too small")
        return 0, 0

    soly = soly[0][0]
    ss = pol1(q, soly)
    solx = ss.roots()[0][0]

    #
    return solx, soly

def example():
    ############################################
    # How To Use This Script
    ##########################################

    #
    # The problem to solve (edit the following values)
    #

    # the modulus
    N = 0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27
    # the public exponent
    e = 0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb
    c = 0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866c

    # the hypothesis on the private exponent (the theoretical maximum is 0.292)
    delta = .18 # this means that d < N^delta

    #
    # Lattice (tweak those values)
    #

    # you should tweak this (after a first run), (e.g. increment it until a solution is found)
    m = 4 # size of the lattice (bigger the better/slower)

    # you need to be a lattice master to tweak these
    t = int((1-2*delta) * m)  # optimization from Herrmann and May
    X = 2*floor(N^delta)  # this _might_ be too much
    Y = floor(N^(1/2))    # correct if p, q are ~ same size

    #
    # Don't touch anything below
    #

    # Problem put in equation
    P.<x,y> = PolynomialRing(ZZ)
    A = int((N+1)/2)
    pol = 1 + x * (A + y)

    #
    # Find the solutions!
    #

    # Checking bounds
    if debug:
        print("=== checking values ===")
        print("* delta:", delta)
        print("* delta < 0.292", delta < 0.292)
        print("* size of e:", int(log(e)/log(2)))
        print("* size of N:", int(log(N)/log(2)))
        print("* m:", m, ", t:", t)

    # boneh_durfee
    if debug:
        print("=== running algorithm ===")
        start_time = time.time()

    solx, soly = boneh_durfee(pol, e, m, t, X, Y)

    # found a solution?
    if solx > 0:
        print("=== solution found ===")
        if False:
            print("x:", solx)
            print("y:", soly)

        d = int(pol(solx, soly) / e)
        m = pow(c,d,N)
        print("private key found:", d)
        print('m is {:x}'.format(int(m)))
    else:
        print("=== no solution was found ===")

    if debug:
        print(("=== %s seconds ===" % (time.time() - start_time)))

if __name__ == "__main__":
    example()
```

## 离散对数[网鼎杯2020青龙组] you_raise_me_up

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from Crypto.Util.number import *
import random

n = 2 ** 512
m = random.randint(2, n-1) | 1
c = pow(m, bytes_to_long(flag), n)
print 'm = ' + str(m)
print 'c = ' + str(c)

# m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075
# c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499
```


```python
m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075
c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499
n = 2 ** 512
import sympy
flag=sympy.discrete_log(2**512,c,m)
import binascii
print(binascii.unhexlify(hex(flag)[2:]))
```

## 公约数题目 pqan,

```py
from gmpy2 import *
from Crypto.Util.number import *
from random import *
from secret import FLAG

bit=512
e=0x20002

hint=b'this is a hint'

def generate_parameter(hint,bit):
    p=getPrime(bit)
    q=getPrime(bit)
    a=getPrime(bit//8)
    N=p*q

    hint=pow(bytes_to_long(hint)+p*a,e,N)

    return hint,(p,q),(e,N)

def encrypt(msg,e,N):
    m=bytes_to_long(msg)

    return pow(m,e,N)

hint,private,public=generate_parameter(hint,bit)
print('hint:{}'.format(hint))
print('pubkey:{}'.format(public))
e,N=public
cipher=encrypt(FLAG,e,N)
print('cipher:{}'.format(cipher))

'''
hint:45571139214141730047842791232148479063161011380263366307082261897241293754468190742262926590325037998936547638541208924014798017124269134490805269268121747506133106836112947459372250939829334495878823821908890205538040419100075496594971486207917786401334058384974643627675179430965516821678169014208396862167
pubkey:(131074, 76073534138146965344349653988298353479586059258925858277238150171088443223584570663917989254106316356538951906924170643320482534213606722628965685582510500298369135396509651713696133607193898331347990302331091657261473528947359967163492485174611747364218463326326080803417640500875853338941721447312213301213)
cipher:31799269072952343192607814802245561453460715337675698876712084732642152553695567934352678728448995696460526274691137850398854884717533943820495054083632376867272265745372527746214758784104409170197778211466306887730837380012085272858283405750004431265326753335124974182067808339319127783568260695952860308749
作者：风二西 https://www.bilibili.com/read/cv13702478?spm_id_from=333.999.0.0 出处：bilibili
'''
```

解题思路

$$
h_c=(h+p*a)^e mod \ n\\
h_c=(h+p*a)^e + kn \ \\ 
h_c+kn = (h+p*a)^e \\
h_c+kn = h^e+k_1p \\
k_1p=kn+h_c-h^e \\
两边同时模n \\

k_1p=(h^e-h_c)\%n \\
k_1p=h^e\%n-h_c\%n \\
p = gcd((h^e-hc)\%n,n) \\
$$

求出p以后，
后面还有个e和phi不互素的知识点


```python
解题脚本

import libnum
import gmpy2
from Crypto.Util.number import *
h=b'this is a hint'
h=libnum.s2n(h)
hc=45571139214141730047842791232148479063161011380263366307082261897241293754468190742262926590325037998936547638541208924014798017124269134490805269268121747506133106836112947459372250939829334495878823821908890205538040419100075496594971486207917786401334058384974643627675179430965516821678169014208396862167
e=131074
n=76073534138146965344349653988298353479586059258925858277238150171088443223584570663917989254106316356538951906924170643320482534213606722628965685582510500298369135396509651713696133607193898331347990302331091657261473528947359967163492485174611747364218463326326080803417640500875853338941721447312213301213
c=31799269072952343192607814802245561453460715337675698876712084732642152553695567934352678728448995696460526274691137850398854884717533943820495054083632376867272265745372527746214758784104409170197778211466306887730837380012085272858283405750004431265326753335124974182067808339319127783568260695952860308749

p=gmpy2.gcd((pow(h,e,n)-pow(hc,1,n)),n)
print(p)
q=n//p
print(n==p*q)

# 当e约去公约数后与phi互素
def decrypt(p, q, e, c):
    n = p * q
    phi = (p - 1) * (q - 1)
    t = gmpy2.gcd(e, phi)
    d = gmpy2.invert(e // t, phi)
    m = pow(c, d, n)
    print(m)
    msg = gmpy2.iroot(m, t)
    print(msg)
    if msg[1]:
        print(long_to_bytes(msg[0]))
decrypt(p, q, e, c)
```

## let's play with rsa, 已知 n,n2,c1,e未知n1

要求m = number 则出flag
$$
\begin{multline}
\shoveleft
\begin{aligned}

& number = n_1*n_2 \\
& m = pow(c,d,n) \\
& 已知 c_1, n_2, 求 m = number  \\
&  \\
& c = m^e \% n \\
\\ 
& c = num^e \% n \\
& c = (n_1*n_2)^e \% n   & \# number = n_1 * n_2\\
& c = (n_1^e*n_2^e) \% n\\
\\ 
& c = (n_1^e\%n*n_2^e\%n) \% n\\
& n_1 ^ e \% n = c_1 \\
& c = (c1*n_2^e \% n) \% n\\
\end{aligned}
\end{multline}
$$

## RSA_enc
https://www.bilibili.com/video/BV19v411N7JP
https://blog.csdn.net/lewyu521/article/details/120035169

题目
```python
import os
from Crypto.Util import number

with open('./secret/flag', 'rb')as f:
    flag = f.read()

assert (len(flag) < 200)
p = number.getPrime(1024)
q = number.getPrime(1024)
n = p * q
e = 65537

data = number.bytes_to_long(flag[:4])
flag = number.bytes_to_long(os.urandom(255 - len(flag)) + flag)

with open('output. txt', 'w') as f:
    print(n, file=f)
    print(pow(flag, e, n), file=f)
    print(pow(data, p, n), file=f)

```

推导
$$
\begin{multline}
\shoveleft
\begin{aligned}
& c = data^p \% n \\
& c = data^p + kn \\
& 同时模p \\
& c \% p = data^p \% p + kn \% p \\
& c \% p = data^p \% p + kpq \% p \\
& c \% p = data^p \% p \\
& 费马小定理 a^p \% p = a \% p \\
& c \% p = data \% p \\
 \\
& kp = c - data \\
& pq = n \\
& p = gcd(c - data, n) \\
\end{aligned}
\end{multline}
$$

这个题目需要爆一下前4位。
```python
import string, libnum
import gmpy2

a = string.ascii_uppercase
for i1 in a:
    for i2 in a:
        for i3 in a:
            for i4 in a:
                m2 = i1 + i2 + i3 + i4
                m1 = libnum.s2n(m1)
                p = gmpy2.gcd(c1 - m1, n)
                if p != 1:
                    print(p)
                    print(m2)
# JDSE
```