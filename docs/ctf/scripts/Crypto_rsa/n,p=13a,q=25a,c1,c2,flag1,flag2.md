# 题目

```python
import sympy
from Crypto.Util.number import *
from flag import flag

a = getPrime(512)
p = sympy.nextprime(13 * a)
q = sympy.prevprime(25 * a)
n = p * q


# number4 = crypto01(flag1, number1, n)


def crypto01(flag1, number1, n):
    tmp = 1
    while number1 > 0:
        if number1 % 2:
            tmp = (tmp * flag1) % n
        flag1 = flag1 ** 2 % n
        number1 //= 2
    return tmp


def crypto02(number1, number2):
    a = number1
    b = number2
    giao = 1
    giaogiao = 0
    while b > 0:
        ss = a // b
        giao, giaogiao = giaogiao, giao - giaogiao * ss
        a, b = b, a - b * ss
    while giao < 0:
        giao = giao + number2
    return giao


number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683
number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
n = number2

flag1 = int.from_bytes(flag[0:19].encode("utf-8"), "big")
flag2 = int.from_bytes(flag[19:39].encode("utf-8"), "big")

print(crypto01(flag1, number1, n))
print(pow(flag2, 0xe18e, n))  # (m, e, n)
c1 = 6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076
c2 = 204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766
e = 0xe18e
# get d
# crypto02(number1,number2) == 5275692713179342445579203865706189353537836827994341954898487149932350705691539820976206193011185616275496796988659045941918467636875604795353143344710692676178394578393975888165226890434386355169374818051887033141694319039656415022384207676518904084358835476850995518006781068990050050646580072767460292472010
```

# 解题

因为数字特别大，所以可以把 p,q 近似看成下面的值。
$$
\begin{align} 
& p = 13*a \\
& q = 25*a \\
& n = p*q = 13 * 25 * a^2 \\
& a = \sqrt{n \  / 13 \ / \ 25} \\
\end{align}
$$


去check一下，如果p,q值不对，根据 p * q - n 的结果 去找a的上一个素数 或者下一个素数

```python
p = sympy.nextprime(13 * a)
q = sympy.prevprime(25 * a)
e = 0xe18e
phin = (p - 1) * (q - 1)

assert gmpy2.gcd(e, phin) == 2 # 不互素
```


$$
\begin{multline}
\shoveleft
\begin{aligned}
& c = m^e mod \ n & &  \# 前提是 e和 \phi(n) 是互素的, 现在gcd为2 \\
& c = m^{2 * \frac e 2} mod \ n & & \# m^2 替换为X, \frac e 2 替换为e1\\
& c = X^{e1} mod \ n \\
& m = \sqrt X & & 可求flag2\\

\end{aligned} \\
\end{multline}
$$


crypto01
```python
def crypto01(flag1, number1, n):
    tmp = 1
    while number1 > 0:
        if number1 % 2:
            tmp = (tmp * flag1) % n
        flag1 = flag1 ** 2 % n
        number1 //= 2
    return tmp
```

$$
\begin{multline}
\shoveleft
\begin{aligned}
& round1, number4 = m \% n , && m = m^2 \% n \\
& round2, number4 = m^2 \% n , && m = m^{2*2} \% n = m^4 \% n \\
...
& roundk, number4 = m^{2k} \% n , k=e/2 => \\
& roundk, number4 = m^e \% n \\ 
& 即 c1 = m^e \% n

\end{aligned} \\
\end{multline}
$$


```py
import gmpy2
import sympy
from Crypto.Util.number import long_to_bytes


def crypto01(flag1, e, n):  # flag1 num1 num2
    number4 = 1
    while e > 0:
        if e % 2:
            number4 = (number4 * flag1) % n
        flag1 = flag1 ** 2 % n
        e //= 2
    return number4


number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683
number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
n = number2

flag1 = 6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076
flag2 = 204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766

a = gmpy2.iroot(number2 // 25 // 13, 2)[0]


def check(a):
    p = sympy.nextprime(13 * a)
    q = sympy.prevprime(25 * a)
    assert p * q == n
    print(a)


# check(a)
a = 7876724580534791771835430594434627088013471560469412207736963203935537053220379418645369259714178145931522503674390087394035229717461111762112820042426116
p = sympy.nextprime(13 * a)
q = sympy.prevprime(25 * a)
phin = (p - 1) * (q - 1)
e = 0xe18e
assert gmpy2.gcd(e, phin) == 2
d = gmpy2.invert(e // 2, phin)
X = pow(flag2, d, n)
m2 = gmpy2.iroot(X, 2)[0]
print(long_to_bytes(m2))

assert gmpy2.gcd(number1, phin) == 1
d1 = gmpy2.invert(number1, phin)
m1 = pow(flag1, d1, n)
print(long_to_bytes(m1))

# flag:flag{75811c6d95770d56092817b75f15df05}
```